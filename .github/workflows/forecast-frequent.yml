name: Frequent Forecast Updates

on:
  schedule:
    # Every 10 minutes (GitHub cron is UTC)
    - cron: "*/10 * * * *"
  workflow_dispatch: {}

permissions:
  contents: write

concurrency:
  group: forecast-frequent
  cancel-in-progress: true

jobs:
  poll-forecasts:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: pip install requests beautifulsoup4 pytz

      # Decide whether to keep polling *today* (ET):
      # - Stop after 6pm ET OR once an "actual" for today exists in the NWS CSV
      - name: Decide polling flags (ET)
        id: decide
        run: |
          python - <<'PY'
          import os, csv, datetime, pytz
          et = pytz.timezone("America/New_York")
          now_et = datetime.datetime.now(et)
          today_iso = now_et.strftime("%Y-%m-%d")
          after_six = now_et.hour >= 18  # 6pm ET or later

          has_actual_today = False
          csv_path = "nws_forecast_log.csv"  # actuals come from NWS/CLI
          if os.path.exists(csv_path):
              with open(csv_path, newline="", encoding="utf-8") as f:
                  r = csv.DictReader(f)
                  for row in r:
                      if (
                          (row.get("forecast_or_actual") or "").strip() == "actual" and
                          (row.get("cli_date") or "").strip() == today_iso and
                          (row.get("actual_high") or "").strip() != ""
                      ):
                          has_actual_today = True
                          break

          should_log_today = (not after_six) and (not has_actual_today)

          with open(os.environ["GITHUB_ENV"], "a") as env:
              env.write(f"TODAY_ISO={today_iso}\n")
              env.write(f"AFTER_SIX_ET={'true' if after_six else 'false'}\n")
              env.write(f"HAS_ACTUAL_TODAY={'true' if has_actual_today else 'false'}\n")
              env.write(f"SHOULD_LOG_TODAY={'true' if should_log_today else 'false'}\n")

          print("today_iso:", today_iso)
          print("after_six_et:", after_six)
          print("has_actual_today:", has_actual_today)
          print("should_log_today:", should_log_today)
          PY

      # ✅ Only log today's NWS forecast when we still need it
      - name: Log today's NWS forecast (only if needed)
        if: env.SHOULD_LOG_TODAY == 'true'
        env:
          TASK: forecast_today
        run: python run_smart.py

      # ✅ Always log tomorrow's NWS forecast every run
      - name: Log tomorrow's NWS forecast
        env:
          TASK: forecast_tomorrow
        run: python run_smart.py

      # ✅ AccuWeather → accuweather_log.csv only if changed (freeze today when NWS actual exists)
      - name: Log AccuWeather forecasts if changed
        env:
          ACCU_API_KEY: ${{ secrets.ACCU_API_KEY }}
          ACCU_LOCATION_KEY: ${{ secrets.ACCU_LOCATION_KEY }}
          HAS_ACTUAL_TODAY: ${{ env.HAS_ACTUAL_TODAY }}
        run: |
          python - <<'PY'
          import os, csv, datetime, pytz, requests, sys, time

          ACCU_CSV = "accuweather_log.csv"
          API_KEY = os.environ.get("ACCU_API_KEY")
          LOC_KEY = os.environ.get("ACCU_LOCATION_KEY")
          if not API_KEY or not LOC_KEY:
              print("AccuWeather: missing API key or location key; skipping.", file=sys.stderr)
              sys.exit(0)

          et = pytz.timezone("America/New_York")
          now_et = datetime.datetime.now(et)
          today_iso = now_et.strftime("%Y-%m-%d")
          tomorrow_iso = (now_et + datetime.timedelta(days=1)).strftime("%Y-%m-%d")
          freeze_today = (os.environ.get("HAS_ACTUAL_TODAY","false").lower() == "true")

          sess = requests.Session()
          sess.headers.update({"Cache-Control": "no-cache", "Pragma": "no-cache"})

          def fetch_daily_1day_high():
              url = f"https://dataservice.accuweather.com/forecasts/v1/daily/1day/{LOC_KEY}"
              params = {
                  "apikey": API_KEY, "details": "true", "metric": "false",
                  "language": "en-us", "_ts": str(int(time.time()))
              }
              r = sess.get(url, params=params, timeout=20); r.raise_for_status()
              j = r.json()
              arr = j.get("DailyForecasts") or []
              if not arr: return None
              mx = (((arr[0] or {}).get("Temperature") or {}).get("Maximum") or {}).get("Value")
              return int(round(float(mx))) if mx is not None else None

          def fetch_daily_5day():
              url = f"https://dataservice.accuweather.com/forecasts/v1/daily/5day/{LOC_KEY}"
              params = {
                  "apikey": API_KEY, "details": "true", "metric": "false",
                  "language": "en-us", "_ts": str(int(time.time()))
              }
              r = sess.get(url, params=params, timeout=20); r.raise_for_status()
              return r.json().get("DailyForecasts", [])

          def to_iso(dstr):
              try:
                  dt = datetime.datetime.fromisoformat(dstr)
                  return dt.astimezone(et).strftime("%Y-%m-%d")
              except Exception:
                  return None

          new_highs = {}

          # D0 (today): /1day preferred (if not frozen); fallback to /5day date match
          if not freeze_today:
              d0_val = None
              try:
                  d0_val = fetch_daily_1day_high()
              except Exception as e:
                  print(f"[Accu] D0 /1day fetch failed: {e}", file=sys.stderr)
              if d0_val is None:
                  try:
                      five = fetch_daily_5day()
                      for d in five:
                          if to_iso(d.get("Date","")) == today_iso:
                              mx = (((d or {}).get("Temperature") or {}).get("Maximum") or {}).get("Value")
                              if mx is not None: d0_val = int(round(float(mx)))
                              break
                  except Exception as e:
                      print(f"[Accu] D0 /5day fallback failed: {e}", file=sys.stderr)
              if d0_val is not None:
                  new_highs[today_iso] = d0_val

          # D1 (tomorrow): use /5day INDEX 1 to avoid date drift; fallback by date
          d1_val = None
          try:
              five = fetch_daily_5day()
              if len(five) > 1:
                  mx = (((five[1] or {}).get("Temperature") or {}).get("Maximum") or {}).get("Value")
                  if mx is not None:
                      d1_val = int(round(float(mx)))
              if d1_val is None:
                  # fallback: date-match
                  for d in five:
                      if to_iso(d.get("Date","")) == tomorrow_iso:
                          mx = (((d or {}).get("Temperature") or {}).get("Maximum") or {}).get("Value")
                          if mx is not None: d1_val = int(round(float(mx)))
                          break
          except Exception as e:
              print(f"[Accu] D1 /5day fetch failed: {e}", file=sys.stderr)
          if d1_val is not None:
              new_highs[tomorrow_iso] = d1_val

          targets = [iso for iso in [today_iso, tomorrow_iso] if (iso != today_iso or not freeze_today)]
          print(f"[Accu] freeze_today={freeze_today} targets={targets} new_highs={new_highs}")

          # Read last logged Accu highs
          last_accu = {iso: None for iso in targets}
          if os.path.exists(ACCU_CSV):
              with open(ACCU_CSV, newline="", encoding="utf-8") as f:
                  r = csv.DictReader(f)
                  for row in r:
                      if (row.get("source") or "").strip() != "AccuWeather": 
                          continue
                      if (row.get("forecast_or_actual") or "").strip() != "forecast":
                          continue
                      t = (row.get("target_date") or "").strip()
                      if t in last_accu:
                          try:
                              ph = int(round(float(row.get("predicted_high") or "")))
                          except Exception:
                              ph = None
                          last_accu[t] = ph  # last seen wins
          print(f"[Accu] last_accu={last_accu}")

          # Append only if integer high changed
          fieldnames = [
              "timestamp","target_date","forecast_or_actual","forecast_time",
              "predicted_high","forecast_detail","cli_date","actual_high",
              "high_time","bias_corrected_prediction","source"
          ]
          to_append = []
          ts = now_et.strftime("%Y-%m-%d %H:%M:%S %Z")

          for iso in targets:
              nv = new_highs.get(iso)
              if nv is None:
                  continue
              pv = last_accu.get(iso)
              if pv is None or nv != pv:
                  to_append.append({
                      "timestamp": ts,
                      "target_date": iso,
                      "forecast_or_actual": "forecast",
                      "forecast_time": ts,
                      "predicted_high": str(int(nv)),
                      "forecast_detail": "accu-daily",
                      "cli_date": "",
                      "actual_high": "",
                      "high_time": "",
                      "bias_corrected_prediction": "",
                      "source": "AccuWeather",
                  })

          if to_append:
              file_exists = os.path.exists(ACCU_CSV)
              if not file_exists:
                  with open(ACCU_CSV, "w", newline="", encoding="utf-8") as f:
                      w = csv.DictWriter(f, fieldnames=fieldnames)
                      w.writeheader()
              with open(ACCU_CSV, "a", newline="", encoding="utf-8") as f:
                  w = csv.DictWriter(f, fieldnames=fieldnames)
                  for row in to_append:
                      w.writerow(row)
              print(f"AccuWeather: appended {len(to_append)} changed row(s). rows={to_append}")
          else:
              print("AccuWeather: no changes; nothing appended.")
          PY

      # Tidy CSVs (no blank lines)
      - name: Remove empty/blank lines
        run: |
          for f in nws_forecast_log.csv accuweather_log.csv; do
            if [ -f "$f" ]; then
              grep -Ev '^[[:space:]]*(,?[[:space:]]*)*$' "$f" > /tmp/clean.csv || true
              if [ -s /tmp/clean.csv ]; then
                mv /tmp/clean.csv "$f"
              fi
            fi
          done

      # Commit only if changed (rebase to avoid rejected push)
      - name: Commit and push CSV if changed
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add nws_forecast_log.csv accuweather_log.csv || true
          git commit -m "Frequent forecast update [skip ci]" || echo "No changes to commit"
          git fetch origin main
          git rebase origin/main || { echo "Rebase failed; aborting and skipping push"; git rebase --abort || true; exit 0; }
          git push origin HEAD:main || true
