<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NWS Forecast Logger Dashboard (Live)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* ===== Design Tokens ===== */
    :root{
      /* Core palette */
      --bg: #0f172a;               /* slate-900 */
      --bg-elev: #0b1220;          /* deeper backdrop for header */
      --card: #0b1220;             /* glass card base */
      --ink: #e2e8f0;              /* slate-200 */
      --muted: #8aa0b6;            /* slate-400/blue-300 mix */
      --ring: rgba(148,163,184,.25);
      --shadow: 0 14px 40px rgba(2, 8, 23, .55);

      --brand: #60a5fa;            /* blue-400 */
      --brand-2: #93c5fd;          /* blue-300 */
      --ok: #34d399;               /* emerald-400 */
      --warn: #f59e0b;             /* amber-500 */

      --card-grad-1: rgba(148,163,184,.10);
      --card-grad-2: rgba(59,130,246,.10);
      --border: rgba(148,163,184,.25);

      --radius: 16px;
      --radius-lg: 20px;
      --radius-xl: 24px;

      /* layout */
      --container: 1200px;
      --sticky-offset: 68px; /* used by sticky table header */
    }

    /* ===== Base ===== */
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:"Inter", system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      color:var(--ink); background:radial-gradient(1200px 1200px at 20% -20%, #0b2447 0%, #0f172a 45%, #0b1220 100%);
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }

    /* ===== Topbar ===== */
    .topbar{
      position:sticky; top:0; z-index:50;
      backdrop-filter:saturate(1.2) blur(10px);
      background:linear-gradient( to right, rgba(15,23,42,.85), rgba(11,18,32,.65) );
      border-bottom:1px solid var(--ring);
    }
    .topbar-inner{
      max-width:var(--container); margin:0 auto; padding:14px 20px; display:flex; align-items:center; gap:12px;
    }
    .brand{
      display:flex; align-items:center; gap:12px; flex:1;
    }
    .dot{ width:9px; height:9px; border-radius:999px; background:var(--ok); box-shadow:0 0 0 0 rgba(52,211,153,.7); animation:pulse 2s infinite; }
    @keyframes pulse{ 0%{box-shadow:0 0 0 0 rgba(52,211,153,.7)} 70%{box-shadow:0 0 0 10px rgba(52,211,153,0)} 100%{box-shadow:0 0 0 0 rgba(52,211,153,0)} }
    .title{ font-weight:700; letter-spacing:.2px; font-size:16px; color:#dbeafe }
    .sub{ font-size:12px; color:var(--muted) }

    .actions{ display:flex; align-items:center; gap:10px; }
    .btn{ appearance:none; border:1px solid var(--ring); background:linear-gradient(180deg, rgba(99,102,241,.15), rgba(59,130,246,.10));
      color:#e5edff; padding:8px 12px; border-radius:12px; font-weight:600; cursor:pointer; transition:all .2s ease;
      box-shadow:0 4px 16px rgba(2,8,23,.2);
    }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 8px 22px rgba(2,8,23,.35); border-color:rgba(99,102,241,.35) }
    .btn:active{ transform:translateY(0) scale(.98) }
    .btn-ghost{ background:transparent; color:var(--brand-2) }

    /* toggle */
    .toggle{
      display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border:1px solid var(--ring); border-radius:12px;
      background:linear-gradient(180deg, rgba(148,163,184,.12), rgba(148,163,184,.06)); cursor:pointer; user-select:none;
    }
    .toggle input{ display:none }
    .knob{ width:36px; height:22px; border-radius:999px; border:1px solid var(--ring); position:relative; background:rgba(148,163,184,.25) }
    .knob::after{ content:""; position:absolute; top:2px; left:2px; width:16px; height:16px; border-radius:50%; background:#e2e8f0; transition:left .2s }
    .toggle input:checked + .knob::after{ left:18px }

    /* ===== Layout ===== */
    .container{ max-width:var(--container); margin:28px auto 50px; padding:0 20px }
    .panel{
      background:linear-gradient(180deg, var(--card-grad-1), var(--card-grad-2));
      border:1px solid var(--border); border-radius:var(--radius-xl); box-shadow:var(--shadow);
      padding:24px 28px;
    }

    /* ===== Header Panel ===== */
    .header{ display:grid; grid-template-columns:1.2fr .8fr; gap:18px; align-items:stretch }
    .intro{ display:flex; flex-direction:column; gap:10px }
    h1{ margin:0; font-size:20px; color:#dbeafe; letter-spacing:.3px }
    .note{ color:var(--muted); margin:0 }
    #recentForecast{ color:var(--brand-2); font-weight:600; font-size:14px }

    .meta{ display:flex; align-items:center; justify-content:flex-end; gap:12px; }

    /* ===== KPI Cards ===== */
    .kpis{ margin-top:22px; display:grid; grid-template-columns:repeat(3,1fr); gap:14px }
    .kpi{ position:relative; padding:18px 20px; border-radius:18px; border:1px solid var(--border); box-shadow:0 10px 24px rgba(2,8,23,.35);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(59,130,246,.08));
    }
    .kpi small{ color:var(--muted) }
    .val{ font-size:28px; font-weight:700; letter-spacing:.2px; color:#e8f1ff; margin-top:4px }

    /* distinct accents */
    #card-today-forecast{ background:linear-gradient(180deg, rgba(253,230,138,.10), rgba(251,191,36,.10)); border-color:rgba(251,191,36,.25) }
    #card-today-actual{ background:linear-gradient(180deg, rgba(16,185,129,.10), rgba(52,211,153,.10)); border-color:rgba(34,197,94,.25) }
    #card-tomorrow-forecast{ background:linear-gradient(180deg, rgba(147,197,253,.12), rgba(59,130,246,.10)); border-color:rgba(59,130,246,.25) }

    /* mini chips + sparkline */
    .mini-forecasts{ display:flex; flex-wrap:wrap; gap:6px; margin-top:8px }
    .mini-chip{ font-size:12px; padding:2px 8px; border-radius:999px; color:#bfdbfe; background:rgba(147,197,253,.15); border:1px solid rgba(147,197,253,.3) }
    .sparkline-wrap{ margin-top:8px }
    .sparkline{ width:100%; height:34px; display:block }

    /* ===== Correction Boxes ===== */
    .two-col{ display:grid; grid-template-columns:1fr 1fr; gap:14px; margin-top:16px }
    .callout{ border-left:6px solid var(--warn); background:linear-gradient(180deg, rgba(255,221,87,.06), rgba(255,221,87,.02));
      border-radius:14px; padding:18px 22px; border:1px solid var(--border) }
    .callout b{ color:#fde68a }

    /* ===== Controls (sub-toolbar) ===== */
    .controls{
      /* no longer sticky */
      position: static; top: auto; z-index: auto; margin-top:18px; border:1px solid var(--border);
      border-radius:14px; padding:12px 14px;
      background:linear-gradient(180deg, rgba(30,41,59,.45), rgba(11,18,32,.45));
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; box-shadow:0 10px 24px rgba(2,8,23,.35);
    }
    label{ font-size:12px; color:var(--muted) }
    input[type="date"]{ font-size:14px; padding:8px 10px; border-radius:10px; border:1px solid var(--ring); background:#0b1220; color:var(--ink) }

    .btn-sm{ padding:8px 12px; border-radius:10px }
    .btn-primary{ border:1px solid rgba(59,130,246,.4); background:linear-gradient(180deg, rgba(59,130,246,.25), rgba(37,99,235,.20)); color:#e8f1ff }

    /* ===== Stats Row ===== */
    .stats{ display:grid; grid-template-columns:repeat(3,1fr); gap:14px; margin-top:14px }
    .stat-box{ background:linear-gradient(180deg, rgba(148,163,184,.10), rgba(148,163,184,.06));
      border:1px solid var(--border); border-radius:16px; padding:14px 18px }
    .stat-box .stat-val{ font-size:22px; font-weight:700; color:#e8f1ff }

    /* ===== Chart ===== */
    .chart{ margin-top:18px; padding:16px; border:1px solid var(--border); border-radius:16px; background:linear-gradient(180deg, rgba(30,41,59,.45), rgba(11,18,32,.45)); box-shadow:var(--shadow) }
    canvas{ display:block; width:100% !important; height:auto !important }

    /* ===== Table ===== */
    .table-wrap{ margin-top:18px; border:1px solid var(--border); border-radius:16px; overflow:hidden; box-shadow:var(--shadow) }
    #dataTable{ width:100%; border-collapse:separate; border-spacing:0; font-size:14px; background:rgba(2,6,23,.45); }
    thead th{ position:sticky; top:0; z-index:5; text-align:center; padding:12px 8px; color:#c7d2fe; background:linear-gradient(180deg, rgba(15,23,42,.98), rgba(11,18,32,.94)); border-bottom:1px solid var(--ring); backdrop-filter:blur(8px) }
    tbody td{ text-align:center; padding:10px 8px; border-bottom:1px solid rgba(148,163,184,.12); color:#e5e9f5 }
    tbody tr:nth-child(even) td{ background:rgba(148,163,184,.03) }
    tbody tr:hover td{ background:rgba(59,130,246,.08) }

    .forecast-row td{ background:rgba(251,191,36,.05) }
    .actual-row td{ background:rgba(16,185,129,.05) }
    .best{ outline:2px solid rgba(52,211,153,.65); outline-offset:-2px } 
    /* Highlight the best forecast row without clipping lines */
    

    /* Skeleton loader */
    .skel td::before{ content:""; display:block; height:10px; margin:6px auto; width:70%;
      background:linear-gradient(90deg, rgba(148,163,184,.18), rgba(148,163,184,.05), rgba(148,163,184,.18));
      background-size:200% 100%; animation:sh 1.2s infinite linear; border-radius:6px }
    @keyframes sh{ from{background-position:0 0} to{background-position:200% 0} }

    /* narrow the "Actual High" column */
    #dataTable th:nth-child(5), #dataTable td:nth-child(5){ width: 90px }

    /* Responsive */
    @media (max-width: 980px){
      .header{ grid-template-columns:1fr }
      .kpis{ grid-template-columns:1fr; }
      .two-col{ grid-template-columns:1fr }
      .stats{ grid-template-columns:1fr }
      :root{ --sticky-offset: 62px }
    }
  </style>
</head>
<body>
  <!-- ===== Sticky Topbar ===== -->
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <span class="dot" aria-hidden="true"></span>
        <div>
          <div class="title">NWS Forecast Logger Dashboard<span class="sub"> — Central Park, NY</span></div>
          <div class="sub">Auto‑logs NWS forecasts and compares against the official daily high</div>
        </div>
      </div>
      <div class="actions">
        <label class="toggle" title="Dark UI is on by default">
          <input type="checkbox" id="themeToggle" checked>
          <span class="knob"></span>
          <span class="sub">Dark</span>
        </label>
        <button class="btn btn-ghost" onclick="reloadCSV()">Reload</button>
      </div>
    </div>
  </div>

  <div class="container">
    <!-- ===== Intro + Recent ===== -->
    <section class="panel header">
      <div class="intro">
        <h1>Forecast Overview</h1>
        <p class="note">Automatically logs every NWS forecast update for Central Park and compares to the official daily high. Happy Betting!?.</p>
        <div id="recentForecast">Last logged forecast: …</div>
      </div>
      <div class="meta">
        <!-- Space reserved for future metadata (run time, data age, etc.) -->
      </div>

      <!-- KPI Cards -->
      <div class="kpis" style="grid-column:1 / -1">
        <div class="kpi" id="card-today-forecast">
          <small>Today’s Latest Forecasted High</small>
          <div id="box-today-forecast" class="val">–</div>
          <div id="mini-today-forecasts" class="mini-forecasts"></div>
          <div class="sparkline-wrap"><canvas id="spark-today-forecast" class="sparkline" width="260" height="34"></canvas></div>
        </div>
        <div class="kpi" id="card-today-actual">
          <small>Today’s Actual High</small>
          <div id="box-today-actual" class="val">–</div>
        </div>
        <div class="kpi" id="card-tomorrow-forecast">
          <small>Tomorrow’s Forecasted High</small>
          <div id="box-tomorrow-forecast" class="val">–</div>
        </div>
      </div>
    </section>

    <!-- ===== Corrected Predictions ===== -->
    <section class="two-col">
      <div id="correctionBoxToday" class="callout">Loading…</div>
      <div id="correctionBoxTomorrow" class="callout">Loading…</div>
    </section>

    <!-- ===== Controls ===== -->
    <section class="controls">
      <label for="fromDate">From</label>
      <input type="date" id="fromDate" />
      <label for="toDate">To</label>
      <input type="date" id="toDate" />
      <button class="btn btn-sm btn-primary" onclick="applyDateFilter()">Filter</button>
      <button class="btn btn-sm btn-ghost" onclick="resetFilter()">Show All</button>
    </section>

    <!-- ===== Stats ===== -->
    <section class="stats">
      <div class="stat-box">Total Days: <span class="stat-val">0</span></div>
      <div class="stat-box">Avg Absolute Error (all forecasts): <span class="stat-val">--°F</span></div>
      <div class="stat-box">Avg Best Error (pre‑high best): <span class="stat-val">--°F</span></div>
    </section>

    <!-- ===== Chart ===== -->
    <section class="chart panel">
      <canvas id="dailyChart" width="1100" height="420"></canvas>
    </section>

    <!-- ===== Table ===== -->
    <section class="table-wrap">
      <table id="dataTable">
        <thead>
          <tr>
            <th>Date Pulled</th>
            <th>Forecast Time</th>
            <th>For Date</th>
            <th>Forecasted High</th>
            <th>Actual High</th>
            <th>High Time</th>
            <th>Error (°F)</th>
            <th>Best?</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </div>

  <!-- ===== Scripts ===== -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    /*
      NOTE: All original IDs & function names preserved so your CSV + logic continue working.
      You can drop this file in as a replacement. Only UI/UX polish has been added
      (sticky toolbars, glassy cards, consistent type scale, better contrast, responsive layout).
    */

    let allRows = [];
    let filteredRows = [];

    /* NYC-local ISO date helper (YYYY-MM-DD) */
    function nycISODate(offsetDays=0){
      const fmt = new Intl.DateTimeFormat('en-CA', { timeZone:'America/New_York', year:'numeric', month:'2-digit', day:'2-digit' });
      const parts = fmt.formatToParts(new Date(Date.now()+offsetDays*86400000));
      const g = k => parts.find(p => p.type === k).value;
      return `${g('year')}-${g('month')}-${g('day')}`;
    }

    /* ---------------- CSV load + parsing ---------------- */
    function showSkeleton(rows=6){
      const tb=document.querySelector("#dataTable tbody"); tb.innerHTML="";
      for(let i=0;i<rows;i++){
        const tr=document.createElement("tr"); tr.className="skel"; tr.innerHTML="<td></td>".repeat(8);
        tb.appendChild(tr);
      }
    }

    function reloadCSV() {
      showSkeleton();
      fetch("https://raw.githubusercontent.com/hwaheed13/nws-forecast-logger/main/nws_forecast_log.csv?"+Date.now())
        .then(resp => resp.text())
        .then(parseCSV)
        .then(() => {
          resetFilter();            // populates table, chart, stats
          showMostRecent();         // truly latest forecast entry
          updateSummaryBoxes();     // summary cards (and today's mini history + sparkline)
          updateCorrectionBoxes();  // corrected predictions (avg of all forecasts for date)
        })
        .catch(err => { alert("Could not load CSV. " + err); });
    }

    // robust CSV parsing
    function csvToRows(text) {
      const rows = [];
      let row = [], field = '', inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const c = text[i], n = text[i+1];
        if (c === '"') {
          if (inQuotes && n === '"') { field += '"'; i++; }
          else { inQuotes = !inQuotes; }
        } else if (c === ',' && !inQuotes) {
          row.push(field); field = '';
        } else if ((c === '\n' || c === '\r') && !inQuotes) {
          if (c === '\r' && n === '\n') i++;
          row.push(field); field = '';
          if (row.length && row.some(x => x !== '')) rows.push(row);
          row = [];
        } else {
          field += c;
        }
      }
      if (field !== '' || row.length) {
        row.push(field);
        if (row.length && row.some(x => x !== '')) rows.push(row);
      }
      return rows;
    }

    function parseCSV(text) {
      const rows = csvToRows(text);
      if (!rows.length) return;
      const header = rows[0].map(h => h.trim());
      allRows = [];
      for (let i = 1; i < rows.length; i++) {
        const vals = rows[i];
        const rec = {};
        for (let j = 0; j < header.length; j++) {
          let v = (vals[j] ?? '').trim();
          if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1).replace(/""/g, '"');
          rec[header[j]] = v;
        }
        allRows.push(rec);
      }
    }

    /* ---------------- Filters & helpers ---------------- */
    function resetFilter() {
      filteredRows = allRows.slice();
      document.getElementById('fromDate').value = "";
      document.getElementById('toDate').value = "";
      displayTable();
      showStats();
      showChart();
      showMostRecent();
      updateCorrectionBoxes();
      updateSummaryBoxes();
    }

    function applyDateFilter() {
      const from = document.getElementById('fromDate').value;
      const to = document.getElementById('toDate').value;
      filteredRows = allRows.filter(row => {
        const date = row.forecast_or_actual === "actual" ? row.cli_date : row.target_date;
        if (!date) return false;
        if (from && date < from) return false;
        if (to && date > to) return false;
        return true;
      });
      displayTable();
      showStats();
      showChart();
      showMostRecent();
      updateCorrectionBoxes();
      updateSummaryBoxes();
    }

    function rNum(x){ const n=Number(x); return Number.isFinite(n)?n:null; }

    function compareTimes(t1,t2) { const d1 = toDateObj(t1), d2 = toDateObj(t2); return (d1&&d2) ? d1-d2 : 0 }
    function toDateObj(t) {
      if (!t) return null;
      if (/[AP]M/i.test(t)) {
        const m = t.match(/(\d{1,2}):(\d{2})\s*([AP]M)/i);
        if (!m) return null;
        const [,h,mn,amp] = m;
        const hour = Number(h)%12 + (amp.toUpperCase()==="PM"?12:0);
        return new Date(2020,1,1,hour,Number(mn));
      }
      if (/^\d{2}:\d{2}$/.test(t)) { const [h,mn]=t.split(":"); return new Date(2020,1,1,Number(h),Number(mn)) }
      return null;
    }

    /* -------- Last logged forecast = the final forecast row in the CSV -------- */
    function showMostRecent() {
      const el = document.getElementById("recentForecast");
      if (!allRows.length) { el.textContent = ""; return; }
      for (let i = allRows.length - 1; i >= 0; i--) {
        const r = allRows[i];
        if (r && r.forecast_or_actual === "forecast" && r.predicted_high && r.target_date) {
          const when = r.timestamp || r.forecast_time || "(time unknown)";
          el.innerHTML = `Last logged forecast: <b>${when}</b> — <b>${r.predicted_high}°F</b> (for <b>${r.target_date}</b>)`;
          return;
        }
      }
      el.textContent = "";
    }

    /* -------- Helpers for today's mini history -------- */
    function getForecastsForDate(dateISO) {
      const rows = allRows
        .filter(r => r.forecast_or_actual === "forecast" && r.target_date === dateISO && r.predicted_high)
        .map(r => ({ tstamp: r.timestamp || r.forecast_time || "", timeHHMM: (r.forecast_time || "").substr(11,5), val: Number(r.predicted_high) }))
        .filter(x => Number.isFinite(x.val));
      rows.sort((a,b) => (a.tstamp || "").localeCompare(b.tstamp || ""));
      return rows;
    }
    function renderMiniForecastChips(rows, elId) {
      const host = document.getElementById(elId); if (!host) return; host.innerHTML = "";
      const compact = []; rows.forEach((r, i) => { if (i === 0 || r.val !== rows[i-1].val) compact.push(r) });
      if (!compact.length) { host.innerHTML = `<span class="mini-chip">No forecasts yet</span>`; return; }
      compact.forEach(r => { const label = `${r.timeHHMM || "—"} ${r.val.toFixed(0)}°`; const chip = document.createElement("span"); chip.className = "mini-chip"; chip.textContent = label; host.appendChild(chip) });
    }
    function drawSparkline(canvasId, rows) {
      const cv = document.getElementById(canvasId); if (!cv) return; const ctx = cv.getContext('2d'); ctx.clearRect(0,0,cv.width,cv.height);
      if (!rows.length) return; const W = cv.width, H = cv.height, pad = 2; const vals = rows.map(r => r.val); const min = Math.min(...vals), max = Math.max(...vals);
      if (max === min) { const y = H/2; ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(W-pad, y); ctx.lineWidth = 2; ctx.strokeStyle = '#93c5fd'; ctx.stroke(); ctx.beginPath(); ctx.arc(W-pad, y, 2.5, 0, Math.PI*2); ctx.fillStyle = '#34d399'; ctx.fill(); return; }
      const n = vals.length; const xStep = (W - pad*2) / Math.max(1, n-1); const toY = v => H - pad - ((v - min) / (max - min)) * (H - pad*2);
      ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = '#93c5fd'; vals.forEach((v, i) => { const x = pad + i * xStep; const y = toY(v); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y) }); ctx.stroke();
      const lastX = pad + (n-1)*xStep, lastY = toY(vals[n-1]); ctx.beginPath(); ctx.arc(lastX, lastY, 2.5, 0, Math.PI*2); ctx.fillStyle = '#34d399'; ctx.fill();
    }

    /* ---------------- Summary boxes (includes mini history) ---------------- */
    function updateSummaryBoxes() {
      const today    = nycISODate(0);
      const tomorrow = nycISODate(1);
      const latestForDate = (date) => {
        const rows = allRows.filter(r => r.forecast_or_actual === "forecast" && r.target_date === date && r.predicted_high);
        if (!rows.length) return null; rows.sort((a,b) => { const A = a.timestamp || a.forecast_time || ""; const B = b.timestamp || b.forecast_time || ""; return B.localeCompare(A) });
        return Number(rows[0].predicted_high);
      };
      const avgForDate = (date) => { const vals = allRows.filter(r => r.forecast_or_actual==="forecast" && r.target_date===date && r.predicted_high).map(r => Number(r.predicted_high)); if (!vals.length) return null; return vals.reduce((a,b)=>a+b,0)/vals.length };
      const todayLatestForecast = latestForDate(today);
      const todayActualRow = allRows.find(r => r.forecast_or_actual==="actual" && r.cli_date===today && r.actual_high);
      const todayActual = todayActualRow ? Number(todayActualRow.actual_high) : null;
      const tomorrowAvgForecast = avgForDate(tomorrow);

      document.getElementById("box-today-forecast").textContent  = (todayLatestForecast==null) ? "–" : todayLatestForecast.toFixed(1) + "°F";
      document.getElementById("box-today-actual").textContent    = (todayActual==null) ? "–" : todayActual.toFixed(1) + "°F";
      document.getElementById("box-tomorrow-forecast").textContent= (tomorrowAvgForecast==null) ? "–" : tomorrowAvgForecast.toFixed(1) + "°F";

      const todayRows = getForecastsForDate(today);
      renderMiniForecastChips(todayRows, "mini-today-forecasts");
      drawSparkline("spark-today-forecast", todayRows);
    }

    /* ---------------- Bias over ALL available days, using pre-high forecasts only ---------------- */
    function calcBiases(){
      const biasList = [], dayMap = {};
      allRows.forEach(r => { const d = r.forecast_or_actual==="actual" ? r.cli_date : r.target_date; if(!d) return; if(!dayMap[d]) dayMap[d] = []; dayMap[d].push(r); });
      const dates = Object.keys(dayMap).sort();
      dates.forEach(d => {
        const rows = dayMap[d];
        const actual = rows.find(r => r.forecast_or_actual==="actual" && r.actual_high);
        if(!actual) return; const actualHigh = Number(actual.actual_high); const highTime = actual.high_time || "";
        const fcVals = [];
        rows.forEach(r => { if(r.forecast_or_actual!=="forecast" || !r.predicted_high) return; if (highTime) { const fcHHMM = (r.forecast_time||"").substr(11,5); if (fcHHMM && compareTimes(fcHHMM, highTime) > 0) return; } fcVals.push(Number(r.predicted_high)); });
        if(fcVals.length){ const meanFc = fcVals.reduce((a,b)=>a+b,0)/fcVals.length; biasList.push(actualHigh - meanFc); }
      });
      return biasList; // ALL qualifying days
    }

    /* ---------------- Corrected predictions ---------------- */
    function updateCorrectionBoxes(){
      const biasList=calcBiases();
      const avgBias=biasList.length? (biasList.reduce((a,b)=>a+b,0)/biasList.length) : 0;
      const today    = nycISODate(0);
      const tomorrow = nycISODate(1);
      const meanForecastForDate = (date) => {
        const actual = allRows.find(r=>r.forecast_or_actual==="actual" && r.cli_date===date && r.actual_high);
        const highTime = actual ? actual.high_time : "";
        const vals = allRows
          .filter(r=>r.forecast_or_actual==="forecast" && r.target_date===date && r.predicted_high)
          .filter(r=>{ if(highTime){ const fcHHMM=(r.forecast_time||"").substr(11,5); if(fcHHMM && compareTimes(fcHHMM, highTime) > 0) return false; } return true; })
          .map(r=>Number(r.predicted_high));
        if (!vals.length) return null; return vals.reduce((a,b)=>a+b,0)/vals.length;
      };
      const todayFcAvg    = meanForecastForDate(today);
      const tomorrowFcAvg = meanForecastForDate(tomorrow);
      const todayPred    = (todayFcAvg==null) ? null : todayFcAvg + avgBias;
      const tomorrowPred = (tomorrowFcAvg==null) ? null : tomorrowFcAvg + avgBias;
      const biasTxt = (avgBias>0?"+":"") + avgBias.toFixed(2);
      document.getElementById("correctionBoxToday").innerHTML =
        `<b>Today's Corrected Prediction:</b><br>
         <span style="font-size:1.6em; color:#e8f1ff">${today}: <b>${todayPred==null?"–":todayPred.toFixed(1)+"°F"}</b></span><br>
         <span style="color:#cbd5e1">Bias: <b>${biasTxt}°F</b> (avg of ${biasList.length} days)</span>`;
      document.getElementById("correctionBoxTomorrow").innerHTML =
        `<b>Tomorrow's Corrected Prediction:</b><br>
         <span style="font-size:1.6em; color:#e8f1ff">${tomorrow}: <b>${tomorrowPred==null?"–":tomorrowPred.toFixed(1)+"°F"}</b></span><br>
         <span style="color:#cbd5e1">Bias: <b>${biasTxt}°F</b> (avg of ${biasList.length} days)</span>`;
    }

    /* ---------------- Stats ---------------- */
    function showStats() {
      let count=0, absSum=0, bestSum=0, bestCount=0; const dayMap = {};
      filteredRows.forEach(row => { const date = row.forecast_or_actual === "actual" ? row.cli_date : row.target_date; if (!date) return; if (!dayMap[date]) dayMap[date] = []; dayMap[date].push(row); });
      Object.values(dayMap).forEach(dayRows => { const actual = dayRows.find(r => r.forecast_or_actual==="actual"); const actualHigh = actual ? Number(actual.actual_high) : null; if (!Number.isFinite(actualHigh)) return; const highTime = actual ? actual.high_time : ""; let bestErr=999;
        dayRows.forEach(r => { if (r.forecast_or_actual!=="forecast" || !r.predicted_high) return; if (highTime) { const fcHour = (r.forecast_time||"").substr(11,5); if (fcHour && compareTimes(fcHour, highTime)>0) return; } const err = Math.abs(Number(r.predicted_high)-actualHigh); absSum += err; count++; if (err<bestErr) bestErr=err; });
        if (bestErr<999) { bestSum += bestErr; bestCount++; }
      });
      const avgAbs = count ? (absSum/count).toFixed(2) : "--"; const avgBest = bestCount ? (bestSum/bestCount).toFixed(2) : "--";
      document.querySelector('.stats').innerHTML = `
        <div class="stat-box">Total Days: <span class="stat-val">${Object.keys(dayMap).length}</span></div>
        <div class="stat-box">Avg Absolute Error (all forecasts): <span class="stat-val">${avgAbs}°F</span></div>
        <div class="stat-box">Avg Best Error (pre‑high best): <span class="stat-val">${avgBest}°F</span></div>
      `;
    }

    /* ---------------- Chart ---------------- */
    function showChart() {
      const ctx = document.getElementById('dailyChart').getContext('2d');
      if (window.mainChart) window.mainChart.destroy();
      const dayMap = {};
      filteredRows.forEach(row => { const date = row.forecast_or_actual === "actual" ? row.cli_date : row.target_date; if (!date) return; if (!dayMap[date]) dayMap[date] = []; dayMap[date].push(row); });
      const labels=[], actuals=[], bestForecasts=[];
      Object.keys(dayMap).sort().forEach(date => {
        const dayRows = dayMap[date]; const actual = dayRows.find(r => r.forecast_or_actual==="actual"); const actualHigh = actual ? Number(actual.actual_high) : null; const highTime = actual ? actual.high_time : ""; let best=null, bestErr=999;
        dayRows.forEach(r => { if (r.forecast_or_actual!=="forecast" || !r.predicted_high) return; if (highTime) { const fcHour=(r.forecast_time||"").substr(11,5); if (fcHour && compareTimes(fcHour, highTime)>0) return; } const err = Math.abs(Number(r.predicted_high)-actualHigh); if (err<bestErr) { bestErr=err; best=r; } });
        if (actualHigh !== null) { labels.push(date); actuals.push(actualHigh); bestForecasts.push(best ? Number(best.predicted_high) : null); }
      });
      window.mainChart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [
          { label: "Actual High", data: actuals, borderColor: "#34d399", backgroundColor: "transparent", tension: .25, pointRadius: 0 },
          { label: "Best Forecast (pre‑high)", data: bestForecasts, borderColor: "#93c5fd", backgroundColor: "transparent", tension: .25, pointRadius: 0 }
        ]},
        options: {
          plugins: {
            legend: { labels: { color: '#c7d2fe', usePointStyle:true } },
            tooltip: { intersect:false, mode:'index' }
          },
          scales: {
            x: { ticks:{ color:'#a5b4fc' }, grid:{ color:'rgba(148,163,184,.15)' }, title:{ display:true, text:'Date', color:'#cbd5e1' } },
            y: { ticks:{ color:'#a5b4fc' }, grid:{ color:'rgba(148,163,184,.15)' }, title:{ display:true, text:'Temperature (°F)', color:'#cbd5e1' } }
          }
        }
      });
    }

    /* ---------------- Table ---------------- */
    function displayTable() {
      const tb = document.querySelector("#dataTable tbody"); tb.innerHTML = ""; const dayMap = {};
      filteredRows.forEach(r => { const date = r.forecast_or_actual === "actual" ? r.cli_date : r.target_date; if (!date) return; if (!dayMap[date]) dayMap[date]=[]; dayMap[date].push(r); });
      Object.keys(dayMap).sort().forEach(date => {
        const dayRows = dayMap[date]; const actual = dayRows.find(r => r.forecast_or_actual==="actual"); const actualHigh = actual ? rNum(actual.actual_high) : null; const actualHighTxt = actual && actual.actual_high ? actual.actual_high+"°F" : ""; const highTime = actual ? actual.high_time : ""; let bestIdx=-1, bestErr=999;
        dayRows.forEach((r,i) => { if (r.forecast_or_actual !== "forecast" || !r.predicted_high || actualHigh===null) return; if (highTime) { const fcHour = (r.forecast_time||"").substr(11,5); if (fcHour && compareTimes(fcHour, highTime)>0) return; } const err = Math.abs(Number(r.predicted_high)-actualHigh); if (err<bestErr) { bestErr=err; bestIdx=i; } });
        dayRows.forEach((r,i) => {
          if (r.forecast_or_actual!=="forecast" && r.forecast_or_actual!=="actual") return;
          let cls = r.forecast_or_actual==="actual" ? "actual-row" : "forecast-row"; if (i===bestIdx && r.forecast_or_actual==="forecast") cls += " best";
          const pred = r.predicted_high ? r.predicted_high+"°F" : ""; const act = r.actual_high ? r.actual_high+"°F" : actualHighTxt; const fTime = r.forecast_time ? r.forecast_time.substr(11,5) : "";
          const errTxt = (r.forecast_or_actual==="forecast" && r.predicted_high && actualHigh!==null) ? (Number(r.predicted_high)-actualHigh).toFixed(1) : "";
          tb.innerHTML += `
            <tr class="${cls}">
              <td>${r.timestamp ? r.timestamp.substr(0,10) : ""}</td>
              <td>${fTime}</td>
              <td>${date}</td>
              <td>${pred}</td>
              <td>${act}</td>
              <td>${highTime}</td>
              <td>${errTxt}</td>
              <td>${(i===bestIdx && r.forecast_or_actual==="forecast") ? "✔️" : ""}</td>
            </tr>`;
        });
      });
    }

    /* ----- Light/Dark theme toggle (dark default) ----- */
    const themeToggle = document.getElementById('themeToggle');
    themeToggle?.addEventListener('change', () => {
      document.documentElement.classList.toggle('light', !themeToggle.checked);
    });

    /* Optional light theme overrides */
    (function injectLightTheme(){
      const css = `
        .light body{ background:radial-gradient(1200px 1200px at 20% -20%, #e5f1ff 0%, #f5f7fb 45%, #eef3fb 100%) }
        .light :root{ --ink:#17324a; --muted:#5c728a; --border:rgba(23,50,74,.15) }
        .light .topbar{ background:linear-gradient( to right, rgba(255,255,255,.9), rgba(255,255,255,.7) ); border-bottom:1px solid rgba(23,50,74,.12) }
        .light .title{ color:#175398 }
        .light .panel, .light .chart{ background:linear-gradient(180deg, rgba(255,255,255,.95), rgba(255,255,255,.85)); border-color:rgba(23,50,74,.12) }
        .light .kpi{ background:linear-gradient(180deg, rgba(255,255,255,.95), rgba(255,255,255,.85)); border-color:rgba(23,50,74,.12) }
        .light .val, .light .stat-box .stat-val{ color:#17324a }
        .light #recentForecast{ color:#175398 }
        .light .mini-chip{ color:#175398; background:#e8f2ff; border-color:#cfe6ff }
        .light #dataTable{ background:#fff }
        .light thead th{ background:linear-gradient(180deg, rgba(255,255,255,.98), rgba(255,255,255,.92)); color:#175398; border-bottom:1px solid rgba(23,50,74,.12) }
        .light tbody td{ color:#17324a; border-bottom:1px solid rgba(23,50,74,.08) }
        .light .forecast-row td{ background:#fff7e6 }
        .light .actual-row td{ background:#ecfff4 }
        .light .controls{ background:linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.82)); border-color:rgba(23,50,74,.12) }
      `;
      const tag = document.createElement('style'); tag.innerHTML = css; document.head.appendChild(tag);
      document.documentElement.classList.remove('light'); // default dark on
    })();

    /* ---------------- Boot ---------------- */
    reloadCSV();
  </script>
</body>
</html>
