<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üå°Ô∏è Daily Dew Point Dashboard</title>

  <!-- Performance hints -->
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="dns-prefetch" href="https://fonts.googleapis.com">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-primary: #fafbfc;
      --bg-secondary: #ffffff;
      --bg-tertiary: #f8f9fa;
      --bg-accent: #f1f5f9;
      --text-primary: #0f172a;
      --text-secondary: #334155;
      --text-muted: #64748b;
      --text-light: #94a3b8;
      --border-subtle: #e2e8f0;
      --border-default: #cbd5e1;
      --accent-blue: #2563eb;
      --accent-blue-light: #dbeafe;
      --accent-green: #059669;
      --accent-green-light: #d1fae5;
      --accent-amber: #d97706;
      --accent-amber-light: #fef3c7;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, .05);
    }

    * { box-sizing: border-box; }

    /* Gate (shows immediately, then hidden on boot) */
    #gate {
      display: flex; align-items: center; justify-content: center;
      min-height: 100vh;
      background: var(--bg-primary); color: var(--text-primary);
      font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif;
      padding: 24px; text-align: center;
    }
    .gate-card { background: var(--bg-secondary); border: 1px solid var(--border-subtle);
      border-radius: 16px; padding: 24px 22px; box-shadow: var(--shadow-sm);
      max-width: 520px; width: 100%;
    }
    .gate-title { font-size: 18px; font-weight: 800; margin: 0 0 6px; }
    .gate-sub { font-size: 14px; color: var(--text-muted); margin: 0 0 12px; }
    .gate-note { font-size: 12px; color: var(--text-light); }
    .gate-spinner { width: 28px; height: 28px; border-radius: 50%;
      border: 3px solid var(--border-subtle); border-top-color: var(--accent-blue);
      margin: 12px auto 8px; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* App */
    body {
      font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif;
      background: var(--bg-primary); color: var(--text-primary);
      margin: 0; line-height: 1.6;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }

    .header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-subtle);
      padding: 20px 0; position: sticky; top: 0; z-index: 10; backdrop-filter: blur(8px);
    }
    .header-content { max-width: 1400px; margin: 0 auto; padding: 0 20px;
      display: flex; align-items: center; justify-content: space-between; }
    .brand { display: flex; align-items: center; justify-content: space-between; gap: 14px; }
    .brand-left { display: flex; align-items: center; gap: 12px; }
    .brand-mark { display: grid; place-items: center; width: 40px; height: 40px;
      border-radius: 12px; background: linear-gradient(135deg, var(--accent-blue-light), var(--accent-green-light));
      box-shadow: var(--shadow-sm); border: 1px solid var(--border-subtle); position: relative; top: -3px; }
    .brand-mark svg { display: block; transform: translate(1px, 1px); }
    .brand-title { margin: 0; font-weight: 800; letter-spacing: .2px;
      font-size: 28px; line-height: 1.15; color: var(--text-primary); }
    .brand-title .thin { font-weight: 600; color: var(--text-secondary); }
    .brand-sub { margin: 2px 0 0; font-size: 13px; color: var(--text-muted); }
    .brand-right { display: flex; flex-direction: column; align-items: flex-end; gap: 6px; }
    .brand-right .pill-group { display: flex; gap: 6px; }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; font-size: 12px; font-weight: 700;
      color: var(--text-secondary); background: var(--bg-accent); border: 1px solid var(--border-subtle); border-radius: 999px; }
    .pill.live { background: var(--accent-green-light); color: var(--accent-green); border-color: transparent; }
    .pill.live .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--accent-green); animation: pulse 2s infinite; }
    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.5} }
    .pill.logout-btn { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-default); }

    .container { max-width: 1400px; margin: 0 auto; padding: 24px; }

    .last-update { background: var(--bg-secondary); border: 1px solid var(--border-subtle);
      border-radius: 12px; padding: 18px 20px; margin-bottom: 20px; box-shadow: var(--shadow-sm); }
    .last-update-label { font-size: 12px; color: var(--text-muted); letter-spacing: .06em; text-transform: uppercase; margin-bottom: 4px; font-weight: 600; }
    .last-update-content { font-size: 15px; color: var(--text-secondary); font-weight: 600; }
    #todayDate { display: block; font-size: 14px; font-weight: 700; color: var(--text-primary); margin-bottom: 2px; }

    .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 18px; margin-bottom: 22px; }
    .metric-card { background: var(--bg-secondary); border: 1.5px solid var(--border-subtle); border-radius: 18px; padding: 24px;
      box-shadow: var(--shadow-sm); position: relative; overflow: hidden; }
    .metric-card::before { content: ''; position: absolute; inset: 0 0 auto; height: 4px;
      background: linear-gradient(90deg, var(--accent-blue), var(--accent-green)); }
    .metric-card.today-forecast::before { background: var(--accent-amber); }
    .metric-card.today-obs::before { background: var(--accent-blue); }
    .metric-card.today-actual::before { background: var(--accent-green); }
    .metric-card.tomorrow-forecast::before { background: var(--accent-blue); }
    .metric-label { font-size: 14px; color: var(--text-muted); margin-bottom: 6px; font-weight: 700; letter-spacing: .02em; }
    .metric-value { font-size: 36px; font-weight: 800; color: var(--text-primary); margin-bottom: 10px; line-height: 1; }
    .metric-subtitle { font-size: 13px; color: var(--text-light); }
    .mini-forecasts { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px; }
    .mini-chip { background: var(--bg-accent); color: var(--text-secondary); padding: 4px 10px; border-radius: 999px;
      font-size: 12px; font-weight: 700; border: 1px solid var(--border-subtle); }

    .kalshi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 18px; margin-bottom: 22px; }
    .kalshi-card { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 16px; padding: 22px; }
    .kalshi-badge { background: var(--accent-amber-light); color: var(--accent-amber);
      padding: 8px 14px; border-radius: 999px; font-size: 14px; font-weight: 800; text-decoration: none; display: inline-block; }
    .kalshi-pending { background: var(--bg-accent); color: var(--text-muted); padding: 8px 14px; border-radius: 999px; font-size: 14px; font-weight: 700; border: 2px dashed var(--border-default); }
    .kalshi-note { font-size: 12px; color: var(--text-light); margin-top: 6px; }

    .prediction-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(360px, 1fr)); gap: 18px; margin-bottom: 22px; }
    .prediction-card { background: linear-gradient(135deg, var(--accent-blue-light), var(--accent-green-light));
      border: 1px solid var(--border-subtle); border-radius: 16px; padding: 24px; }
    .prediction-title { font-size: 15px; font-weight: 800; margin-bottom: 12px; }
    .prediction-content {}
    .prediction-value { font-size: 28px; font-weight: 800; color: #1f2937; }
    .prediction-subtitle { font-size: 13px; color: var(--text-secondary); }

    .controls-section { background: var(--bg-secondary); border: 1px solid var(--border-subtle);
      border-radius: 16px; padding: 18px; margin-bottom: 22px; }
    .controls-title { font-size: 15px; font-weight: 800; margin-bottom: 10px; }
    .controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .control-group { display: flex; align-items: center; gap: 6px; }
    .control-label { font-size: 13px; font-weight: 700; color: var(--text-secondary); }
    input[type="date"] { padding: 8px 10px; border: 1px solid var(--border-default); border-radius: 10px; font-size: 14px; background: var(--bg-secondary); }
    input[type="date"]:focus { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 3px var(--accent-blue-light); }
    .btn { background: var(--accent-blue); color: #fff; border: none; border-radius: 10px; padding: 9px 16px; font-size: 14px; font-weight: 800; cursor: pointer; box-shadow: var(--shadow-sm); }
    .btn.secondary { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-default); }

    .stats-grid { 
  display: grid; 
  grid-template-columns: repeat(3, 1fr);  /* Force 3 columns on desktop */
  gap: 16px; 
  margin-bottom: 22px; 
}

/* Tablet: 3 columns but tighter */
@media (max-width: 900px) {
  .stats-grid { 
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
  }
  .stat-card { padding: 14px; }
  .stat-label { font-size: 12px; }
  .stat-value { font-size: 24px; }
}

/* Mobile: keep existing 2 column layout */
@media (max-width: 600px) {
  .stats-grid { 
    grid-template-columns: repeat(2, 1fr); 
    gap: 8px; 
  }
  .stat-card { padding: 10px; }
  .stat-label { font-size: 11px; }
  .stat-value { font-size: 22px; }
}
    .stat-card { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 14px; padding: 18px; text-align: center; }
    .stat-label { font-size: 13px; color: var(--text-muted); font-weight: 700; }
    .stat-value { font-size: 28px; font-weight: 800; color: var(--accent-blue); }

    .chart-section { background: var(--bg-secondary); border: 1px solid var(--border-subtle);
      border-radius: 16px; padding: 24px; margin-bottom: 22px; }
    .chart-title { font-size: 16px; font-weight: 800; margin-bottom: 14px; }
    .chart-container { position: relative; height: clamp(220px, 38vh, 380px); width: 100%; }

    .table-section { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 16px; padding: 0; overflow: hidden; }
    .table-container { 
      overflow: auto;  /* Changed from overflow-x to handle both directions */
      max-height: 600px;  /* Fixed height makes it scrollable */
      border-top: 1px solid var(--border-subtle); 
      padding: 0 18px 18px; 
    }
    #dataTable { width: 100%; border-collapse: collapse; font-size: 14px; background: var(--bg-secondary); }
    #dataTable th { background: var(--bg-tertiary); color: var(--text-primary); padding: 12px 10px; text-align: left; font-weight: 800;
      font-size: 12px; letter-spacing: .06em; text-transform: uppercase; border-bottom: 2px solid var(--border-default); position: sticky; top: 0; z-index: 1; }
    #dataTable td { padding: 12px 10px; border-bottom: 1px solid var(--border-subtle); color: var(--text-secondary); }
    #dataTable tbody tr:hover { background: var(--bg-accent); }
    .forecast-row { background: var(--accent-blue-light) !important; }
    .actual-row { background: var(--accent-green-light) !important; }
    .best { box-shadow: inset 0 0 0 2px var(--accent-green); }
    details.table-wrap { border-top: 1px solid var(--border-subtle); }
    details.table-wrap summary { background: var(--bg-accent); border-bottom: 1px solid var(--border-subtle);
      list-style: none; cursor: pointer; padding: 16px 18px; font-weight: 800; display: flex; align-items: center; justify-content: space-between; }
    details.table-wrap summary::-webkit-details-marker { display: none; }
    .caret { transition: transform .2s ease; }
    details[open] summary .caret { transform: rotate(90deg); }
    .skel td::before { content: ""; display: block; height: 12px; margin: 4px 0; width: 70%;
      background: linear-gradient(90deg, var(--bg-accent), var(--bg-tertiary), var(--bg-accent));
      background-size: 200% 100%; animation: shimmer 1.5s infinite; border-radius: 4px; }
    @keyframes shimmer { 0%{background-position:-200% 0} 100%{background-position:200% 0} }

    .footer { margin-top: 28px; padding: 18px 24px; background: var(--bg-tertiary); border-top: 1px solid var(--border-subtle);
      text-align: center; font-size: 12px; color: var(--text-light); }
    .footer a { color: var(--accent-blue); text-decoration: none; }

    /* Month group header row */
    #dataTable tr.month-row { background: var(--bg-tertiary); border-top: 2px solid var(--border-default); cursor: pointer; }
    #dataTable tr.month-row td { font-weight: 800; font-size: 12px; letter-spacing: .06em; text-transform: uppercase;
      color: var(--text-primary); padding: 10px 10px; }
    #dataTable tr.month-row .caret { display: inline-block; transition: transform .18s ease; margin-right: 6px; }
    #dataTable tr.month-row.collapsed .caret { transform: rotate(-90deg); }
    #dataTable tr[data-month].is-hidden { display: none; }

    /* Fluid sizes + mobile */
    .brand-title { font-size: clamp(18px, 2.2vw, 28px); }
    .metric-value { font-size: clamp(22px, 3vw, 36px); }
    .prediction-value { font-size: clamp(20px, 2.6vw, 28px); }
    .stat-value { font-size: clamp(18px, 2.4vw, 28px); }
    .kalshi-badge { font-size: clamp(11px, 1.8vw, 14px); padding: 6px 10px; }
    .pill { font-size: clamp(10px, 1.6vw, 12px); padding: 4px 8px; }

    @media (max-width: 600px) {
      .container { padding: 12px; }
      .header { padding: 12px 0; }
      .brand { gap: 8px; }
      .brand-left { gap: 8px; }
      .brand-mark { width: 32px; height: 32px; border-radius: 10px; top: -17px; }
      .brand-mark svg { width: 28px; height: 28px; transform: translate(0, 0); }
      .brand-sub { font-size: 12px; line-height: 1.35; }
      .brand-right .pill-group { margin-top: -14px; }
      .pill.logout-btn { margin-top: 18px; }
      .metrics-grid, .prediction-grid, .kalshi-grid { grid-template-columns: 1fr; gap: 10px; }
      .metric-card { padding: 14px; border-radius: 14px; }
      .metric-label { font-size: 13px; }
      .metric-subtitle { font-size: 12px; }
      .prediction-card { padding: 14px; }
      .stats-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; }
      .stat-card { padding: 10px; }
      .stat-label { font-size: 11px; }
      .stat-value { font-size: 22px; }
      .mini-forecasts { gap: 4px; }
      .mini-chip { font-size: 11px; padding: 3px 8px; }
      .controls-section { padding: 12px; }
      .controls { gap: 8px; }
      .control-label { font-size: 12px; }
      input[type="date"] { font-size: 13px; padding: 7px 8px; border-radius: 8px; }
      .btn { font-size: 13px; padding: 8px 12px; border-radius: 8px; }
      .chart-section { padding: 14px; }
      .chart-title { font-size: 14px; margin-bottom: 10px; }
      .chart-container { height: 260px; }
      .table-container { padding: 0 12px 12px; }
      #dataTable { font-size: 12px; }
      #dataTable th { font-size: 11px; padding: 10px 8px; }
      #dataTable td { padding: 10px 8px; }
      .brand-right { gap: 6px; flex-wrap: wrap; justify-content: flex-start; }
      .pill { flex: 0 1 auto; }
      .pill .dot { width: 5px; height: 5px; }
      .last-update-label { font-size: 10px; }
      .last-update-content { font-size: 13px; line-height: 1.35; }
    }

    @media (min-width: 601px) {
      .pill.logout-btn { margin-top: 10px; background: #e5e7eb; color: var(--text-primary);
        border: 1px solid var(--border-default); font-size: 14px; padding: 8px 14px; border-radius: 12px; }
    }

    .brand-right .pill-sep { flex: 0 0 12px; }

    /* Desktop gutter push + styling for billing/logout */
    @media (min-width: 960px) {
      #btn-billing, #btn-logout {
        position: relative;
        left: calc(max(0px, (100vw - 1400px) / 2 - 12px));
        margin-top: -6px;
      }
      .pill.logout-btn { margin-top: -6px; }
      #btn-billing {
        margin-top: -4px; background: #dbeafe; color: #2563eb; border: 1px solid #93c5fd;
      }
      #btn-billing:hover { background: #bfdbfe; }
    }
    #btn-billing, #btn-logout { cursor: pointer; transition: transform .02s ease, box-shadow .15s ease, opacity .15s ease; }
    #btn-billing:hover, #btn-logout:hover { box-shadow: 0 2px 8px rgba(0,0,0,.08); }
    #btn-billing:active, #btn-logout:active { transform: translateY(1px); opacity: .9; }

    /* 2-col grid on desktop for pills/billing/logout */
    @media (min-width: 960px) {
      .brand-right { display: grid; grid-template-columns: auto auto; column-gap: 12px; row-gap: 10px; align-items: center; justify-items: end; }
      .brand-right .pill-group { grid-column: 1; grid-row: 1; }
      #btn-billing { grid-column: 2; grid-row: 1; }
      #btn-logout { grid-column: 2; grid-row: 2; }
      #btn-billing, #btn-logout { left: calc(max(0px, (100vw - 1400px) / 2 - 6px)); }
      #btn-billing { margin-top: -2px; background: #dbeafe; color: #2563eb; border: 1px solid #93c5fd; }
      #btn-billing:hover { background: #bfdbfe; }
    }

    /* Last update row + badge */
    .lu-top { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:20px; flex-wrap:wrap; }
    .lu-date { display:block; font-size:14px; font-weight:700; color:var(--text-primary); text-transform:uppercase; letter-spacing:.02em; margin-bottom:2px; }
    .lu-badge { white-space:nowrap; font-size:12px; font-weight:800; color:#b91c1c; margin-top:4px; }
    @media (max-width: 600px) {
      .lu-top { gap:6px; margin-bottom:2px; }
      .lu-date { margin-bottom:0; }
      .lu-badge { font-size:10px; white-space:normal; display:block; margin-top:0; text-align:right; }
      .last-update-label { font-size:11px; }
    }
    @media (max-width: 600px) {
      .last-update .lu-badge { display:block; margin-top:-6px; }
    }

    /* Tooltip */
    .tip { display:inline-flex; align-items:center; justify-content:center; width:16px; height:16px; border-radius:50%;
      font-size:11px; font-weight:800; line-height:1; cursor:help;
      border:1px solid var(--border-default); color:var(--text-secondary);
      background:var(--bg-tertiary); margin-left:6px; position:relative; outline:none; }
    .tip:hover { box-shadow: 0 1px 6px rgba(0,0,0,.08); }
    .tip:focus-visible { box-shadow: 0 0 0 3px var(--accent-blue-light); }
    .tip[data-tip]::after{
      content:attr(data-tip); position:absolute; inset:auto auto calc(100% + 8px) 50%; transform:translateX(-50%);
      white-space:nowrap; background:#111827; color:#fff; font-size:12px; font-weight:600; padding:6px 8px; border-radius:8px;
      box-shadow:0 4px 12px rgba(0,0,0,.15); opacity:0; pointer-events:none; transition:opacity .12s ease, transform .12s ease;
    }
    .tip[data-tip]::before{
      content:""; position:absolute; inset:auto auto calc(100% + 3px) 50%; transform:translateX(-50%);
      border:6px solid transparent; border-top-color:#111827; opacity:0; transition:opacity .12s ease;
    }
    .tip:hover[data-tip]::after,.tip:focus[data-tip]::after,.tip:hover[data-tip]::before,.tip:focus[data-tip]::before{opacity:1;}
        /* Mobile tooltip fixes */
    @media (max-width: 600px) {
      .tip[data-tip]::after {
        white-space: normal;  /* Allow text to wrap */
        width: 200px;         /* Fixed width for consistency */
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
      }
      
      /* If tooltip would go off left edge, shift it right */
      .stat-card:nth-child(odd) .tip[data-tip]::after {
        left: 0;
        transform: translateX(0);
      }
      
      /* If tooltip would go off right edge, shift it left */
      .stat-card:nth-child(even) .tip[data-tip]::after {
        left: auto;
        right: 0;
        transform: translateX(0);
      }
      
      /* Adjust arrow position for shifted tooltips */
      .stat-card:nth-child(odd) .tip[data-tip]::before {
        left: 16px;
        transform: translateX(0);
      }
      
      .stat-card:nth-child(even) .tip[data-tip]::before {
        left: auto;
        right: 16px;
        transform: translateX(0);
      }
    }
  /* Mobile-only adjustments for prediction formula subtitle */
    @media (max-width: 600px) {
      .prediction-subtitle small {
        display: block;
        margin-top: 4px;
        font-size: 10px;
        line-height: 1.3;
      }
      
      .prediction-card {
        padding-bottom: 14px !important;
      }
      
      .prediction-disclaimer {
        font-size: 10px !important;
      }
    }
  </style>
</head>
  
<body>
  <!-- ====== LOGIN GATE ====== -->
  <div id="gate" role="status" aria-live="polite">
    <div class="gate-card">
      <div class="gate-title">Checking access‚Ä¶</div>
      <div class="gate-sub">Loading the dashboard.</div>
      <div class="gate-spinner" aria-hidden="true"></div>
      <div class="gate-note">This will update automatically.</div>
    </div>
  </div>

  <!-- ====== APP ====== -->
  <div id="app" style="display:none">
    <header class="header">
      <div class="header-content brand">
        <div class="brand-left">
          <div class="brand-mark" aria-hidden="true">
            <svg viewBox="0 0 64 64" width="38" height="38" role="img">
              <defs>
                <linearGradient id="dpGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                  <stop offset="0%" stop-color="var(--accent-blue)" />
                  <stop offset="100%" stop-color="var(--accent-green)" />
                </linearGradient>
              </defs>
              <path fill="url(#dpGrad)" d="M32 6c6 10 16 18 16 30 0 9.94-8.06 18-18 18s-18-8.06-18-18C12 24 26 16 32 6z"/>
            </svg>
          </div>
          <div class="brand-copy">
            <h1 class="brand-title"><span class="thin">Daily</span> Dew&nbsp;Point</h1>
            <p class="brand-sub">Automatically logs every NWS forecast update for Central Park and compares to the official daily high</p>
          </div>
        </div>
        <div class="brand-right">
          <div class="pill-group">
            <span class="pill live"><span class="dot"></span> Live</span>
            <span class="pill">NYC</span>
            <span class="pill">KNYC</span>
          </div>
          <button id="btn-billing" class="pill">Manage billing</button>
          <button id="btn-logout" class="pill logout-btn">Log out</button>
        </div>
      </div>
    </header>

    <div class="container">
      <div class="last-update">
        <div class="lu-top">
          <span id="todayDate" class="lu-date"></span>
          <span class="lu-badge">All times and day boundary are Eastern Time (aligned with NWS)</span>
        </div>
        <div class="last-update-label">Latest Forecast Update</div>
        <div id="recentForecast" class="last-update-content">Loading latest forecast data...</div>
      </div>

      <!-- Metrics -->
      <div class="metrics-grid">
        <div class="metric-card today-forecast">
          <div class="metric-label">Today's Latest Forecast</div>
          <div id="box-today-forecast" class="metric-value">‚Äì</div>
          <div class="metric-subtitle">Today's Forecasts</div>
          <div id="mini-today-forecasts" class="mini-forecasts"></div>
        </div>

        <div class="metric-card today-actual">
          <div class="metric-label">Today's High (DSM)</div>
          <div id="box-dsm-max" class="metric-value">‚Äì</div>
          <div id="box-dsm-note" class="metric-subtitle"></div>
          <div style="margin-top:16px; padding-top:14px; border-top:1px solid var(--border-subtle);">
            <div class="metric-label" style="margin-bottom:6px;">Today's Actual High (CLI)</div>
            <div id="box-today-actual" class="metric-value">‚Äì</div>
            <div id="box-today-actual-note" class="metric-subtitle">NWS daily climatological report</div>
          </div>
        </div>

        <div class="metric-card today-obs">
          <div class="metric-label">6 Hr Max</div>
          <div id="box-6hr-max" class="metric-value">‚Äì</div>
          <div id="box-6hr-max-note" class="metric-subtitle"></div>
          <div style="margin-top:16px; padding-top:14px; border-top:1px solid var(--border-subtle);">
            <div class="metric-label">Recent Observed Temperature</div>
            <div id="box-today-current" class="metric-value">‚Äì</div>
            <div id="box-today-current-note" class="metric-subtitle"></div>
          </div>
        </div>

        <div class="metric-card tomorrow-forecast">
          <div class="metric-label">Tomorrow's Latest Forecast</div>
          <div id="box-tomorrow-forecast" class="metric-value">‚Äì</div>
          <div class="metric-subtitle">Tomorrow's Forecasts</div>
          <div id="mini-tomorrow-forecasts" class="mini-forecasts"></div>
        </div>
      </div>

      <!-- Bias-corrected -->
      <div class="prediction-grid" style="display:grid; grid-template-columns:repeat(2,1fr); gap:18px; margin-bottom:22px;">
        <div class="prediction-card">
          <div class="prediction-title">
            Today's Bias-Corrected Prediction
            <span class="tip" tabindex="0" data-tip="Starts with yesterday‚Äôs forecast for today, updates if additional forecasts come in, and locks once the actual high is reported">i</span>
          </div>
          <div id="correctionBoxToday" class="prediction-content">Loading...</div>
        </div>
        <div class="prediction-card">
          <div class="prediction-title">
            Tomorrow's Bias-Corrected Prediction
            <span class="tip" tabindex="0" data-tip="Uses today‚Äôs forecasts for tomorrow. Once tomorrow begins, updates with that day‚Äôs forecasts if any are issued">i</span>
          </div>
          <div id="correctionBoxTomorrow" class="prediction-content">Loading...</div>
        </div>
        <div class="prediction-disclaimer" style="grid-column:1 / span 2; font-size:12px; color:var(--text-light); margin-top:-4px;">
        Based on historical forecast accuracy patterns; updates as new forecasts arrive. Bias correction reduces average error over many days, but NWS can still miss on individual days.
      </div>
      </div>

      <!-- Kalshi -->
      <div class="kalshi-grid">
        <div class="kalshi-card">
          <div class="metric-label">Today's Kalshi Market</div>
          <div id="box-today-kalshi" class="metric-value" style="font-size:18px;">Pending settlement</div>
          <div id="box-today-kalshi-note" class="kalshi-note"></div>
        </div>
        <div class="kalshi-card">
          <div class="metric-label">Yesterday's Kalshi Result</div>
          <div id="box-yday-kalshi" class="metric-value" style="font-size:18px;">‚Äì</div>
          <div id="box-yday-kalshi-note" class="kalshi-note"></div>
        </div>
      </div>

      <!-- Controls -->
      <div class="controls-section">
        <div class="controls-title">Filter Data</div>
        <div class="controls">
          <div class="control-group">
            <label class="control-label" for="fromDate">From:</label>
            <input type="date" id="fromDate"/>
          </div>
          <div class="control-group">
            <label class="control-label" for="toDate">To:</label>
            <input type="date" id="toDate"/>
          </div>
          <button class="btn" onclick="applyDateFilter()">Apply Filter</button>
          <button class="btn secondary" onclick="resetFilter()">Show All</button>
          <button class="btn secondary" onclick="reloadCSV()">Refresh Data</button>
        </div>
      </div>

      <!-- Stats -->
      <div class="stats-grid" id="stats">
        <div class="stat-card">
          <div class="stat-label">Days Tracked</div>
          <div class="stat-value">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Days With Actual</div>
          <div class="stat-value">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Average Absolute Error</div>
          <div class="stat-value">--¬∞F</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Average Best Error</div>
          <div class="stat-value">--¬∞F</div>
        </div>
      </div>

      <!-- Chart -->
      <div class="chart-section">
        <div class="chart-title">Temperature Trends: Actual vs Forecasted</div>
        <div class="chart-container">
          <canvas id="dailyChart" width="1000" height="380"></canvas>
        </div>
      </div>

      <!-- Collapsible Table -->
      <div class="table-section">
        <details class="table-wrap">
          <summary>
            <span>Detailed Forecast Log</span>
            <span class="caret">‚ñ∏</span>
          </summary>
          <div class="table-container">
            <table id="dataTable">
              <thead>
                <tr>
                  <th>Date Pulled</th>
                  <th>Forecast Time</th>
                  <th>For Date</th>
                  <th>Forecasted High</th>
                  <th>Actual High</th>
                  <th>High Time</th>
                  <th>Error (¬∞F)</th>
                  <th>Best?</th>
                  <th>Kalshi Range</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </details>
      </div>
    </div>

    <footer class="footer">
      ¬© 2025 Dewdrop Ventures, LLC ¬∑
      <a href="/terms.html">Terms</a> ¬∑
      <a href="/privacy.html">Privacy</a> ¬∑
      <span>Informational only ‚Äî not financial advice. Do your own due diligence before placing any bets or making financial decisions.</span>
    </footer>
  </div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- App scripts -->
  <script>
    /* ========= SIMPLE GATE ========= */
    const $gate = () => document.getElementById('gate');
    const $app  = () => document.getElementById('app');

    function showApp(){ const g=$gate(), a=$app(); if(g) g.style.display='none'; if(a) a.style.display=''; }
    function showGate(msg){ const g=$gate(); if(!g) return; g.style.display=''; const sub=g.querySelector('.gate-sub'); if(sub&&msg) sub.textContent=msg; }
    window.showApp = showApp;
    window.showGate = showGate;

/* ========= DATA + UI ========= */
let allRows = [], filteredRows = [], chartInstance = null, accuRows = [];

// --- Helpers: separate NWS vs AccuWeather rows ---
function getNwsForecastRowsFor(targetISO, kind) {
  const dayPrev = prevISO(targetISO);
  return allRows.filter(r => {
    if ((r.forecast_or_actual || "") !== "forecast") return false;
    if ((r.target_date || "") !== targetISO) return false;
    
    const issueISO = etDateISOFromTS(r.timestamp || r.forecast_time || "");
    if (!issueISO) return false;
    
    if (kind === "D0") return issueISO === targetISO;
    if (kind === "D1") return issueISO === dayPrev;
    if (!kind) return true; // If no kind specified, return all forecasts for this target
    
    return false;
  });
}

    // === Online ensemble (Hedge) + Bias EWMA (self-learning) =====================
const ENS_KEY = "hedge_v3";               // bump to reset everything
const ETA = 0.25;                         // learning rate per ¬∞F (Hedge)
const MIX_GAMMA = 0.02;                   // uniform mix-in to avoid collapse
const DECAY_PER_DAY = 0.997;              // gently decay old info
const BIAS_HALFLIFE_DAYS = 21;            // bias recency (~1 month)
const RMSE_HALFLIFE_DAYS = 21;            // uncertainty recency for clamp

function loadState(key){
  const raw = localStorage.getItem(`${ENS_KEY}:${key}`);
  return raw ? JSON.parse(raw) : null;
}
function saveState(key, obj){
  try { localStorage.setItem(`${ENS_KEY}:${key}`, JSON.stringify(obj)); } catch {}
}
function decayWeights(ws){ for (const k in ws) ws[k] *= DECAY_PER_DAY; }
function contextKey(lead, season){ return `${lead}:${season}`; } // lead: 'today'|'tomorrow'

function softmaxNormalize(obj){
  let sum = 0; for (const k in obj) sum += obj[k];
  if (sum <= 0) { const ks = Object.keys(obj); const n = ks.length || 1; ks.forEach(k => obj[k]=1/n); return; }
  for (const k in obj) obj[k] /= sum;
}
function mixWithUniform(weights, gamma= MIX_GAMMA){
  const ks = Object.keys(weights); if (!ks.length) return;
  const n = ks.length;
  ks.forEach(k => { weights[k] = (1 - gamma) * weights[k] + gamma * (1 / n); });
}
function ewmaUpdate(old, value, halfLifeDays){
  if (value == null) return old ?? null;
  const alpha = (halfLifeDays && halfLifeDays > 0)
    ? 1 - Math.exp(-Math.log(2) / halfLifeDays)
    : 1;
  return (old == null) ? value : (1 - alpha) * old + alpha * value;
}

// Build candidates + envelope for a target date.
// Uses your existing d0CandidatesFor, d1CandidatesFor, combineSeries, repFromSeries.
function buildCandidatesForDay(targetISO, highTime){
  const c0 = d0CandidatesFor(targetISO, highTime);   // today-for-today (pre-high)
  const c1 = d1CandidatesFor(targetISO);             // yesterday-for-today, or today-for-tomorrow

  const seriesAll = combineSeries(c1.series, c0.series);
  const seriesRep = repFromSeries(seriesAll); // (keep your current rep; easy to swap to time-aware later)

  const candidates = {};
  if (c1.latest  != null) candidates.D1_latest  = Number(c1.latest);
  if (c1.trimmed != null) candidates.D1_trimmed = Number(c1.trimmed);
  if (c0.latest  != null) candidates.D0_latest  = Number(c0.latest);
  if (c0.trimmed != null) candidates.D0_trimmed = Number(c0.trimmed);
  if (seriesRep  != null) candidates.series_rep = Number(seriesRep);

  // --- AccuWeather injection (ENUMERABLE OWN KEY) ---
 const accD0 = latestPreHighValue(getAccuRowsFor(targetISO, "D0"), "");
const accD1 = latestPreHighValue(getAccuRowsFor(targetISO, "D1"), "");
  const accVal = Number.isFinite(accD1) ? accD1 : (Number.isFinite(accD0) ? accD0 : null);
  if (accVal != null) {
    candidates.AccuWeather = Number(accVal); // plain assignment => enumerable, own
  }

  // envelope + latest issuance (unchanged)
  const vals = [];
  (c1.series||[]).forEach(r=>{ const v=Number(r.predicted_high); if(Number.isFinite(v)) vals.push(v); });
  (c0.series||[]).forEach(r=>{ const v=Number(r.predicted_high); if(Number.isFinite(v)) vals.push(v); });
  const envelope = vals.length ? { lo: Math.min(...vals), hi: Math.max(...vals) } : { lo:null, hi:null };
  const latestIssuanceRow = (seriesAll && seriesAll.length) ? seriesAll[seriesAll.length-1] : null;

  return { candidates, envelope, latestIssuanceRow, c0, c1, seriesAll };
}

// Make a prediction with Hedge (+ stored bias)
function predictWithHedge(lead, season, candidates, rmseContext){
  const key = contextKey(lead, season);
  let st = loadState(key) || { w:{}, bias:null, rmse:null, lastDay:null };

  const names = Reflect.ownKeys(candidates).filter(k => typeof k === 'string');
  if (!names.length) return { y:null, y0:null, bias:0, pad:2, weights:{}, key };

  // init on first use
  if (!Object.keys(st.w).length) {
    const init = 1 / names.length;
    names.forEach(n => st.w[n] = init);
} else {
    // Check for new candidates
    const existingNames = Object.keys(st.w);
    const newNames = names.filter(n => !(n in st.w));
    
    if (newNames.length > 0) {
      // If AccuWeather is joining, reset everyone to equal weight for fair competition
        if (newNames.includes('AccuWeather')) {
          const equalWeight = 1 / names.length;
          names.forEach(n => st.w[n] = equalWeight);
          console.log(`AccuWeather joined: all ${names.length} sources reset to ${(equalWeight*100).toFixed(1)}% weight each`);
          // persist immediately and refresh UI once, so the 25% shows up right away
          saveState(key, st);
          if (typeof window.updateCorrectionBoxes === 'function') {
            setTimeout(window.updateCorrectionBoxes, 0);
          }
        } else {
          // For other new sources, use minimal weight as before
          newNames.forEach(n => st.w[n] = 1e-6);
        }

    }
  }

  // small uniform mix to prevent collapse
  mixWithUniform(st.w, MIX_GAMMA);

  const denom = names.reduce((s,n)=>s + (st.w[n]||0), 0) || 1;
  const y0 = names.reduce((s,n)=>s + (st.w[n]||0) * candidates[n], 0) / denom;

  const bias = st.bias ?? 0;
  const y = (y0 == null) ? null : (y0 + bias);

  // clamp pad from stored RMSE or provided context
  const pad = Math.max(2, Number(st.rmse ?? rmseContext ?? 0) || 0);

  return { y, y0, bias, pad, weights:{...st.w}, key };
}

// Update Hedge weights + Bias/RMSE when an actual arrives
function updateHedgeOnActual(lead, season, candidates, actual, dayISO){
  const key = contextKey(lead, season);
  let st = loadState(key) || { w:{}, bias:null, rmse:null, lastDay:null, learnCounts:{} };

  // Track how many times each candidate has been trained
  if (!st.learnCounts) st.learnCounts = {};

  const names = Object.keys(candidates);
  if (!names.length || actual == null) return;

  if (st.lastDay && st.lastDay !== dayISO) decayWeights(st.w);
  st.lastDay = dayISO;

  // compute pre-bias ensemble pred for residual
  mixWithUniform(st.w, MIX_GAMMA);
  const denom = names.reduce((s,n)=>s + (st.w[n]||0), 0) || 1;
  const y0 = names.reduce((s,n)=>s + (st.w[n]||0) * candidates[n], 0) / denom;
  const yhat = (st.bias ?? 0) + (y0 ?? 0);

  const err = Number(actual) - Number(yhat);
  const absErr = Math.abs(err);

  // Hedge update with boost for new sources
  for (const n of names){
    const li = Math.abs(Number(candidates[n]) - Number(actual));
    
    // Boost learning rate for sources with < 10 observations
    const count = st.learnCounts[n] || 0;
    const etaBoost = count < 10 ? 2.0 : 1.0; // 2x learning rate for new sources
    
    st.w[n] = (st.w[n] || 0) * Math.exp(-ETA * etaBoost * li);
    st.learnCounts[n] = count + 1;
  }
  softmaxNormalize(st.w);
  mixWithUniform(st.w, MIX_GAMMA);

  // Bias EWMA (clip to ¬±6¬∞F to damp outliers)
  const clipped = Math.max(-6, Math.min(6, err));
  st.bias = ewmaUpdate(st.bias, clipped, BIAS_HALFLIFE_DAYS);

  // RMSE EWMA (for clamp pad)
  const sq = Math.min(36, err*err);
  const oldVar = st.rmse == null ? null : (st.rmse*st.rmse);
  const varNew = ewmaUpdate(oldVar, sq, RMSE_HALFLIFE_DAYS);
  st.rmse = varNew == null ? st.rmse : Math.sqrt(Math.max(0, varNew));

  saveState(key, st);
}
    function pretrainFromHistory() {
  // Collect which days have an actual
  const byDay = new Map();
  for (const r of allRows) {
    const day = (r.forecast_or_actual === "actual" ? r.cli_date : r.target_date);
    if (!/^\d{4}-\d{2}-\d{2}$/.test(day || "")) continue;
    if (!byDay.has(day)) byDay.set(day, { actual: null });
    if (r.forecast_or_actual === "actual" && r.actual_high) byDay.get(day).actual = r;
  }

  for (const [iso, { actual }] of byDay.entries()) {
    if (!actual || actual.actual_high == null) continue;

    const season  = isWarmSeason(iso) ? "warm" : "cool";
    const hiTime  = actual.high_time || "";
    const actualF = Number(actual.actual_high);

    // Train the "today" policy using everything you'd have for that day
    const builtToday = buildCandidatesForDay(iso, hiTime);
    updateHedgeOnActual("today", season, builtToday.candidates, actualF, iso);

    // Train the "tomorrow" policy using only D1 info (what you knew the day before)
    const d1 = d1CandidatesFor(iso);
    const candTomorrow = {};
    if (d1.latest  != null) candTomorrow.D1_latest  = Number(d1.latest);
    if (d1.trimmed != null) candTomorrow.D1_trimmed = Number(d1.trimmed);
    const rep1 = repFromSeries(d1.series);
    if (rep1 != null) candTomorrow.series_rep = Number(rep1);
    // --- AccuWeather (D1 for this iso) ---
    const accD1 = latestPreHighValue(getAccuRowsFor(iso, "D1"), "");
    if (Number.isFinite(accD1)) {
      candTomorrow.AccuWeather = Number(accD1);
    }
    updateHedgeOnActual("tomorrow", season, candTomorrow, actualF, iso);
  }
}
window.pretrainFromHistory = pretrainFromHistory;
function resetHedgeState(){
  const keys = [];
  for (let i=0; i<localStorage.length; i++){
    const k = localStorage.key(i);
    if (k && k.startsWith(`${ENS_KEY}:`)) keys.push(k);
  }
  keys.forEach(k => localStorage.removeItem(k));
}

function historySignature(){
  const last = allRows[allRows.length-1] || {};
  return `${allRows.length}|${last.timestamp||last.date_pulled||''}|${last.cli_date||last.target_date||''}`;
}

async function warmOnceForCurrentCSV(){
  const sigKey = `${ENS_KEY}:trained_sig`;
  const sig = historySignature();
  if (localStorage.getItem(sigKey) === sig) return;  // already warmed for this data
  resetHedgeState();           // start from clean state
  pretrainFromHistory();       // train on CSV once
  try { localStorage.setItem(sigKey, sig); } catch {}
}

// optional: expose for debugging
window.resetHedgeState = resetHedgeState;
window.warmOnceForCurrentCSV = warmOnceForCurrentCSV;

    // === Header date (ET) ===
      function showTodayDate() {
        const el = document.getElementById('todayDate');
        if (!el) return;
        const label = new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/New_York',
          weekday: 'short',
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        }).format(new Date());
        el.textContent = label;
      }
      
      function scheduleMidnightUpdate() {
        showTodayDate();                   // set immediately
        setInterval(showTodayDate, 60 * 1000); // refresh once a minute
      }
      
      // expose to the UMD boot block
      window.showTodayDate = showTodayDate;
      window.scheduleMidnightUpdate = scheduleMidnightUpdate;


    function nycISODate(offsetDays = 0) {
      const fmt = new Intl.DateTimeFormat('en-CA', {
        timeZone: 'America/New_York', year: 'numeric', month: '2-digit', day: '2-digit'
      });
      const parts = fmt.formatToParts(new Date(Date.now() + offsetDays * 86400000));
      const g = k => parts.find(p => p.type === k).value;
      return `${g('year')}-${g('month')}-${g('day')}`;
    }

    function kalshiAnchorForISO(dateISO) {
      const [y,m,d] = dateISO.split('-').map(Number);
      const dt = new Date(Date.UTC(y, m-1, d));
      const mon = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'][dt.getUTCMonth()];
      const dd = String(dt.getUTCDate()).padStart(2,'0');
      const yy = String(dt.getUTCFullYear()).slice(-2);
      return `#kxhighny-${yy}${mon}${dd}`;
    }

    function showSkeleton(rows = 6) {
      const tb = document.querySelector("#dataTable tbody");
      if (!tb) return;
      tb.innerHTML = "";
      for (let i = 0; i < rows; i++) {
        const tr = document.createElement("tr");
        tr.className = "skel";
        tr.innerHTML = "<td></td>".repeat(9);
        tb.appendChild(tr);
      }
    }

   // Global holder for AccuWeather rows
accuRows = [];

function reloadCSV(opts = {}) {
  const skipUI = !!opts.skipUI;
  showSkeleton();

  // Fetch NWS + AccuWeather concurrently
  return Promise.all([
    fetch(CSV_URL + "?" + Date.now()).then(r => r.text()),
    fetch(ACCU_URL + "?" + Date.now()).then(r => r.text()).catch(() => "")
  ])
  .then(([nwsText, accuText]) => {
    // Parse NWS (UI + ensemble base)
    parseCSV(nwsText);

    // Parse AccuWeather separately
    accuRows = [];
    if (accuText && accuText.trim()) {
      const rows = csvToRows(accuText);
      const header = rows[0].map(h => h.trim());
      for (let i = 1; i < rows.length; i++) {
        const vals = rows[i];
        const rec = {};
        for (let j = 0; j < header.length; j++) {
          let v = (vals[j] ?? "").trim();
          if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1).replace(/""/g, '"');
          rec[header[j]] = v;
        }
        accuRows.push(rec);
      }
    }

    // Continue normal boot
    seedForecastSignatures();
    lastActualSig = actualSignatureFor(allRows);
    forecastChanged.today = false;
    forecastChanged.tomorrow = false;

    if (!skipUI) {
      resetFilter();
      showMostRecent();
      updateSummaryBoxes();
      updateCorrectionBoxes();
      updateCorrectionBoxes();
      updateObservations();
    }
  })
  .catch(err => {
    alert("Could not load CSVs. " + err);
    throw err;
  });
}

    function csvToRows(text) {
      const rows = [];
      let row = [], field = '', q = false;
      for (let i = 0; i < text.length; i++) {
        const c = text[i], n = text[i + 1];
        if (c === '"') {
          if (q && n === '"') { field += '"'; i++; } else q = !q;
        } else if (c === ',' && !q) {
          row.push(field); field = '';
        } else if ((c === '\n' || c === '\r') && !q) {
          if (c === '\r' && n === '\n') i++;
          row.push(field); field = '';
          if (row.length && row.some(x => x !== '')) rows.push(row);
          row = [];
        } else field += c;
      }
      if (field !== '' || row.length) {
        row.push(field);
        if (row.length && row.some(x => x !== '')) rows.push(row);
      }
      return rows;
    }

    function parseCSV(text) {
      const rows = csvToRows(text);
      if (!rows.length) return;
      const header = rows[0].map(h => h.trim());
      allRows = [];
      for (let i = 1; i < rows.length; i++) {
        const vals = rows[i];
        const rec = {};
        for (let j = 0; j < header.length; j++) {
          let v = (vals[j] ?? '').trim();
          if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1).replace(/""/g, '"');
          rec[header[j]] = v;
        }
        allRows.push(rec);
      }
    }

    function rNum(x){ const n=Number(x); return Number.isFinite(n)? n : null; }

    function toDateObj(t) {
      if (!t) return null;
      const clean = String(t).trim().replace(/:(\d{2})(?=\s*[AP]M)/i, '');
      if (/[AP]M/i.test(clean)) {
        const m = clean.match(/(\d{1,2}):(\d{2})\s*([AP]M)/i);
        if (!m) return null;
        const [, h, mn, amp] = m;
        const hour = (Number(h) % 12) + (amp.toUpperCase() === "PM" ? 12 : 0);
        return new Date(2020, 1, 1, hour, Number(mn));
      }
      if (/^\d{2}:\d{2}$/.test(clean)) {
        const [h, mn] = clean.split(":");
        return new Date(2020, 1, 1, Number(h), Number(mn));
      }
      return null;
    }
    function compareTimes(t1, t2) { const d1=toDateObj(t1), d2=toDateObj(t2); return (d1&&d2)? d1-d2 : 0; }

    // ===== ET date helpers =====
    function etDateISOFromTS(ts) {
      const s = (ts || "").replace(" ", "T"); const d = new Date(s);
      if (!Number.isFinite(d.getTime())) return "";
      return new Intl.DateTimeFormat("en-CA", { timeZone: "America/New_York", year:"numeric", month:"2-digit", day:"2-digit" }).format(d);
    }
    function prevISO(iso) { const d = new Date(iso + "T00:00:00"); d.setDate(d.getDate()-1); return d.toISOString().slice(0,10); }
    function monthNum(iso){ return Number((iso||"").split("-")[1]||"0"); }
    function isWarmSeason(iso){ const m=monthNum(iso); return m>=5 && m<=9; }

    // ===== Lead kind =====
    function leadKind(row){
      if (!row || !row.target_date) return "other";
      const issueISO = etDateISOFromTS(row.timestamp || row.forecast_time || "");
      if (!issueISO) return "other";
      if (issueISO === row.target_date) return "D0";
      if (issueISO === prevISO(row.target_date)) return "D1";
      return "other";
    }

  // ===== Row selectors =====
  function getForecastRowsFor(targetISO, kind, source){
    const rows = (String(source||"") === "AccuWeather") ? accuRows : allRows;
    const dayPrev = prevISO(targetISO);
    return rows.filter(r => {
      if ((r.forecast_or_actual||"") !== "forecast") return false;
      if ((r.target_date||"") !== targetISO) return false;
  
      // optional strict source filter (for NWS vs Accu explicit calls)
      if (source && String(r.source||"").trim() !== String(source).trim()) return false;
  
      const issueISO = etDateISOFromTS(r.timestamp || r.forecast_time || "");
      if (kind === "D0") return issueISO === targetISO;
      if (kind === "D1") return issueISO === dayPrev;
      return false;
    });
  }

  // Accu-only (hidden from UI)
  function getAccuRowsFor(targetISO, kind){
    const dayPrev = prevISO(targetISO);
    return accuRows.filter(r=>{
      if ((r.forecast_or_actual||"") !== "forecast") return false;
      if ((r.target_date||"") !== targetISO) return false;
      const issueISO = etDateISOFromTS(r.timestamp || r.forecast_time || "");
      if (kind === "D0") return issueISO === targetISO;
      if (kind === "D1") return issueISO === dayPrev;
      return false;
    });
  }

    // Keep trend; collapse only consecutive duplicates by value
   function collapseConsecutiveDuplicates(sortedRows){
        const out = [];
        let lastBin = null;
        for (const r of sortedRows){
          const v = Number(r.predicted_high);
          if (!Number.isFinite(v)) continue;
          const bin = quantize05(v);  // bucket by 0.5¬∞F
          if (lastBin === null || bin !== lastBin){
            out.push(r);
            lastBin = bin;
          }
        }
        return out;
      }


    // Representative issuance rows/values
    function latestPreHighRow(rows, highTime/* "" allowed */){
      const pre = rows
        .filter(r => r.predicted_high != null && r.predicted_high !== "")
        .filter(r => {
          if (!highTime) return true;
          const fcHH = (r.forecast_time || "").substr(11,5);
          return !(fcHH && compareTimes(fcHH, highTime) > 0);
        })
        .sort((a,b)=>((a.timestamp||a.forecast_time||"")).localeCompare(b.timestamp||b.forecast_time||""));
      if (!pre.length) return null;
      const dedup = collapseConsecutiveDuplicates(pre);
      return dedup[dedup.length-1] || null;
    }
    function latestPreHighValue(rows, highTime){ const row=latestPreHighRow(rows, highTime); const v=Number(row?.predicted_high); return Number.isFinite(v)?v:null; }

    // Robust stats
    function winsorize(arr,p=0.10){ if(!arr.length) return arr.slice(); const s=arr.slice().sort((a,b)=>a-b);
      const loIdx = Math.floor(p*(s.length-1)), hiIdx = Math.ceil((1-p)*(s.length-1));
      const lo=s[loIdx], hi=s[hiIdx]; return s.map(x=>Math.max(lo, Math.min(hi,x)));
    }
    function median(a){ if(!a.length) return null; const s=a.slice().sort((x,y)=>x-y); const m=Math.floor(s.length/2); return s.length%2? s[m] : (s[m-1]+s[m])/2; }
    function mean(a){ return a.length? a.reduce((x,y)=>x+y,0)/a.length : null; }
    function robustMean(arr){ if(arr.length>=15) return mean(winsorize(arr,0.10)); if(arr.length>=7){ const m=median(arr); return m==null? mean(arr):m; } return mean(arr); }

    // ===== Candidate builders =====
  function d0CandidatesFor(dayISO, highTime) {
    const d0 = getForecastRowsFor(dayISO, "D0").filter(r => r.predicted_high != null && r.predicted_high !== "");
    const sorted = d0
      .filter(r => {
        if (!highTime) return true;
        const fcHH = (r.forecast_time || "").substr(11,5);
        return !(fcHH && compareTimes(fcHH, highTime) > 0);
      })
      .sort((a,b)=>((a.timestamp||a.forecast_time||"")).localeCompare(b.timestamp||b.forecast_time||""));
  
    // chronological series with 0.5¬∞F step de-noise
    const series = collapseConsecutiveDuplicates(sorted);
  
    const first   = series.length ? Number(series[0].predicted_high) : null;
    const latest  = series.length ? Number(series[series.length-1].predicted_high) : null;
    const trimmed = (() => {
      const vals = series.map(r=>Number(r.predicted_high)).filter(Number.isFinite).sort((a,b)=>a-b);
      if (!vals.length) return null;
      const k = Math.max(1, Math.floor(vals.length*0.1));
      const core = vals.slice(k, vals.length-k);
      const arr = core.length ? core : vals;
      return mean(arr);
    })();
 
    // carry-over D1 (yesterday's issuance for this target) ‚Äî NWS only
   const d1Carry = latestPreHighValue(getForecastRowsFor(dayISO, "D1"), ""); 
    return { first, latest, trimmed, carry: d1Carry, series, _hasD0: series.length>0 };
  }

   function d1CandidatesFor(tomorrowISO) {
     const d1 = getForecastRowsFor(tomorrowISO, "D1").filter(r => r.predicted_high != null && r.predicted_high !== "");
      const series = collapseConsecutiveDuplicates(
        d1.sort((a,b)=>((a.timestamp||a.forecast_time||"")).localeCompare(b.timestamp||b.forecast_time||""))
      );
    
      const first   = series.length ? Number(series[0].predicted_high) : null;
      const latest  = series.length ? Number(series[series.length-1].predicted_high) : null;
      const trimmed = (() => {
        const vals = series.map(r=>Number(r.predicted_high)).filter(Number.isFinite).sort((a,b)=>a-b);
        if (!vals.length) return null;
        const k = Math.max(1, Math.floor(vals.length*0.1));
        const core = vals.slice(k, vals.length-k);
        const arr = core.length ? core : vals;
        return mean(arr);
      })();
    
      return { first, latest, trimmed, series };
    }

    // ===== Learn per-bucket blend + bias =====
function buildBiasAndBlend() {
  // ---- Gather per-day data ----
  const dayMap = new Map();
  for (const r of allRows) {
    const d = (r.forecast_or_actual === "actual" ? r.cli_date : r.target_date);
    if (!d) continue;
    if (!dayMap.has(d)) dayMap.set(d, { D0:[], D1:[], actual:null });
    const bucket = dayMap.get(d);
    if (r.forecast_or_actual === "forecast") {
      const k = leadKind(r);
      if (k === "D0") bucket.D0.push(r);
      else if (k === "D1") bucket.D1.push(r);
    } else if (r.actual_high) {
      bucket.actual = r;
    }
  }

  const todayISO = nycISODate(0);

  // ---- Build examples (candidates + series) ----
  const examples = [];
  for (const [iso, {D0, D1, actual}] of dayMap.entries()) {
    if (!actual || !actual.actual_high) continue;
    const act = Number(actual.actual_high);
    const highTime = actual.high_time || "";
    const season = isWarmSeason(iso) ? "warm" : "cool";

    // D0 entry (same-day issuances)
    const c0 = d0CandidatesFor(iso, highTime);
    if (c0._hasD0) {
      examples.push({
        iso, season, lead: "D0", actual: act,
        cand: { first:c0.first, latest:c0.latest, trimmed:c0.trimmed, carry:c0.carry },
        series: c0.series
      });
    }

    // D1 entry (yesterday's issuances for this target)
    const c1 = d1CandidatesFor(iso);
    if (c1.first!=null || c1.latest!=null || c1.trimmed!=null) {
      examples.push({
        iso, season, lead: "D1", actual: act,
        cand: { first:c1.first, latest:c1.latest, trimmed:c1.trimmed },
        series: c1.series
      });
    }
  }

  // ---- Learn blend weights (per lead+season) ----
  function learnWeights(rows, allowCarry) {
    if (!rows.length) return { w:{first:0, latest:1, trimmed:0, carry:0}, mae:Infinity };
    let best = { w:null, mae:Infinity };
    const step = 0.1;
    for (let f=0; f<=1; f+=step) {
      for (let l=0; l<=1-f; l+=step) {
        for (let t=0; t<=1-f-l; t+=step) {
          const c = allowCarry ? (1 - f - l - t) : 0;
          if (!allowCarry && Math.abs(1 - f - l - t) > 1e-9) continue;
          const w = { first:f, latest:l, trimmed:t, carry:c };

          // MAE vs actual using this blend
          let absSum=0, n=0;
          for (const r of rows) {
            const parts=[];
            if (r.cand.first   != null) parts.push({v:r.cand.first,   w:w.first});
            if (r.cand.latest  != null) parts.push({v:r.cand.latest,  w:w.latest});
            if (r.cand.trimmed != null) parts.push({v:r.cand.trimmed, w:w.trimmed});
            if (allowCarry && r.cand.carry != null) parts.push({v:r.cand.carry, w:w.carry});
            if (!parts.length) continue;
            const sumW = parts.reduce((a,b)=>a+b.w,0) || 1;
            const rep  = parts.reduce((a,b)=>a + b.v * (b.w/sumW), 0);
            absSum += Math.abs(r.actual - rep);
            n++;
          }
          if (!n) continue;
          const mae = absSum / n;
          if (mae < best.mae) best = { w, mae };
        }
      }
    }
    if (!best.w) best = { w:{first:0,latest:1,trimmed:0,carry:0}, mae:Infinity };
    return best;
  }

  const D0_warm = learnWeights(examples.filter(e=>e.lead==="D0" && e.season==="warm"), true);
  const D0_cool = learnWeights(examples.filter(e=>e.lead==="D0" && e.season==="cool"), true);
  const D1_warm = learnWeights(examples.filter(e=>e.lead==="D1" && e.season==="warm"), false);
  const D1_cool = learnWeights(examples.filter(e=>e.lead==="D1" && e.season==="cool"), false);

  const weights = {
    D0_warm: D0_warm.w, D0_cool: D0_cool.w,
    D1_warm: D1_warm.w, D1_cool: D1_cool.w
  };

  // ---- Compute residuals for series & blend (rolling window, recency-weighted) ----
  const res = {
    series: { D0:{warm:[], cool:[]}, D1:{warm:[], cool:[]} },
    blend:  { D0:{warm:[], cool:[]}, D1:{warm:[], cool:[]} }
  };

  for (const e of examples) {
    const age = Math.max(0, daysBetween(e.iso, todayISO));
    if (age > BIAS_WINDOW_DAYS) continue; // rolling window
    const decay = Math.pow(2, -age/DECAY_HALF_LIFE);

    // series representative (EMA of deduped series)
    const repSeries = repFromSeries(e.series);
    if (repSeries != null) {
      const r = clamp(e.actual - repSeries, -RESIDUAL_CLAMP, RESIDUAL_CLAMP);
      res.series[e.lead][e.season].push({ r, w:decay });
    }

    // blend representative (using learned weights)
    const key = `${e.lead}_${e.season}`;
    const w   = weights[key] || { first:0, latest:1, trimmed:0, carry:0 };
    const parts=[];
    if (e.cand.first   != null) parts.push({v:e.cand.first,   w:w.first});
    if (e.cand.latest  != null) parts.push({v:e.cand.latest,  w:w.latest});
    if (e.cand.trimmed != null) parts.push({v:e.cand.trimmed, w:w.trimmed});
    if (e.lead==="D0" && e.cand.carry != null) parts.push({v:e.cand.carry, w:w.carry});
    if (parts.length){
      const sumW = parts.reduce((a,b)=>a+b.w,0) || 1;
      const rep  = parts.reduce((a,b)=>a + b.v * (b.w/sumW), 0);
      const r    = clamp(e.actual - rep, -RESIDUAL_CLAMP, RESIDUAL_CLAMP);
      res.blend[e.lead][e.season].push({ r, w:decay });
    }
  }

  function weightedMeanResidual(arr){
    if (!arr.length) return null;
    return wmean(arr.map(x=>x.r), arr.map(x=>x.w));
  }
  function weightedRMSE(arr){
    if (!arr.length) return null;
    const xs = arr.map(x=>x.r*x.r), ws = arr.map(x=>x.w);
    const m = wmean(xs, ws);
    return m==null ? null : Math.sqrt(m);
  }

  const bias = {
    D0: {
      warm: { series: weightedMeanResidual(res.series.D0.warm), blend: weightedMeanResidual(res.blend.D0.warm) },
      cool: { series: weightedMeanResidual(res.series.D0.cool), blend: weightedMeanResidual(res.blend.D0.cool) }
    },
    D1: {
      warm: { series: weightedMeanResidual(res.series.D1.warm), blend: weightedMeanResidual(res.blend.D1.warm) },
      cool: { series: weightedMeanResidual(res.series.D1.cool), blend: weightedMeanResidual(res.blend.D1.cool) }
    },
    global: {
      warm: {
        series: weightedMeanResidual([...res.series.D0.warm, ...res.series.D1.warm]),
        blend:  weightedMeanResidual([...res.blend.D0.warm,  ...res.blend.D1.warm])
      },
      cool: {
        series: weightedMeanResidual([...res.series.D0.cool, ...res.series.D1.cool]),
        blend:  weightedMeanResidual([...res.blend.D0.cool,  ...res.blend.D1.cool])
      },
      all: weightedMeanResidual([
        ...res.series.D0.warm, ...res.series.D1.warm,
        ...res.series.D0.cool, ...res.series.D1.cool
      ]) ?? 0
    }
  };

  const rmse = {
    D0: {
      warm: { series: weightedRMSE(res.series.D0.warm), blend: weightedRMSE(res.blend.D0.warm) },
      cool: { series: weightedRMSE(res.series.D0.cool), blend: weightedRMSE(res.blend.D0.cool) }
    },
    D1: {
      warm: { series: weightedRMSE(res.series.D1.warm), blend: weightedRMSE(res.blend.D1.warm) },
      cool: { series: weightedRMSE(res.series.D1.cool), blend: weightedRMSE(res.blend.D1.cool) }
    }
  };

  return { weights, bias, rmse };
}

    // Pick bias (lead-level with safe fallback)
  function pickBiasFrom(tables, lead, season, usedSeries){
  const method = usedSeries ? "series" : "blend";
  const s = (season === "warm" || season === "cool") ? season : "warm";
  const byLead = tables?.bias?.[lead]?.[s]?.[method];
  if (Number.isFinite(byLead)) return byLead;
  const bySeason = tables?.bias?.global?.[s]?.[method];
  if (Number.isFinite(bySeason)) return bySeason;
  return tables?.bias?.global?.all ?? 0;
}

    // Blend helper
    function blendedRep(cands, weights, allowCarry) {
      const parts = [];
      if (cands.first   != null) parts.push({v:cands.first,   w:weights.first ?? 0});
      if (cands.latest  != null) parts.push({v:cands.latest,  w:weights.latest ?? 0});
      if (cands.trimmed != null) parts.push({v:cands.trimmed, w:weights.trimmed ?? 0});
      if (allowCarry && cands.carry != null) parts.push({v:cands.carry, w:weights.carry ?? 0});
      if (!parts.length) return null;
      const sumW = parts.reduce((a,b)=>a+b.w,0);
      if (sumW <= 1e-9) return cands.latest ?? cands.first ?? cands.trimmed ?? cands.carry ?? null;
      return parts.reduce((a,b)=>a + b.v * (b.w/sumW), 0);
    }

          // === Exact formula explainer (normalized to the parts that exist) ===
      function blendExplainer(cands, weights, allowCarry) {
        const present = [];
        if (cands.first   != null)  present.push({label:"first",   v:Number(cands.first),   w:weights.first ?? 0});
        if (cands.latest  != null)  present.push({label:"latest",  v:Number(cands.latest),  w:weights.latest ?? 0});
        if (cands.trimmed != null)  present.push({label:"trimmed", v:Number(cands.trimmed), w:weights.trimmed ?? 0});
        if (allowCarry && cands.carry != null) present.push({label:"carry", v:Number(cands.carry), w:weights.carry ?? 0});
      
        const sumW = present.reduce((a,p)=>a+p.w,0);
        const used = sumW > 1e-9
          ? present.map(p => ({...p, wn: p.w/sumW}))
          : present.map(p => ({...p, wn: (p.label==="latest") ? 1 : 0})); // mirrors blendedRep fallback
      
        const partsTxt = used
          .filter(p => p.wn > 0)
          .map(p => `${p.wn.toFixed(2)}√ó${p.label} ${p.v.toFixed(1)}¬∞F`)
          .join(" + ");
      
        return { partsTxt };
      }
// === Subtitle explainer: prefer series rep if used, else show normalized blend ===
function explainPred({ usedSeries, series, bias, partsTxt, nudge = null }) {
  const b = (bias == null) ? "0.0" : Number(bias).toFixed(1);

  if (usedSeries) {
    const n = Array.isArray(series) ? series.length : 0;
    const core = `pred = series_rep (n=${n}, newest-weighted) + ${b}`;
    if (nudge != null && Number.isFinite(nudge) && Math.abs(nudge) > 0) {
      return `${core} + nudge ${Number(nudge).toFixed(1)}`;
    }
    return core;
  }

  // fallback: normalized blend parts (only if any non-zero weight components exist)
  return partsTxt ? `pred = (${partsTxt}) + ${b}` : `pred = ‚Äî + ${b}`;
}

    // === Series helpers (0.5¬∞F de-noise + recency rep) =========================
function quantize05(x){
  const n = Number(x);
  if (!Number.isFinite(n)) return null;
  return Math.round(n * 2) / 2; // nearest 0.5¬∞F
}

// rowsChrono: chronological rows (oldest ‚Üí newest), each has predicted_high
// alpha=0.85 weights newest more (w, w*alpha, w*alpha^2, ... from newest back)
function repFromSeries(rowsChrono, alpha = 0.85){
  if (!rowsChrono || !rowsChrono.length) return null;
  let vsum = 0, wsum = 0, w = 1;               // start from newest
  for (let i = rowsChrono.length - 1; i >= 0; i--) {
    const v = Number(rowsChrono[i].predicted_high);
    if (!Number.isFinite(v)) continue;
    vsum += w * v;
    wsum += w;
    w *= alpha;
  }
  return wsum > 0 ? (vsum / wsum) : null;
}
function combineSeries(seriesD1, seriesD0){
  const A = Array.isArray(seriesD1) ? seriesD1 : [];
  const B = Array.isArray(seriesD0) ? seriesD0 : [];
  const merged = [...A, ...B].sort((x,y)=>
    ((x.timestamp||x.forecast_time||"").localeCompare(y.timestamp||y.forecast_time||""))
  );
  return collapseConsecutiveDuplicates(merged);
}

// === Calibration config (rolling/recency-weighted biases) ===
const BIAS_WINDOW_DAYS   = 75;   // only last ~2.5 months
const DECAY_HALF_LIFE    = 30;   // days; recency weighting for biases
const RESIDUAL_CLAMP     = 6;    // ¬∞F; soft outlier guard

function daysBetween(iso1, iso2){
  if(!iso1 || !iso2) return 0;
  const d1=new Date(iso1+"T00:00:00"), d2=new Date(iso2+"T00:00:00");
  return Math.round((d2-d1)/86400000);
}
function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }
function wmean(xs, ws){
  let num=0, den=0;
  for (let i=0;i<xs.length;i++){
    const x=xs[i], w=ws[i] ?? 1;
    if (!Number.isFinite(x) || w<=0) continue;
    num += x*w; den += w;
  }
  return den>0 ? num/den : null;
}

    // ===== Feature helpers for logging =====
    function issuanceISOUTC(row){
      const src = (row?.timestamp || row?.forecast_time || "").replace(" ", "T");
      const d = new Date(src);
      if (!Number.isFinite(d.getTime())) return null;
      return d.toISOString().slice(0,19) + "Z"; // canonical UTC
    }
    function issuanceHourET(row){
      const s = (row?.timestamp || row?.forecast_time || "").replace(" ", "T"); const d=new Date(s);
      if (!Number.isFinite(d.getTime())) return null;
      const hh = new Intl.DateTimeFormat("en-CA",{timeZone:"America/New_York",hour:"2-digit",hour12:false}).format(d);
      return Number(hh);
    }
    function rowSig(r){ return `${r.timestamp || r.forecast_time || ""}|${r.predicted_high}`; }

    function deltaLast3(rows, repRow, highTime){
      const sorted = rows
        .filter(r => r.predicted_high != null && r.predicted_high !== "")
        .filter(r => {
          if (!highTime) return true;
          const fcHH = (r.forecast_time || r.timestamp || "").substr(11,5);
          return !(fcHH && compareTimes(fcHH, highTime) > 0);
        })
        .sort((a,b)=>((a.timestamp||a.forecast_time||"")).localeCompare(b.timestamp||b.forecast_time||""));

      const dedup = collapseConsecutiveDuplicates(sorted);
      if (!repRow || !dedup.length) return 0;

      const repS = rowSig(repRow);
      let idx = dedup.findIndex(x => rowSig(x) === repS);
      if (idx < 0) idx = dedup.length - 1;

      const prevs = dedup.slice(Math.max(0, idx - 2), idx)
        .map(r => Number(r.predicted_high))
        .filter(Number.isFinite);

      if (!prevs.length) return 0;
      const medPrev = median(prevs);
      const rep = Number(repRow.predicted_high);
      return (Number.isFinite(rep) && medPrev != null) ? (rep - medPrev) : 0;
    }

    // === Client idempotency helpers (avoid logging the same prediction repeatedly) ===
    function stableRound(x, d=1){
      const n = Number(x);
      if (!Number.isFinite(n)) return null;
      const p = Math.pow(10, d);
      return Math.round(n * p) / p;
    }
    function round1(x){ const n = Number(x); return Number.isFinite(n) ? Math.round(n*10)/10 : null; }

    function buildPredSignature({
      target_date, lead_used, issuance_iso,
      rep_forecast, bias_applied, prediction_value,
      model_name, version
    }) {
      const rep = stableRound(rep_forecast, 1);
      const bias = stableRound(bias_applied, 2);
      const pred = stableRound(prediction_value, 1);
      return [
        target_date || '',
        lead_used || '',
        issuance_iso || '',
        rep ?? '',
        bias ?? '',
        pred ?? '',
        model_name || '',
        version || ''
      ].join('|');
    }

    // remembers the last forecast_signature we actually logged
    const loggedSig = {
      today:    localStorage.getItem("loggedSig_today")    || null,
      tomorrow: localStorage.getItem("loggedSig_tomorrow") || null,
    };
    function setLoggedSig(which, sig) {
      loggedSig[which] = sig;
      try { localStorage.setItem(`loggedSig_${which}`, sig); } catch {}
    }

    // ===== Prediction logging toggle + helpers =====
    let PREDICTION_LOGGING_ENABLED = false; // off until we detect availability
    async function probeLoggingEndpoint() {
      try {
        const r = await fetch(`${API_BASE}/log-prediction`, { method: "OPTIONS" });
        PREDICTION_LOGGING_ENABLED = r.ok;
      } catch {
        PREDICTION_LOGGING_ENABLED = false;
      }
    }
     async function logPrediction(payload){
      if (!PREDICTION_LOGGING_ENABLED) return;
      try{
        const r = await fetch(`${API_BASE}/log-prediction`, {
          method:"POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify(payload)
        });
        if (!r.ok) {
          let j = null; try { j = await r.json(); } catch {}
          const dup = r.status === 409 || (j && (j.code === '23505' || /duplicate key/i.test(j.message||"")));
          if (dup) return;                   // silently ignore duplicates
          if (r.status === 404) PREDICTION_LOGGING_ENABLED = false; // endpoint missing: stop trying
          console.debug("/api/log-prediction error", r.status, j?.message || r.statusText);
        }
      } catch(_) { /* quiet */ }
    }

    // ---- Friendly ET date display helpers ----
    function safeParseTimestamp(ts) {
      const s = (ts || "").trim();
      if (!s) return null;
      const isoish = s.includes("T") ? s : s.replace(" ", "T");
      const d = new Date(isoish);
      return Number.isFinite(d.getTime()) ? d : null;
    }
    function fmtMonthDayET(d) {
      return new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        month: "short",
        day: "numeric"
      }).format(d);
    }
    function fmtTimeET(d) {
      return new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        hour: "numeric",
        minute: "2-digit"
      }).format(d);
    }
    function monthDayFromISO(iso) {
      if (!/^\d{4}-\d{2}-\d{2}$/.test(iso || "")) return "";
      return fmtMonthDayET(new Date(iso + "T00:00:00"));
    }
    function hhmmFromTS(s) {
      const m = String(s || "").match(/\b(\d{1,2}:\d{2})\b/);
      return m ? m[1] : "";
    }
    function showMostRecent() {
      const el = document.getElementById("recentForecast");
      if (!el) return;
      if (!allRows.length) { el.textContent = ""; return; }

      for (let i = allRows.length - 1; i >= 0; i--) {
        const r = allRows[i];
        if (r && r.forecast_or_actual === "forecast" && r.predicted_high && r.target_date) {
          const d =
            safeParseTimestamp(r.timestamp) ||
            safeParseTimestamp(r.forecast_time);

          const dateLabel = d
            ? fmtMonthDayET(d)
            : monthDayFromISO((r.timestamp || r.forecast_time || "").slice(0, 10)) ||
              monthDayFromISO(nycISODate(0));

          const timeLabel = d
            ? fmtTimeET(d)
            : hhmmFromTS(r.timestamp || r.forecast_time) || "";

          const whenLabel = timeLabel ? `${dateLabel} at ${timeLabel} ET` : `${dateLabel}`;

          el.innerHTML =
            `<strong>${whenLabel}</strong> ‚Äî ` +
            `<strong>${r.predicted_high}¬∞F</strong> for <strong>${r.target_date}</strong>`;
          return;
        }
      }
      el.textContent = "";
    }

    function getForecastsForDate(dateISO) {
      const rows = allRows
        .filter(r => r.forecast_or_actual === "forecast" && r.target_date === dateISO && r.predicted_high)
        .map(r => ({
          tstamp: r.timestamp || r.forecast_time || "",
          timeHHMM: (r.forecast_time || "").substr(11, 5),
          val: Number(r.predicted_high)
        }))
        .filter(x => Number.isFinite(x.val));
      rows.sort((a, b) => (a.tstamp || "").localeCompare(b.tstamp || ""));
      return rows;
    }

    function renderMiniForecastChips(rows, elId) {
      const host = document.getElementById(elId);
      if (!host) return;
      host.innerHTML = "";
      const compact = [];
      rows.forEach((r, i) => {
        if (i === 0 || r.val !== rows[i - 1].val) compact.push(r);
      });
      if (!compact.length) {
        host.innerHTML = `<span class="mini-chip">No forecasts yet</span>`;
        return;
      }
      compact.forEach(r => {
        const label = `${r.timeHHMM || "‚Äî"}, ${r.val.toFixed(0)}¬∞`;
        const chip = document.createElement("span");
        chip.className = "mini-chip";
        chip.textContent = label;
        host.appendChild(chip);
      });
    }

    // ---- Forecast change watcher (GLOBAL scope) ----
    let lastSig = { today: null, tomorrow: null };
    let forecastChanged = { today: false, tomorrow: false };

    let lastActualSig = null;
function actualSignatureFor(rows) {
  const todayISO = nycISODate(0);
  const a = rows.find(r =>
    r.forecast_or_actual === "actual" &&
    r.cli_date === todayISO &&
    r.actual_high
  );
  if (!a) return "";
  return [
    a.cli_date,
    a.actual_high,
    a.high_time || "",
    a.timestamp || a.date_pulled || ""
  ].join("|");
}

    function forecastSignatureFor(dateISO, rows = allRows) {
      return rows
        .filter(r => r.forecast_or_actual === "forecast" && r.target_date === dateISO && r.predicted_high)
        .map(r => `${r.timestamp || r.forecast_time || ""}|${r.predicted_high}`)
        .sort()
        .join("~");
    }
    function seedForecastSignatures() {
      lastSig.today = forecastSignatureFor(nycISODate(0));
      lastSig.tomorrow = forecastSignatureFor(nycISODate(1));
    }

    async function pollCsvAndUpdate() {
      try {
        const txt = await fetch(CSV_URL + "?" + Date.now(), { cache: "no-cache", mode: "cors" }).then(r => r.text());

        // reuse parser
        const raw = csvToRows(txt);
        if (!raw.length) return;
        const header = raw[0].map(h => h.trim());
        const rows = [];
        for (let i = 1; i < raw.length; i++) {
          const rec = {};
          for (let j = 0; j < header.length; j++) {
            let v = (raw[i][j] ?? '').trim();
            if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1).replace(/""/g, '"');
            rec[header[j]] = v;
          }
          rows.push(rec);
        }

        const todayISO = nycISODate(0);
        const tomorrowISO = nycISODate(1);
        const sigTodayNew = forecastSignatureFor(todayISO, rows);
        const sigTmrwNew  = forecastSignatureFor(tomorrowISO, rows);
        const actSigNew = actualSignatureFor(rows);
      const actualChanged = actSigNew !== lastActualSig;
if (actualChanged) lastActualSig = actSigNew;

const changedToday    = sigTodayNew !== lastSig.today;
const changedTomorrow = sigTmrwNew  !== lastSig.tomorrow;

// If nothing changed at all, bail
if (!changedToday && !changedTomorrow && !actualChanged) return;

// Adopt new signatures (we still only *log* on forecast changes)
lastSig.today    = sigTodayNew;
lastSig.tomorrow = sigTmrwNew;
forecastChanged.today    = changedToday;
forecastChanged.tomorrow = changedTomorrow;

// Swap data
allRows = rows;
filteredRows = allRows.slice();

// === NEW: if an actual just appeared/changed, train Hedge immediately ===
if (actualChanged) {
  try {
    const todayISO = nycISODate(0);
    const a = allRows.find(r => r.forecast_or_actual === "actual" && r.cli_date === todayISO && r.actual_high);
    if (a && a.actual_high != null) {
      const season = isWarmSeason(todayISO) ? "warm" : "cool";
      const built  = buildCandidatesForDay(todayISO, a.high_time || "");
      updateHedgeOnActual("today", season, built.candidates, Number(a.actual_high), todayISO);
        // also teach the "tomorrow" model using D1-only candidates for the resolved day
      const c1today = d1CandidatesFor(todayISO);
      const tmCands = {};
      if (c1today.latest  != null) tmCands.D1_latest  = Number(c1today.latest);
      if (c1today.trimmed != null) tmCands.D1_trimmed = Number(c1today.trimmed);
      const rep1 = repFromSeries(c1today.series);
      if (rep1 != null) tmCands.series_rep = Number(rep1);
      updateHedgeOnActual("tomorrow", season, tmCands, Number(a.actual_high), todayISO);
    }
  } catch(_) {}
}

// Refresh UI
showMostRecent();
updateSummaryBoxes();
updateCorrectionBoxes();  // now uses the freshly-trained state

      } catch (e) {
        console.debug("pollCsvAndUpdate error:", e);
      }
    }

    /* ========= NETWORK: SAME-ORIGIN ‚Üí PROXY ‚Üí UPSTREAM ========= */
    const CSV_URL = "https://raw.githubusercontent.com/hwaheed13/nws-forecast-logger/main/nws_forecast_log.csv";
    const ACCU_URL = "https://raw.githubusercontent.com/hwaheed13/nws-forecast-logger/main/accuweather_log.csv";
    const KALSHI_BASE_URL = "https://kalshi.com/markets/kxhighny/highest-temperature-in-nyc";
    const API_BASE = "/api"; // relative works from / or /dashboard/

    const KALSHI_BY_DATE_URLS = [ `${API_BASE}/kalshi` ];
    const KALSHI_LIVE_URLS    = [ `${API_BASE}/kalshi-live` ];
    const NWS_HIGH_SO_FAR_URLS= [ `${API_BASE}/nws-high-so-far` ];
    const NWS_CURRENT_TEMP_URLS=[ `${API_BASE}/nws-current-temp` ];
    const NWS_DSM_URLS        = [
      `${API_BASE}/nws-dsm?issuedby=NYC`,
      "https://forecast.weather.gov/product.php?site=NWS&issuedby=NYC&product=DSM&format=CI&version=1&glossary=1",
    ];
    const NWS_6HR_JSON_URLS = [
      `${API_BASE}/nws-6hr-json`,
      "https://www.weather.gov/source/wrh/timeseries/obs.js",
    ];

    async function fetchJSON(urls, qs) {
      for (const base of urls) {
        try {
          const u = new URL(base, location.origin);
          if (qs) for (const [k, v] of Object.entries(qs)) u.searchParams.set(k, v);
          const r = await fetch(u.toString(), { cache: "no-cache", mode: "cors", headers: { Accept: "application/json" } });
          if (r.ok) return await r.json();
        } catch (_) {}
      }
      return null;
    }
    async function fetchTEXT(urls, qs) {
      for (const base of urls) {
        try {
          const u = new URL(base, location.origin);
          if (qs) for (const [k, v] of Object.entries(qs)) u.searchParams.set(k, v);
          const r = await fetch(u.toString(), { cache: "no-cache", mode: "cors" });
          if (r.ok) return await r.text();
        } catch (_) {}
      }
      return null;
    }

    async function fetchKalshiWinningRange(dateISO) { return fetchJSON(KALSHI_BY_DATE_URLS, { date: dateISO }); }
    async function fetchKalshiLiveLeader(dateISO)   { return fetchJSON(KALSHI_LIVE_URLS, { date: dateISO, cb: Date.now() }); }
    async function fetchNwsHighSoFar(station = "KNYC") { return fetchJSON(NWS_HIGH_SO_FAR_URLS, { station }); }
    async function fetchNwsCurrentTemp(station = "KNYC") { return fetchJSON(NWS_CURRENT_TEMP_URLS, { station, cb: Date.now() }); }
    // AccuWeather data storage
const accuWeatherData = { today: null, tomorrow: null };

async function fetchAccuWeatherForecasts() {
  try {
    const response = await fetch('/api/accuweather-forecast');
    if (!response.ok) return null;
    
    const data = await response.json();
    accuWeatherData.today = Math.round(data.DailyForecasts[0].Temperature.Maximum.Value);
    accuWeatherData.tomorrow = Math.round(data.DailyForecasts[1].Temperature.Maximum.Value);
    
    console.log(`AccuWeather: Today ${accuWeatherData.today}¬∞F, Tomorrow ${accuWeatherData.tomorrow}¬∞F`);
    return accuWeatherData;
  } catch (error) {
    console.error('AccuWeather error:', error);
    return null;
  }
}
window.fetchAccuWeatherForecasts = fetchAccuWeatherForecasts;

    // Kalshi cache
    const kalshiCache = new Map();
    async function getKalshiLabel(dateISO) {
      const today = nycISODate(0);
      const yesterday = nycISODate(-1);

      // Never cache "today"
      if (dateISO === today) return await fetchKalshiWinningRange(dateISO);

      const now = Date.now();
      const cached = kalshiCache.get(dateISO);
      if (cached && (dateISO !== yesterday || (now - cached._ts) < 120000)) return cached.data;

      const fresh = await fetchKalshiWinningRange(dateISO);
      kalshiCache.set(dateISO, { _ts: now, data: fresh });
      return fresh;
    }

    // DSM parsing
    function parseDSM(text) {
      if (!text) return null;
      const t = text.replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim();
      const dateMatch = t.match(/\b(\d{1,2})\/(\d{2})\b/);
      if (!dateMatch) return null;
      const after = t.slice(t.indexOf(dateMatch[0]) + dateMatch[0].length);
      const hiBlock = after.match(/\b(\d{6})\b/);
      if (!hiBlock) return null;
      const block = hiBlock[1];
      const tempF = Number(block.slice(0, 2));
      const hh = block.slice(2, 4);
      const mm = block.slice(4, 6);
      if (!Number.isFinite(tempF)) return null;
      const now = new Date();
      const year = now.getFullYear();
      const dd = String(dateMatch[1]).padStart(2, "0");
      const mmMon = String(dateMatch[2]).padStart(2, "0");
      const isoLocal = `${year}-${mmMon}-${dd}T${hh}:${mm}:00`;
      const dayISO = `${year}-${mmMon}-${dd}`;
      const when = new Date(isoLocal);
      const fmtET = new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        hour: "numeric",
        minute: "2-digit"
      }).format(when);
      return { tempF, timeET: fmtET, iso: isoLocal, dayISO, raw: block };
    }

    // Month helpers (for table)
    function monthKeyFromISO(iso) { const [y,m] = iso.split('-'); return `${y}-${m}`; }
    function monthLabelFromKey(key) {
      const [y, m] = key.split('-').map(Number);
      const d = new Date(y, m - 1, 1);
      return new Intl.DateTimeFormat('en-US', { month: 'long', year: 'numeric' }).format(d);
    }

    // DSM (single, non-duplicated)
    let lastDSMDay = nycISODate(0);
    function clearDSMOnly() {
      const max = document.getElementById("box-dsm-max");
      const note = document.getElementById("box-dsm-note");
      if (max) max.textContent = "‚Äì";
      if (note) note.textContent = "";
    }
    async function updateDSM() {
      const el = document.getElementById("box-dsm-max");
      const note = document.getElementById("box-dsm-note");
      if (!el || !note) return;
      const today = nycISODate(0);
      if (today !== lastDSMDay) { clearDSMOnly(); lastDSMDay = today; }
      el.textContent = "‚Äì";
      note.textContent = "";
      const txt = await fetchTEXT(NWS_DSM_URLS);
      const parsed = parseDSM(txt);
      if (parsed && parsed.dayISO === today) {
        el.textContent = `${parsed.tempF.toFixed(0)}¬∞F`;
        note.textContent = `${parsed.timeET} ET ‚Ä¢ daily summary message`;
      } else {
        clearDSMOnly();
      }
    }

    // 6-hr max
    async function updateSixHourMax() {
      const el = document.getElementById("box-6hr-max");
      const note = document.getElementById("box-6hr-max-note");
      if (!el || !note) return;
      el.textContent = "‚Äì";
      note.textContent = "";
      try {
        const parsed = await fetchJSON(NWS_6HR_JSON_URLS, { station: "KNYC" });
        if (parsed && parsed.value != null) {
          el.textContent = `${parsed.value}¬∞F`;
          note.textContent = parsed.time ? `as of ${parsed.time} ‚Ä¢ 6-hr max` : "Latest 6-hr max";
        } else {
          note.textContent = "6-Hr Max not available";
        }
      } catch (err) {
        console.error("6HR fetch error:", err);
        note.textContent = "6-Hr Max unavailable";
      }
    }

    // Observations: current temp only
    function updateObservations() {
      fetchNwsCurrentTemp("KNYC").then(cur => {
        const el = document.getElementById("box-today-current");
        const note = document.getElementById("box-today-current-note");
        if (!el || !note) return;
        if (cur && cur.currentF != null) {
          el.textContent = `${Number(cur.currentF).toFixed(1)}¬∞F`;
          const ts = cur.atISO ? new Date(cur.atISO) : null;
          const tNY = ts ? new Intl.DateTimeFormat("en-US", {
            timeZone: "America/New_York",
            hour: "numeric",
            minute: "2-digit"
          }).format(ts) : "";
          note.textContent = tNY ? `as of ${tNY} ET ‚Ä¢ station ${cur.station}` : `station ${cur.station}`;
        } else {
          el.textContent = "‚Äì";
          note.textContent = "";
        }
      });
    }

    async function updateSummaryBoxes() {
      const today = nycISODate(0);
      const tomorrow = nycISODate(1);
      const yesterday = nycISODate(-1);

      const latestForDate = (date) => {
        const rows = allRows
          .filter(r => r.forecast_or_actual === "forecast" && r.target_date === date && r.predicted_high);
        if (!rows.length) return null;
        rows.sort((a, b) => {
          const A = a.timestamp || a.forecast_time || "";
          const B = b.timestamp || b.forecast_time || "";
          return B.localeCompare(A);
        });
        return Number(rows[0].predicted_high);
      };

      // Update the four metric boxes + mini chips
      const tLatest  = latestForDate(today);
      const tActRow  = allRows.find(r => r.forecast_or_actual === "actual" && r.cli_date === today && r.actual_high);
      const tActual  = tActRow ? Number(tActRow.actual_high) : null;
      const tmLatest = latestForDate(tomorrow);

      const e = (id) => document.getElementById(id);
      if (e("box-today-forecast"))    e("box-today-forecast").textContent    = (tLatest  == null) ? "‚Äì" : `${tLatest.toFixed(0)}¬∞F`;
      if (e("box-today-actual"))      e("box-today-actual").textContent      = (tActual  == null) ? "‚Äì" : `${tActual.toFixed(0)}¬∞F`;
      if (e("box-tomorrow-forecast")) e("box-tomorrow-forecast").textContent = (tmLatest == null) ? "‚Äì" : `${tmLatest.toFixed(0)}¬∞F`;

      const todayRows    = getForecastsForDate(today);
      const tomorrowRows = getForecastsForDate(tomorrow);
      renderMiniForecastChips(todayRows, "mini-today-forecasts");
      renderMiniForecastChips(tomorrowRows, "mini-tomorrow-forecasts");

      // ===== Kalshi badges =====
      const tBox  = e('box-today-kalshi');
      const tNote = e('box-today-kalshi-note');
      const yBox  = e('box-yday-kalshi');
      const yNote = e('box-yday-kalshi-note');

      try {
        const [ktoday, kyday, live] = await Promise.all([
          getKalshiLabel(today),
          getKalshiLabel(yesterday),
          fetchKalshiLiveLeader(today)
        ]);

        // --- TODAY ---
        if (live && live.leadingLabel) {
          const pct = (live.leadingProb != null) ? ` (${Math.round(live.leadingProb * 100)}%)` : "";
          if (tBox)  tBox.innerHTML  = `<a class="kalshi-badge" href="${KALSHI_BASE_URL}" target="_blank" rel="noopener noreferrer">${live.leadingLabel}${pct}</a>`;
          if (tNote) tNote.textContent = "Live leader (can flip before settlement).";
        } else if (ktoday && ktoday.settled === true && ktoday.label) {
          if (tBox)  tBox.innerHTML  = `<a class="kalshi-badge" href="${KALSHI_BASE_URL}" target="_blank" rel="noopener noreferrer">${ktoday.label}</a>`;
          if (tNote) tNote.textContent = (ktoday.exactTemp != null) ? `Settled at ${ktoday.exactTemp.toFixed(1)}¬∞F.` : "";
        } else {
          if (tBox)  tBox.innerHTML  = `<span class="kalshi-pending">Pending settlement</span>`;
          if (tNote) tNote.textContent = "Closes 11:59 PM ET; settles after NWS daily report.";
        }

        // --- YESTERDAY ---
        const anchor = kalshiAnchorForISO(yesterday);
        const yHref = `${KALSHI_BASE_URL}${anchor}`;
        if (kyday && kyday.label) {
          const exact = (kyday.exactTemp != null) ? ` (settled ${kyday.exactTemp.toFixed(1)}¬∞F)` : "";
          if (yBox)  yBox.innerHTML  = `<a class="kalshi-badge" href="${yHref}" target="_blank" rel="noopener noreferrer">${kyday.label}${exact}</a>`;
          if (yNote) yNote.textContent = "Links directly to yesterday's contract.";
        } else {
          if (yBox)  yBox.innerHTML  = `<a class="kalshi-badge" href="${yHref}" target="_blank" rel="noopener noreferrer">Open yesterday's market</a>`;
          if (yNote) yNote.textContent = "No proxy data; linking via anchor.";
        }
      } catch {
        if (tBox)  tBox.innerHTML  = `<a class="kalshi-badge" href="${KALSHI_BASE_URL}" target="_blank" rel="noopener noreferrer">Open market</a>`;
        if (tNote) tNote.textContent = "Could not load proxy data.";
        const yHref = `${KALSHI_BASE_URL}${kalshiAnchorForISO(yesterday)}`;
        if (yBox)  yBox.innerHTML  = `<a class="kalshi-badge" href="${yHref}" target="_blank" rel="noopener noreferrer">Open yesterday's market</a>`;
        if (yNote) yNote.textContent = "Proxy error; using anchor link.";
      }
    }

    function hasActualFor(dateISO) {
      return allRows.some(r =>
        r.forecast_or_actual === "actual" &&
        r.cli_date === dateISO &&
        r.actual_high && String(r.actual_high).trim() !== ""
      );
    }

function updateCorrectionBoxes() {
  try {
    const todayISO = nycISODate(0);
    const tmwISO   = nycISODate(1);

    const builtToday = buildCandidatesForDay(todayISO, "");
    const builtTmw   = buildCandidatesForDay(tmwISO, "");

    // Debug: log what candidates we have
    console.log("Today candidates:", builtToday.candidates);
    console.log("Tomorrow candidates:", builtTmw.candidates);

    const s0 = isWarmSeason(todayISO) ? "warm" : "cool";
    const s1 = isWarmSeason(tmwISO) ? "warm" : "cool";

    const out0 = predictWithHedge("today", s0, builtToday.candidates);
    const out1 = predictWithHedge("tomorrow", s1, builtTmw.candidates);

    // Debug: log predictions
    console.log("Today prediction:", out0);
    console.log("Tomorrow prediction:", out1);

    // Format predictions with proper display
    const el0 = document.getElementById('correctionBoxToday');
    const el1 = document.getElementById('correctionBoxTomorrow');
    
    if (el0) {
      if (Number.isFinite(out0?.y)) {
        const val = Math.round(out0.y);
        const bias = out0.bias != null ? out0.bias.toFixed(1) : "0.0";
        const sign = Number(bias) >= 0 ? "+" : "";
        el0.innerHTML = `
          <div class="prediction-value">${val}¬∞F</div>
          <div class="prediction-subtitle">Ensemble prediction with ${sign}${bias}¬∞F bias correction</div>
        `;
      } else {
        el0.innerHTML = `<div class="prediction-value">‚Äî</div><div class="prediction-subtitle">Awaiting forecast data</div>`;
      }
    }
    
    if (el1) {
      if (Number.isFinite(out1?.y)) {
        const val = Math.round(out1.y);
        const bias = out1.bias != null ? out1.bias.toFixed(1) : "0.0";
        const sign = Number(bias) >= 0 ? "+" : "";
        el1.innerHTML = `
          <div class="prediction-value">${val}¬∞F</div>
          <div class="prediction-subtitle">Ensemble prediction with ${sign}${bias}¬∞F bias correction</div>
        `;
      } else {
        el1.innerHTML = `<div class="prediction-value">‚Äî</div><div class="prediction-subtitle">Awaiting forecast data</div>`;
      }
    }
  } catch (e) {
    console.warn("updateCorrectionBoxes() failed", e);
    const el0 = document.getElementById('correctionBoxToday');
    const el1 = document.getElementById('correctionBoxTomorrow');
    if (el0) el0.innerHTML = `<div class="prediction-value">‚Äî</div><div class="prediction-subtitle">Error loading data</div>`;
    if (el1) el1.innerHTML = `<div class="prediction-value">‚Äî</div><div class="prediction-subtitle">Error loading data</div>`;
  }
}
window.updateCorrectionBoxes = updateCorrectionBoxes;

  function showChart() {
    // Group rows by target/cli date (the "day" label)
    const byDate = {};
    filteredRows.forEach(r => {
      const d = (r.forecast_or_actual === "actual" ? r.cli_date : r.target_date);
      if (!/^\d{4}-\d{2}-\d{2}$/.test(d || "")) return;
      (byDate[d] ??= []).push(r);
    });
  
    const haveDays = Object.keys(byDate).sort();
    const ctx = document.getElementById('dailyChart').getContext('2d');
  
    if (!haveDays.length) {
      if (chartInstance) chartInstance.destroy();
      chartInstance = new Chart(ctx, { type:'line', data:{labels:[], datasets:[]}, options:{} });
      return;
    }
  
    // Build continuous day labels from first Monday-ish to last day (same as before)
    const isoToDate = iso => { const [Y,M,D] = iso.split('-').map(Number); return new Date(Y, M-1, D); };
    const dateToISO = d => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    const addDays  = (d,n)=>{ const x=new Date(d); x.setDate(x.getDate()+n); return x; };
  
    const first = isoToDate(haveDays[0]);
    const dow = first.getDay();             // 0=Sun ‚Ä¶ 6=Sat
    const back = (dow + 6) % 7;             // start week on Mon
    const start = addDays(first, -back);
    const end   = isoToDate(haveDays[haveDays.length - 1]);
  
    const labels = [];
    for (let d=new Date(start); d<=end; d=addDays(d,1)) labels.push(dateToISO(d));
  
    // Helpers to compute daily stats from detailed log
    const actualMap   = new Map();  // day ‚Üí actual
    const lastMap     = new Map();  // day ‚Üí last pre-high forecast (chronological latest before high_time)
    const bestMap     = new Map();  // day ‚Üí best pre-high forecast (closest to actual)
    const minMap      = new Map();  // day ‚Üí min pre-high forecast
    const maxMap      = new Map();  // day ‚Üí max pre-high forecast
  
    labels.forEach(dayISO => {
      const rows = byDate[dayISO] || [];
      const actualRow = rows.find(r => r.forecast_or_actual === "actual" && r.actual_high);
      if (!actualRow) return; // only compute when we have an actual
  
      const actualHigh = Number(actualRow.actual_high);
      const highTime   = actualRow.high_time || ""; // HH:MM AM/PM (ET) when available
      actualMap.set(dayISO, Number.isFinite(actualHigh) ? actualHigh : null);
  
      // Collect pre-high forecasts
      const pre = rows
        .filter(r => r.forecast_or_actual === "forecast" && r.predicted_high)
        .filter(r => {
          if (!highTime) return true; // if no high time, treat all same-day forecasts as eligible
          const fcHH = (r.forecast_time || "").substr(11, 5);
          return !(fcHH && compareTimes(fcHH, highTime) > 0); // drop after-high issuances
        })
        .map(r => ({
          t: (r.timestamp || r.forecast_time || ""),
          v: Number(r.predicted_high)
        }))
        .filter(x => Number.isFinite(x.v))
        .sort((a,b) => (a.t || "").localeCompare(b.t || "")); // chronological
  
      if (!pre.length) return;
  
      // Last pre-high (chronologically latest before high)
      const last = pre[pre.length - 1].v;
      lastMap.set(dayISO, last);
  
      // Best pre-high (closest to actual)
      if (Number.isFinite(actualHigh)) {
        let best = pre[0].v, bestErr = Math.abs(pre[0].v - actualHigh);
        for (let i=1;i<pre.length;i++){
          const e = Math.abs(pre[i].v - actualHigh);
          if (e < bestErr) { best = pre[i].v; bestErr = e; }
        }
        bestMap.set(dayISO, best);
      }
  
      // Range band
      const vs = pre.map(p => p.v);
      minMap.set(dayISO, Math.min(...vs));
      maxMap.set(dayISO, Math.max(...vs));
    });
  
    const actual = labels.map(d => actualMap.has(d) ? actualMap.get(d) : null);
    const lastPH = labels.map(d => lastMap.has(d)     ? lastMap.get(d)     : null);
    const bandMin= labels.map(d => minMap.has(d)      ? minMap.get(d)      : null);
    const bandMax= labels.map(d => maxMap.has(d)      ? maxMap.get(d)      : null);
    const bestPH = labels.map(d => bestMap.has(d)     ? bestMap.get(d)     : null); // used in tooltip only
  
    // Build chart
    if (chartInstance) chartInstance.destroy();
    chartInstance = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          // 1) Band (min then max). Max fills down to previous (min) to create the shaded envelope.
          {
            label: 'Pre-high range (min)',
            data: bandMin,
            borderWidth: 0,
            pointRadius: 0,
            spanGaps: true
          },
          {
            label: 'Pre-high range (max)',
            data: bandMax,
            borderWidth: 0,
            pointRadius: 0,
            spanGaps: true,
            fill: { target: '-1' },                  // fill to previous dataset (min)
            backgroundColor: 'rgba(37,99,235,0.10)'  // subtle blue-ish shade
          },
  
          // 2) Actual
          {
            label: 'Actual high',
            data: actual,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 0,
            pointHitRadius: 10,
            spanGaps: true,
            borderColor: '#2563eb'
          },
  
          // 3) Last pre-high (what you realistically knew)
          {
            label: 'Last pre-high forecast',
            data: lastPH,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 0,
            pointHitRadius: 10,
            spanGaps: true,
            borderColor: '#059669'
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        spanGaps: true,
        animation: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { display: true },
          tooltip: {
            mode: 'index',
            intersect: false,
            callbacks: {
              title: (items) => {
                const iso = labels[items[0].dataIndex];
                const [Y,M,D] = iso.split('-').map(Number);
                const jsDate = new Date(Y, M-1, D);
                return new Intl.DateTimeFormat('en-US', { weekday:'short', month:'short', day:'numeric' }).format(jsDate);
              },
              label: (ctx) => {
                const y = ctx.parsed.y;
                const name = ctx.dataset.label;
                if (y == null) return `${name}: ‚Äî`;
                return `${name}: ${Number(y).toFixed(1)}¬∞F`;
              },
              afterBody: (items) => {
                // Append Best pre-high + simple errors in the tooltip (no extra line on chart)
                const idx = items?.[0]?.dataIndex;
                if (idx == null) return '';
                const a = actual[idx], lp = lastPH[idx], bp = bestPH[idx];
                const parts = [];
  
                if (bp != null) {
                  parts.push(`Best pre-high: ${bp.toFixed(1)}¬∞F`);
                }
                if (a != null && lp != null) {
                  const errLast = (lp - a).toFixed(1);
                  parts.push(`Last error: ${errLast}¬∞F`);
                }
                if (a != null && bp != null) {
                  const errBest = (bp - a).toFixed(1);
                  parts.push(`Best error: ${errBest}¬∞F`);
                }
                return parts.length ? parts.join('\n') : '';
              }
            }
          }
        },
        scales: {
          x: {
            title: { display: true, text: 'Day' },
            grid: { color: 'rgba(0,0,0,0.05)' },
            offset: true,
            ticks: {
              autoSkip: true, autoSkipPadding: 8, maxRotation: 0, minRotation: 0,
              callback: (val, idx) => {
                const iso = labels[idx];
                if (!iso) return '';
                const [Y,M,D] = iso.split('-').map(Number);
                const jsDate = new Date(Y, M-1, D);
                return new Intl.DateTimeFormat('en-US', { month:'short', day:'numeric' }).format(jsDate);
              }
            }
          },
          y: {}
        }
      }
    });
  }

    async function displayTable() {
      const tb = document.querySelector("#dataTable tbody");
      if (!tb) return;
      tb.innerHTML = "";

      const dayMap = {};
      filteredRows.forEach(r => {
        const date = (r.forecast_or_actual === "actual" ? r.cli_date : r.target_date);
        if (!/^\d{4}-\d{2}-\d{2}$/.test(date || "")) return;
        (dayMap[date] ??= []).push(r);
      });

      const dates = Object.keys(dayMap).sort();
      const months = {};
      dates.forEach(d => {
        const mk = monthKeyFromISO(d);
        (months[mk] ??= []).push(d);
      });

      const kalshiByDate = {};
      await Promise.all(dates.map(async d => {
        try { kalshiByDate[d] = await getKalshiLabel(d); }
        catch { kalshiByDate[d] = null; }
      }));

      const todayISO = nycISODate(0);
      const yISO = nycISODate(-1);

      Object.keys(months).sort().forEach(mk => {
        const label = monthLabelFromKey(mk);
        const hdr = document.createElement("tr");
        hdr.className = "month-row collapsed";
        hdr.dataset.month = mk;
        hdr.innerHTML = `<td colspan="9"><span class="caret">‚ñ∏</span>${label}</td>`;
        tb.appendChild(hdr);

        months[mk].forEach(date => {
          const rows = dayMap[date];
          const forecasts = rows.filter(r => r.forecast_or_actual === "forecast");
          const actual = rows.find(r => r.forecast_or_actual === "actual") || null;

          forecasts.sort((a, b) => {
            const A = (a.timestamp || a.forecast_time || "");
            const B = (b.timestamp || b.forecast_time || "");
            return A.localeCompare(B);
          });

          let bestIdx = -1, bestErr = Infinity;
          const actualHigh = actual && actual.actual_high ? Number(actual.actual_high) : null;
          const highTime = actual && actual.high_time ? actual.high_time : "";

          forecasts.forEach((r, i) => {
            if (!r.predicted_high || actualHigh == null) return;
            if (highTime) {
              const fcHH = (r.forecast_time || "").substr(11, 5);
              if (fcHH && compareTimes(fcHH, highTime) > 0) return;
            }
            const err = Math.abs(Number(r.predicted_high) - actualHigh);
            if (err < bestErr) { bestErr = err; bestIdx = i; }
          });

          forecasts.forEach((r, i) => {
            const cls = "forecast-row" + (i === bestIdx ? " best" : "");
            const pulled = r.timestamp || r.date_pulled || "";
            const fcTime = (r.forecast_time || "").substr(11, 5);
            const pred = r.predicted_high ? `${r.predicted_high}¬∞F` : "";
            const actTxt = (actual && actual.actual_high) ? `${actual.actual_high}¬∞F` : "";
           const errTxt = (r.predicted_high && actualHigh != null)
          ? (Number(r.predicted_high) - actualHigh).toFixed(1)   // signed error: pred - actual
          : "";

            const tr = document.createElement("tr");
            tr.className = cls + " is-hidden";
            tr.dataset.month = mk;
            tr.innerHTML = `
              <td>${pulled}</td>
              <td>${fcTime}</td>
              <td>${date}</td>
              <td>${pred}</td>
              <td>${actTxt}</td>
              <td>${highTime || ""}</td>
              <td>${errTxt}</td>
              <td>${i === bestIdx ? "‚úÖ" : ""}</td>
              <td></td>
            `;
            tb.appendChild(tr);
          });

          if (actual) {
            const pulled = actual.timestamp || actual.date_pulled || "";
            const actTxt = actual.actual_high ? `${actual.actual_high}¬∞F` : "";
            const k = kalshiByDate[date];
            const label = k && k.label ? k.label : "";
            const exact = (k && k.exactTemp != null) ? ` (${k.exactTemp.toFixed(1)}¬∞F)` : "";

            let kalshiCell = "‚Äî";
            if (date === yISO) {
              kalshiCell = `<a class="kalshi-badge" href="${KALSHI_BASE_URL}${kalshiAnchorForISO(yISO)}" target="_blank" rel="noopener noreferrer">${label || "Open market"}${exact}</a>`;
            } else if (date === todayISO) {
              kalshiCell = `<a class="kalshi-badge" href="${KALSHI_BASE_URL}" target="_blank" rel="noopener noreferrer">${label || "Open market"}</a>`;
            } else if (label) {
              kalshiCell = `<span class="kalshi-badge">${label}${exact}</span>`;
            }

            const tr = document.createElement("tr");
            tr.className = "actual-row is-hidden";
            tr.dataset.month = mk;
            tr.innerHTML = `
              <td>${pulled}</td>
              <td></td>
              <td>${date}</td>
              <td></td>
              <td>${actTxt}</td>
              <td>${actual.high_time || ""}</td>
              <td></td>
              <td></td>
              <td>${kalshiCell}</td>
            `;
            tb.appendChild(tr);
          }
        });
      });

      tb.onclick = (e) => {
        const tr = e.target.closest("tr.month-row");
        if (!tr) return;
        const mk = tr.dataset.month;
        
        // First, collapse ALL other months
        tb.querySelectorAll("tr.month-row").forEach(row => {
          if (row !== tr) {
            row.classList.add("collapsed");
            const monthKey = row.dataset.month;
            tb.querySelectorAll(`tr[data-month="${monthKey}"]:not(.month-row)`).forEach(r =>
              r.classList.add("is-hidden")
            );
          }
        });
        
        // Then toggle the clicked month
        const collapsed = tr.classList.toggle("collapsed");
        tb.querySelectorAll(`tr[data-month="${mk}"]:not(.month-row)`).forEach(r =>
          r.classList.toggle("is-hidden", collapsed)
        );
      };
    }

    function resetFilter() {
      filteredRows = allRows.slice();
      const f = document.getElementById('fromDate'); if (f) f.value = "";
      const t = document.getElementById('toDate');   if (t) t.value = "";
      displayTable();
      showStats();
      showChart();
      showMostRecent();
      updateCorrectionBoxes();
      updateSummaryBoxes();
    }

    function applyDateFilter() {
      const from = document.getElementById('fromDate').value;
      const to   = document.getElementById('toDate').value;
      filteredRows = allRows.filter(row => {
        const date = row.forecast_or_actual === "actual" ? row.cli_date : row.target_date;
        if (!date) return false;
        if (from && date < from) return false;
        if (to && date > to) return false;
        return true;
      });
      displayTable();
      showStats();
      showChart();
      showMostRecent();
      updateCorrectionBoxes();
      updateSummaryBoxes();
    }

   function showStats() {
  const stats = document.getElementById('stats');
  if (!stats) return;

  const dayMap = {};
  filteredRows.forEach(r => {
    const date = (r.forecast_or_actual === "actual" ? r.cli_date : r.target_date);
    if (!date) return;
    (dayMap[date] ??= []).push(r);
  });

  const dates = Object.keys(dayMap).filter(d => /^\d{4}-\d{2}-\d{2}$/.test(d));
  const daysWithActual = dates.filter(d => {
    const rows = dayMap[d] || [];
    return rows.some(r => r.forecast_or_actual === "actual" && r.actual_high);
  });

  let totalAbsErr = 0, totalBestErr = 0, errCount = 0, bestCount = 0;
  let totalSignedErr = 0, totalBestSignedErr = 0;  // NEW: track signed errors

  daysWithActual.forEach(d => {
    const rows = dayMap[d] || [];
    const actual = rows.find(r => r.forecast_or_actual === "actual" && r.actual_high);
    if (!actual) return;
    const actualHigh = Number(actual.actual_high);
    const highTime = actual.high_time || "";

    const forecasts = rows
      .filter(r => r.forecast_or_actual === "forecast" && r.predicted_high)
      .filter(r => {
        if (highTime) {
          const fcHH = (r.forecast_time || "").substr(11, 5);
          if (fcHH && compareTimes(fcHH, highTime) > 0) return false;
        }
        return true;
      })
      .map(r => Number(r.predicted_high))
      .filter(Number.isFinite);

    if (forecasts.length) {
      const signedErrors = forecasts.map(f => f - actualHigh);  // NEW: keep sign
      const allErrors = forecasts.map(f => Math.abs(f - actualHigh));
      
      const avgErr = allErrors.reduce((a, b) => a + b, 0) / allErrors.length;
      const avgSignedErr = signedErrors.reduce((a, b) => a + b, 0) / signedErrors.length;  // NEW
      
      const bestIdx = allErrors.indexOf(Math.min(...allErrors));
      const bestErr = allErrors[bestIdx];
      const bestSignedErr = signedErrors[bestIdx];  // NEW: signed error of best forecast
      
      totalAbsErr += avgErr;
      totalSignedErr += avgSignedErr;  // NEW
      totalBestErr += bestErr;
      totalBestSignedErr += bestSignedErr;  // NEW
      errCount++;
      bestCount++;
    }
  });

  const avgAbsErr = errCount > 0 ? (totalAbsErr / errCount).toFixed(1) : "--";
  const avgBestErr = bestCount > 0 ? (totalBestErr / bestCount).toFixed(1) : "--";
  const meanBias = errCount > 0 ? (totalSignedErr / errCount) : null;  // NEW
  const bestBias = bestCount > 0 ? (totalBestSignedErr / bestCount) : null;  // NEW

  // Format bias with + or - sign
  const meanBiasStr = meanBias != null 
    ? (meanBias >= 0 ? "+" : "") + meanBias.toFixed(1) + "¬∞F"
    : "--";
  const bestBiasStr = bestBias != null
    ? (bestBias >= 0 ? "+" : "") + bestBias.toFixed(1) + "¬∞F" 
    : "--";

stats.innerHTML = `
  <div class="stat-card">
    <div class="stat-label">
      Days Tracked
      <span class="tip" tabindex="0" data-tip="Total days with any forecast data">i</span>
    </div>
    <div class="stat-value">${dates.length}</div>
  </div>
  <div class="stat-card">
    <div class="stat-label">
      Days With Actual
      <span class="tip" tabindex="0" data-tip="Days where the actual high was recorded">i</span>
    </div>
    <div class="stat-value">${daysWithActual.length}</div>
  </div>
  <div class="stat-card">
    <div class="stat-label">
      Avg Absolute Error
      <span class="tip" tabindex="0" data-tip="Average forecast error magnitude (ignores direction)">i</span>
    </div>
    <div class="stat-value">${avgAbsErr}¬∞F</div>
  </div>
  <div class="stat-card">
    <div class="stat-label">
      Avg Forecast Bias
      <span class="tip" tabindex="0" data-tip="Average signed error: + means forecasts run high, - means low">i</span>
    </div>
    <div class="stat-value" style="color: ${meanBias > 0 ? '#d97706' : meanBias < 0 ? '#2563eb' : 'inherit'}">
      ${meanBiasStr}
    </div>
  </div>
  <div class="stat-card">
    <div class="stat-label">
      Best Absolute Error
      <span class="tip" tabindex="0" data-tip="Average error of each day's most accurate forecast">i</span>
    </div>
    <div class="stat-value">${avgBestErr}¬∞F</div>
  </div>
  <div class="stat-card">
    <div class="stat-label">
      Best Forecast Bias
      <span class="tip" tabindex="0" data-tip="Average bias of each day's best forecast">i</span>
    </div>
    <div class="stat-value" style="color: ${bestBias > 0 ? '#d97706' : bestBias < 0 ? '#2563eb' : 'inherit'}">
      ${bestBiasStr}
    </div>
  </div>
`;
}
    // Expose necessary functions globally for auth script
    window.probeLoggingEndpoint = probeLoggingEndpoint;
    window.reloadCSV = reloadCSV;
    window.updateDSM = updateDSM;
    window.updateSixHourMax = updateSixHourMax;
    window.updateObservations = updateObservations;
    window.updateSummaryBoxes = updateSummaryBoxes;
    window.updateCorrectionBoxes = updateCorrectionBoxes;
    window.pollCsvAndUpdate = pollCsvAndUpdate;
  </script>

  <!-- Auth + boot (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
<script>
(() => {
  const supabase = window.supabase.createClient(
    "https://ztjtuhkjkqchsiuuvmzs.supabase.co",
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inp0anR1aGtqa3FjaHNpdXV2bXpzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYzMTUwODIsImV4cCI6MjA3MTg5MTA4Mn0.g7Zq-YbHxBzw732PhVfTf7XGiR080gRndsrzc0YPHfw"
  );

  const gate = document.getElementById("gate");
  function gateMsg(msg){
    const sub = gate && gate.querySelector(".gate-sub");
    if (sub && msg) sub.textContent = msg;
  }

  // Buttons
  document.getElementById("btn-logout")?.addEventListener("click", async () => {
    try { await supabase.auth.signOut(); } catch(e) {}
    try { localStorage.removeItem("dashboard_heartbeat"); } catch(e) {}
    window.location.href = "login.html";
  });

  document.getElementById("btn-billing")?.addEventListener("click", async () => {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) { window.location.href = "login.html"; return; }
    try {
      const r = await fetch("/api/create-portal-session", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ supabaseAccessToken: session.access_token })
      });
      const j = await r.json();
      if (!r.ok || !j?.url) { alert(j?.error || "Could not open billing portal"); return; }
      window.location.href = j.url;
    } catch (e) { alert("Could not open billing portal"); }
  });

  async function bootApp() {
    // light, defensive calls
    try { window.showTodayDate && window.showTodayDate(); } catch {}
    try { window.scheduleMidnightUpdate && window.scheduleMidnightUpdate(); } catch {}

    try { window.probeLoggingEndpoint && await window.probeLoggingEndpoint(); } catch {}

     try { window.reloadCSV && await window.reloadCSV({ skipUI: true }); } catch {}
  try { window.warmOnceForCurrentCSV && await window.warmOnceForCurrentCSV(); } catch {}
    // now paint the UI once, with warmed state
    try { window.resetFilter && window.resetFilter(); } catch {}
    try { window.showMostRecent && window.showMostRecent(); } catch {}
    try { window.updateSummaryBoxes && window.updateSummaryBoxes(); } catch {}
    try { window.updateCorrectionBoxes && window.updateCorrectionBoxes(); } catch {}
    try { window.updateObservations && window.updateObservations(); } catch {}
    try { window.updateDSM && window.updateDSM(); } catch {}
    try { window.updateSixHourMax && window.updateSixHourMax(); } catch {}
    try { window.updateObservations && window.updateObservations(); } catch {}
    try { window.updateSummaryBoxes && window.updateSummaryBoxes(); } catch {}
    try { window.updateCorrectionBoxes && window.updateCorrectionBoxes(); } catch {}

    try { window.pollCsvAndUpdate && window.pollCsvAndUpdate(); } catch {}
    setInterval(() => { try { window.updateObservations && window.updateObservations(); } catch {} }, 5 * 60 * 1000);
    setInterval(() => { try { window.updateDSM && window.updateDSM(); } catch {} }, 10 * 60 * 1000);
    setInterval(() => { try { window.updateSixHourMax && window.updateSixHourMax(); } catch {} }, 10 * 60 * 1000);
    setInterval(() => { try { window.updateSummaryBoxes && window.updateSummaryBoxes(); } catch {} }, 60 * 1000);
    setInterval(() => { try { window.updateCorrectionBoxes && window.updateCorrectionBoxes(); } catch {} }, 60 * 1000);
    setInterval(() => { try { window.pollCsvAndUpdate && window.pollCsvAndUpdate(); } catch {} }, 60 * 1000);
    // Poll AccuWeather every 2 hours
    fetchAccuWeatherForecasts();
    setInterval(fetchAccuWeatherForecasts, 2 * 60 * 60 * 1000);

    try {
      localStorage.setItem("dashboard_heartbeat", String(Date.now()));
      setInterval(() => { try { localStorage.setItem("dashboard_heartbeat", String(Date.now())); } catch {} }, 60 * 1000);
    } catch {}
  }

async function checkAccess() {
  const path = location.pathname || "";
  const onLogin = /\/login(\.html)?$/.test(path);
  const onSubscribe = /\/subscribe(\.html)?$/.test(path);

  gateMsg("Checking access‚Ä¶");

  // 1) Session
  const { data: sessData, error: sErr } = await supabase.auth.getSession();
  if (sErr) {
    console.warn("getSession error", sErr);
    // If we're on login already, just show the prompt; otherwise go to login
    if (!onLogin) location.href = "login.html";
    else gateMsg("Please sign in.");
    return;
  }
  const session = sessData?.session || null;

  if (!session) {
    if (!onLogin) {
      gateMsg("Not signed in ‚Üí redirecting to login‚Ä¶");
      location.href = "login.html";
    } else {
      gateMsg("Please sign in.");
    }
    return;
  }

  // 2) Entitlement (profiles)
  try {
    const { data: profile, error } = await supabase
      .from("profiles")
      .select("subscription_status, current_period_end, trial_used")
      .eq("id", session.user.id)
      .single();

    if (error) throw error;

    const status = String(profile?.subscription_status || "inactive").toLowerCase();
    const entitled = (status === "active" || status === "trialing");

    if (!entitled) {
      if (!onSubscribe) {
        const dest = profile?.trial_used ? "subscribe.html?reason=trial_expired" : "subscribe.html";
        gateMsg("Subscription required ‚Üí redirecting‚Ä¶");
        location.href = dest;
      } else {
        gateMsg("Subscription required.");
      }
      return;
    }

    // 3) Authorized ‚Üí show the app
    try { window.showApp && window.showApp(); } catch {}
    await bootApp().catch(console.error);

  } catch (e) {
    // On any entitlement error: don't loop from login; show message there
    console.warn("Entitlement check failed", e);
    if (!onLogin) {
      location.href = "login.html";
    } else {
      gateMsg("Please sign in.");
    }
  }
}

supabase.auth.onAuthStateChange((_event, session) => {
  const onLogin = /\/login(\.html)?$/.test(location.pathname || "");
  if (!session && !onLogin) {
    location.href = "login.html";
  }
  // If on /login, let the login UI handle it.
});

  checkAccess();
})();
</script>
</body>
</html>
