<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üå°Ô∏è Daily Dew Point Dashboard</title>

  <!-- Performance hints -->
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="dns-prefetch" href="https://fonts.googleapis.com">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <style>
 :root {
      --bg-primary: #fafbfc;
      --bg-secondary: #ffffff;
      --bg-tertiary: #f8f9fa;
      --bg-accent: #f1f5f9;
      --text-primary: #0f172a;
      --text-secondary: #334155;
      --text-muted: #64748b;
      --text-light: #94a3b8;
      --border-subtle: #e2e8f0;
      --border-default: #cbd5e1;
      --accent-blue: #2563eb;
      --accent-blue-light: #dbeafe;
      --accent-green: #059669;
      --accent-green-light: #d1fae5;
      --accent-amber: #d97706;
      --accent-amber-light: #fef3c7;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, .05);
    }

:root[data-theme="dark"] {
  --bg-primary: #0b1220;
  --bg-secondary: #0e1726;
  --bg-tertiary: #121a2b;
  --bg-accent: #0f1a33;
  --text-primary: #e6edf7;
  --text-secondary: #c7d2e3;
  --text-muted: #9fb0c8;
  --text-light: #7f93b1;
  --border-subtle: #1f2937;
  --border-default: #334155;
  --accent-blue: #3b82f6;
  --accent-blue-light: #1e3a8a;
  --accent-green: #10b981;
  --accent-green-light: #064e3b;
  --accent-amber: #f59e0b;
  --accent-amber-light: #78350f;
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.5);
}


    * { box-sizing: border-box; }

    /* Gate (shows immediately, then hidden on boot) */
    #gate {
      display: flex; align-items: center; justify-content: center;
      min-height: 100vh;
      background: var(--bg-primary); color: var(--text-primary);
      font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif;
      padding: 24px; text-align: center;
    }
    .gate-card { background: var(--bg-secondary); border: 1px solid var(--border-subtle);
      border-radius: 16px; padding: 24px 22px; box-shadow: var(--shadow-sm);
      max-width: 520px; width: 100%;
    }
    .gate-title { font-size: 18px; font-weight: 800; margin: 0 0 6px; }
    .gate-sub { font-size: 14px; color: var(--text-muted); margin: 0 0 12px; }
    .gate-note { font-size: 12px; color: var(--text-light); }
    .gate-spinner { width: 28px; height: 28px; border-radius: 50%;
      border: 3px solid var(--border-subtle); border-top-color: var(--accent-blue);
      margin: 12px auto 8px; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* App */
    body {
      font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif;
      background: var(--bg-primary); color: var(--text-primary);
      margin: 0; line-height: 1.6;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }

    .header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-subtle);
      padding: 20px 0; position: sticky; top: 0; z-index: 10; backdrop-filter: blur(8px);
    }
    .header-content { max-width: 1400px; margin: 0 auto; padding: 0 20px;
      display: flex; align-items: center; justify-content: space-between; }
    .brand { display: flex; align-items: center; justify-content: space-between; gap: 14px; }
    .brand-left { display: flex; align-items: center; gap: 12px; }
    .brand-mark { display: grid; place-items: center; width: 40px; height: 40px;
      border-radius: 12px; background: linear-gradient(135deg, var(--accent-blue-light), var(--accent-green-light));
      box-shadow: var(--shadow-sm); border: 1px solid var(--border-subtle); position: relative; top: -3px; }
    .brand-mark svg { display: block; transform: translate(1px, 1px); }
    .brand-title { margin: 0; font-weight: 800; letter-spacing: .2px;
      font-size: 28px; line-height: 1.15; color: var(--text-primary); }
    .brand-title .thin { font-weight: 600; color: var(--text-secondary); }
    .brand-sub { margin: 2px 0 0; font-size: 13px; color: var(--text-muted); }
    .brand-right { display: flex; flex-direction: column; align-items: flex-end; gap: 6px; }
    .brand-right .pill-group { display: flex; gap: 6px; }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; font-size: 12px; font-weight: 700;
      color: var(--text-secondary); background: var(--bg-accent); border: 1px solid var(--border-subtle); border-radius: 999px; }
    .pill.live { background: var(--accent-green-light); color: var(--accent-green); border-color: transparent; }
    .pill.live .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--accent-green); animation: pulse 2s infinite; }
    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.5} }
    .pill.logout-btn { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-default); }

    .container { max-width: 1400px; margin: 0 auto; padding: 24px; }

    .last-update { background: var(--bg-secondary); border: 1px solid var(--border-subtle);
      border-radius: 12px; padding: 18px 20px; margin-bottom: 20px; box-shadow: var(--shadow-sm); }
    .last-update-label { font-size: 12px; color: var(--text-muted); letter-spacing: .06em; text-transform: uppercase; margin-bottom: 4px; font-weight: 600; }
    .last-update-content { font-size: 15px; color: var(--text-secondary); font-weight: 600; }
    #todayDate { display: block; font-size: 14px; font-weight: 700; color: var(--text-primary); margin-bottom: 2px; }

    .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 18px; margin-bottom: 22px; }
    .metric-card { background: var(--bg-secondary); border: 1.5px solid var(--border-subtle); border-radius: 18px; padding: 24px;
      box-shadow: var(--shadow-sm); position: relative; overflow: hidden; }
    .metric-card::before { content: ''; position: absolute; inset: 0 0 auto; height: 4px;
      background: linear-gradient(90deg, var(--accent-blue), var(--accent-green)); }
    .metric-card.today-forecast::before { background: var(--accent-amber); }
    .metric-card.today-obs::before { background: var(--accent-blue); }
    .metric-card.today-actual::before { background: var(--accent-green); }
    .metric-card.tomorrow-forecast::before { background: var(--accent-blue); }
    .metric-label { font-size: 14px; color: var(--text-muted); margin-bottom: 6px; font-weight: 700; letter-spacing: .02em; }
    .metric-value { font-size: 36px; font-weight: 800; color: var(--text-primary); margin-bottom: 10px; line-height: 1; }
    .metric-subtitle { font-size: 13px; color: var(--text-light); }
    .mini-forecasts { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px; }
    .mini-chip { background: var(--bg-accent); color: var(--text-secondary); padding: 4px 10px; border-radius: 999px;
      font-size: 12px; font-weight: 700; border: 1px solid var(--border-subtle); }

    .kalshi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 18px; margin-bottom: 22px; }
    .kalshi-card { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 16px; padding: 22px; }
    .kalshi-badge { background: var(--accent-amber-light); color: var(--accent-amber);
      padding: 8px 14px; border-radius: 999px; font-size: 14px; font-weight: 800; text-decoration: none; display: inline-block; }
    .kalshi-pending { background: var(--bg-accent); color: var(--text-muted); padding: 8px 14px; border-radius: 999px; font-size: 14px; font-weight: 700; border: 2px dashed var(--border-default); }
    .kalshi-note { font-size: 12px; color: var(--text-light); margin-top: 6px; }

    .prediction-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(360px, 1fr)); gap: 18px; margin-bottom: 22px; }
    .prediction-card { background: linear-gradient(135deg, var(--accent-blue-light), var(--accent-green-light));
      border: 1px solid var(--border-subtle); border-radius: 16px; padding: 24px; }
    .prediction-title { font-size: 15px; font-weight: 800; margin-bottom: 12px; }
    .prediction-content {}
    .prediction-value { font-size: 28px; font-weight: 800; color: var(--text-primary); }
    .prediction-subtitle { font-size: 13px; color: var(--text-secondary); }

    /* Bucket-centric prediction display ‚Äî 3-tier layout */
    .bucket-display { display: flex; align-items: center; gap: 14px; margin-bottom: 4px; }
    .bucket-range { font-size: 32px; font-weight: 800; color: var(--text-primary); }
    .bucket-signal { display: inline-block; padding: 5px 12px; border-radius: 8px; font-size: 13px; font-weight: 800; letter-spacing: 0.05em; color: #fff; }
    .bucket-signal.bet { background: #059669; }
    .bucket-signal.lean { background: #d97706; }
    .bucket-signal.skip { background: #dc2626; }
    .probability-value { font-size: 28px; font-weight: 800; margin-left: auto; }
    .probability-value.bet { color: #059669; }
    .probability-value.lean { color: #d97706; }
    .probability-value.skip { color: #dc2626; }
    .confidence-reason { font-size: 13px; color: var(--text-muted); font-weight: 600; margin-bottom: 6px; }
    .source-details { margin-top: 4px; }
    .source-details summary { font-size: 12px; color: var(--text-muted); cursor: pointer; font-weight: 600; }
    .source-details .detail-content { font-size: 12px; color: var(--text-muted); margin-top: 4px; padding: 8px; background: var(--bg-tertiary); border-radius: 8px; }

    .controls-section { background: var(--bg-secondary); border: 1px solid var(--border-subtle);
      border-radius: 16px; padding: 18px; margin-bottom: 22px; }
    .controls-title { font-size: 15px; font-weight: 800; margin-bottom: 10px; }
    .controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .control-group { display: flex; align-items: center; gap: 6px; }
    .control-label { font-size: 13px; font-weight: 700; color: var(--text-secondary); }
    input[type="date"] { padding: 8px 10px; border: 1px solid var(--border-default); border-radius: 10px; font-size: 14px; background: var(--bg-secondary); }
    input[type="date"]:focus { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 3px var(--accent-blue-light); }
    .btn { background: var(--accent-blue); color: #fff; border: none; border-radius: 10px; padding: 9px 16px; font-size: 14px; font-weight: 800; cursor: pointer; box-shadow: var(--shadow-sm); }
    .btn.secondary { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-default); }

    .stats-grid { 
  display: grid; 
  grid-template-columns: repeat(3, 1fr);  /* Force 3 columns on desktop */
  gap: 16px; 
  margin-bottom: 22px; 
}

/* Tablet: 3 columns but tighter */
@media (max-width: 900px) {
  .stats-grid { 
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
  }
  .stat-card { padding: 14px; }
  .stat-label { font-size: 12px; }
  .stat-value { font-size: 24px; }
}

/* Mobile: keep existing 2 column layout */
@media (max-width: 600px) {
  .stats-grid { 
    grid-template-columns: repeat(2, 1fr); 
    gap: 8px; 
  }
  .stat-card { padding: 10px; }
  .stat-label { font-size: 11px; }
  .stat-value { font-size: 22px; }
}
    .stat-card { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 14px; padding: 18px; text-align: center; }
    .stat-label { font-size: 13px; color: var(--text-muted); font-weight: 700; }
    .stat-value { font-size: 28px; font-weight: 800; color: var(--accent-blue); }

    .chart-section { background: var(--bg-secondary); border: 1px solid var(--border-subtle);
      border-radius: 16px; padding: 24px; margin-bottom: 22px; }
    .chart-title { font-size: 16px; font-weight: 800; margin-bottom: 14px; }
    .chart-container { position: relative; height: clamp(220px, 38vh, 380px); width: 100%; }

    .table-section { background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 16px; padding: 0; overflow: hidden; }
    .table-container { 
      overflow: auto;  /* Changed from overflow-x to handle both directions */
      max-height: 600px;  /* Fixed height makes it scrollable */
      border-top: 1px solid var(--border-subtle); 
      padding: 0 18px 18px; 
    }
    #dataTable { width: 100%; border-collapse: collapse; font-size: 14px; background: var(--bg-secondary); }
    #dataTable th { background: var(--bg-tertiary); color: var(--text-primary); padding: 12px 10px; text-align: left; font-weight: 800;
      font-size: 12px; letter-spacing: .06em; text-transform: uppercase; border-bottom: 2px solid var(--border-default); position: sticky; top: 0; z-index: 1; }
    #dataTable td { padding: 12px 10px; border-bottom: 1px solid var(--border-subtle); color: var(--text-secondary); }
    #dataTable tbody tr:hover { background: var(--bg-accent); }
    .forecast-row { background: var(--accent-blue-light) !important; }
    .actual-row { background: var(--accent-green-light) !important; }
    #dataTable .actual-row td { background: var(--accent-green-light) !important; }
    #dataTable .forecast-row td { background: var(--accent-blue-light) !important; }
    .best { box-shadow: inset 0 0 0 2px var(--accent-green); }
    details.table-wrap { border-top: 1px solid var(--border-subtle); }
    details.table-wrap summary { background: var(--bg-accent); border-bottom: 1px solid var(--border-subtle);
      list-style: none; cursor: pointer; padding: 16px 18px; font-weight: 800; display: flex; align-items: center; justify-content: space-between; }
    details.table-wrap summary::-webkit-details-marker { display: none; }
    .caret { transition: transform .2s ease; }
    details[open] summary .caret { transform: rotate(90deg); }
    .skel td::before { content: ""; display: block; height: 12px; margin: 4px 0; width: 70%;
      background: linear-gradient(90deg, var(--bg-accent), var(--bg-tertiary), var(--bg-accent));
      background-size: 200% 100%; animation: shimmer 1.5s infinite; border-radius: 4px; }
    @keyframes shimmer { 0%{background-position:-200% 0} 100%{background-position:200% 0} }
    
    /* Info note style (exceedance, etc) */
    .info-note {
      background: #dbeafe;
      border: 1px solid #3b82f6;
      color: #1e40af;
      padding: 10px 14px;
      border-radius: 10px;
      margin-top: 12px;
      font-size: 13px;
      font-weight: 600;
    }
    .ml-badge {
      font-size: 11px;
      font-weight: 700;
      color: #fff;
      background: var(--accent-blue);
      padding: 2px 7px;
      border-radius: 6px;
    }
    /* Track record banner */
    .track-record {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 14px 20px;
      margin-bottom: 22px;
      flex-wrap: wrap;
    }
    .track-label { font-size: 13px; color: var(--text-muted); font-weight: 700; }
    .track-value { font-size: 22px; font-weight: 800; color: var(--accent-blue); }
    .track-value.highlight { color: #059669; }
    .track-sep { color: var(--border-default); font-size: 20px; }

    .footer { margin-top: 28px; padding: 18px 24px; background: var(--bg-tertiary); border-top: 1px solid var(--border-subtle);
      text-align: center; font-size: 12px; color: var(--text-light); }
    .footer a { color: var(--accent-blue); text-decoration: none; }

    /* Month group header row */
    #dataTable tr.month-row { background: var(--bg-tertiary); border-top: 2px solid var(--border-default); cursor: pointer; }
    #dataTable tr.month-row td { font-weight: 800; font-size: 12px; letter-spacing: .06em; text-transform: uppercase;
      color: var(--text-primary); padding: 10px 10px; }
    #dataTable tr.month-row .caret { display: inline-block; transition: transform .18s ease; margin-right: 6px; }
    #dataTable tr.month-row.collapsed .caret { transform: rotate(-90deg); }
    #dataTable tr[data-month].is-hidden { display: none; }

    /* Fluid sizes + mobile */
    .brand-title { font-size: clamp(18px, 2.2vw, 28px); }
    .metric-value { font-size: clamp(22px, 3vw, 36px); }
    .prediction-value { font-size: clamp(20px, 2.6vw, 28px); }
    .stat-value { font-size: clamp(18px, 2.4vw, 28px); }
    .kalshi-badge { font-size: clamp(11px, 1.8vw, 14px); padding: 6px 10px; }
    .pill { font-size: clamp(10px, 1.6vw, 12px); padding: 4px 8px; }

    @media (max-width: 600px) {
      .container { padding: 12px; }
      .header { padding: 12px 0; }
      .brand { gap: 8px; }
      .brand-left { gap: 8px; }
      .brand-mark { width: 32px; height: 32px; border-radius: 10px; top: -17px; }
      .brand-mark svg { width: 28px; height: 28px; transform: translate(0, 0); }
      .brand-sub { font-size: 12px; line-height: 1.35; }
      .brand-right .pill-group { margin-top: -14px; }
      .pill.logout-btn { margin-top: 18px; }
      .metrics-grid, .prediction-grid, .kalshi-grid { grid-template-columns: 1fr; gap: 10px; }
      .metric-card { padding: 14px; border-radius: 14px; }
      .metric-label { font-size: 13px; }
      .metric-subtitle { font-size: 12px; }
      .prediction-card { padding: 14px; }
      .track-record { flex-direction: column; gap: 8px; padding: 10px; }
      .track-sep { display: none; }
      .track-value { font-size: 18px; }
      .bucket-range { font-size: 24px; }
      .probability-value { font-size: 22px; }
      .stats-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; }
      .stat-card { padding: 10px; }
      .stat-label { font-size: 11px; }
      .stat-value { font-size: 22px; }
      .mini-forecasts { gap: 4px; }
      .mini-chip { font-size: 11px; padding: 3px 8px; }
      .controls-section { padding: 12px; }
      .controls { gap: 8px; }
      .control-label { font-size: 12px; }
      input[type="date"] { font-size: 13px; padding: 7px 8px; border-radius: 8px; }
      .btn { font-size: 13px; padding: 8px 12px; border-radius: 8px; }
      .chart-section { padding: 14px; }
      .chart-title { font-size: 14px; margin-bottom: 10px; }
      .chart-container { height: 260px; }
      .table-container { padding: 0 12px 12px; }
      #dataTable { font-size: 12px; }
      #dataTable th { font-size: 11px; padding: 10px 8px; }
      #dataTable td { padding: 10px 8px; }
      .brand-right { gap: 6px; flex-wrap: wrap; justify-content: flex-start; }
      .pill { flex: 0 1 auto; }
      .pill .dot { width: 5px; height: 5px; }
      .last-update-label { font-size: 10px; }
      .last-update-content { font-size: 13px; line-height: 1.35; }
    }

    @media (min-width: 601px) {
     .pill.logout-btn { margin-top: 10px; background: var(--bg-tertiary); color: var(--text-secondary);
  border: 1px solid var(--border-default); font-size: 14px; padding: 8px 14px; border-radius: 12px; }
    }

    .brand-right .pill-sep { flex: 0 0 12px; }

    /* Desktop gutter push + styling for billing/logout */
    @media (min-width: 960px) {
      #btn-billing, #btn-logout {
        position: relative;
        left: calc(max(0px, (100vw - 1400px) / 2 - 12px));
        margin-top: -6px;
      }
      .pill.logout-btn { margin-top: -6px; }
      #btn-billing {
        margin-top: -4px; background: #dbeafe; color: #2563eb; border: 1px solid #93c5fd;
      }
      #btn-billing:hover { background: #bfdbfe; }
    }
    #btn-billing, #btn-logout { cursor: pointer; transition: transform .02s ease, box-shadow .15s ease, opacity .15s ease; }
    #btn-billing:hover, #btn-logout:hover { box-shadow: 0 2px 8px rgba(0,0,0,.08); }
    #btn-billing:active, #btn-logout:active { transform: translateY(1px); opacity: .9; }

    /* 2-col grid on desktop for pills/billing/logout */
    @media (min-width: 960px) {
      .brand-right { display: grid; grid-template-columns: auto auto; column-gap: 12px; row-gap: 10px; align-items: center; justify-items: end; }
      .brand-right .pill-group { grid-column: 1; grid-row: 1; }
      #btn-billing { grid-column: 2; grid-row: 1; }
      #btn-logout { grid-column: 2; grid-row: 2; }
      #btn-billing, #btn-logout { left: calc(max(0px, (100vw - 1400px) / 2 - 6px)); }
      #btn-billing { margin-top: -2px; background: #dbeafe; color: #2563eb; border: 1px solid #93c5fd; }
      #btn-billing:hover { background: #bfdbfe; }
    }

    /* Last update row + badge */
    .lu-top { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:20px; flex-wrap:wrap; }
    .lu-date { display:block; font-size:14px; font-weight:700; color:var(--text-primary); text-transform:uppercase; letter-spacing:.02em; margin-bottom:2px; }
    .lu-badge { white-space:nowrap; font-size:12px; font-weight:800; color:#b91c1c; margin-top:4px; }
    @media (max-width: 600px) {
      .lu-top { gap:6px; margin-bottom:2px; }
      .lu-date { margin-bottom:0; }
      .lu-badge { font-size:10px; white-space:normal; display:block; margin-top:0; text-align:right; }
      .last-update-label { font-size:11px; }
    }
    @media (max-width: 600px) {
      .last-update .lu-badge { display:block; margin-top:-6px; }
    }

    /* Tooltip */
    .tip { display:inline-flex; align-items:center; justify-content:center; width:16px; height:16px; border-radius:50%;
      font-size:11px; font-weight:800; line-height:1; cursor:help;
      border:1px solid var(--border-default); color:var(--text-secondary);
      background:var(--bg-tertiary); margin-left:6px; position:relative; outline:none; }
    .tip:hover { box-shadow: 0 1px 6px rgba(0,0,0,.08); }
    .tip:focus-visible { box-shadow: 0 0 0 3px var(--accent-blue-light); }
    .tip[data-tip]::after{
      content:attr(data-tip); position:absolute; inset:auto auto calc(100% + 8px) 50%; transform:translateX(-50%);
      white-space:nowrap; background:#111827; color:#fff; font-size:12px; font-weight:600; padding:6px 8px; border-radius:8px;
      box-shadow:0 4px 12px rgba(0,0,0,.15); opacity:0; pointer-events:none; transition:opacity .12s ease, transform .12s ease;
    }
    .tip[data-tip]::before{
      content:""; position:absolute; inset:auto auto calc(100% + 3px) 50%; transform:translateX(-50%);
      border:6px solid transparent; border-top-color:#111827; opacity:0; transition:opacity .12s ease;
    }
    .tip:hover[data-tip]::after,.tip:focus[data-tip]::after,.tip:hover[data-tip]::before,.tip:focus[data-tip]::before{opacity:1;}
        /* Mobile tooltip fixes */
    @media (max-width: 600px) {
      .tip[data-tip]::after {
        white-space: normal;  /* Allow text to wrap */
        width: 200px;         /* Fixed width for consistency */
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
      }
      
      /* If tooltip would go off left edge, shift it right */
      .stat-card:nth-child(odd) .tip[data-tip]::after {
        left: 0;
        transform: translateX(0);
      }
      
      /* If tooltip would go off right edge, shift it left */
      .stat-card:nth-child(even) .tip[data-tip]::after {
        left: auto;
        right: 0;
        transform: translateX(0);
      }
      
      /* Adjust arrow position for shifted tooltips */
      .stat-card:nth-child(odd) .tip[data-tip]::before {
        left: 16px;
        transform: translateX(0);
      }
      
      .stat-card:nth-child(even) .tip[data-tip]::before {
        left: auto;
        right: 16px;
        transform: translateX(0);
      }
    }
  /* Mobile-only adjustments for prediction formula subtitle */
    @media (max-width: 600px) {
      .prediction-subtitle small {
        display: block;
        margin-top: 4px;
        font-size: 10px;
        line-height: 1.3;
      }
      
      .prediction-card {
        padding-bottom: 14px !important;
      }
    .confidence-low { color: #d97706; }
    .confidence-medium { color: #2563eb; }
    .confidence-high { color: #059669; }
      .prediction-disclaimer {
        font-size: 10px !important;
      }
    }
    /* Theme-aware date inputs */
input[type="date"] {
  color: var(--text-primary);
  background: var(--bg-secondary);
}
:root[data-theme="dark"] input[type="date"]::-webkit-calendar-picker-indicator {
  filter: invert(1);
}
    :root[data-theme="dark"] #btn-billing {
  background: var(--bg-tertiary);
  color: var(--accent-blue);
  border: 1px solid var(--border-default);
}
:root[data-theme="dark"] #btn-billing:hover {
  background: var(--bg-accent);
}
.theme-switch {
  display: flex; align-items: center; gap: 6px;
  cursor: pointer; font: 500 14px/1 Inter, system-ui, sans-serif;
  color: var(--text-secondary);
}
.theme-switch input { display: none; }
.theme-switch .slider {
  position: relative; width: 36px; height: 20px;
  background: var(--border-default);
  border-radius: 20px; transition: background .3s;
}
.theme-switch .slider::before {
  content: ""; position: absolute; height: 14px; width: 14px;
  left: 3px; top: 3px; background: var(--bg-secondary);
  border-radius: 50%; transition: transform .3s;
}
.theme-switch input:checked + .slider { background: #2563eb; }
.theme-switch input:checked + .slider::before { transform: translateX(16px); }
.theme-label { min-width: 40px; }

/* Distinguish Auto (system-follow) from Light */
.theme-switch.is-auto .slider {
  box-shadow: 0 0 6px 2px #2563eb; /* blue glow */
}

  </style>
</head>
  
<body>
  <!-- ====== LOGIN GATE ====== -->
  <div id="gate" role="status" aria-live="polite">
    <div class="gate-card">
      <div class="gate-title">Checking access‚Ä¶</div>
      <div class="gate-sub">Loading the dashboard.</div>
      <div class="gate-spinner" aria-hidden="true"></div>
      <div class="gate-note">This will update automatically.</div>
    </div>
  </div>

  <!-- ====== APP ====== -->
  <div id="app" style="display:none">
    <header class="header">
      <div class="header-content brand">
        <div class="brand-left">
          <div class="brand-mark" aria-hidden="true">
            <svg viewBox="0 0 64 64" width="38" height="38" role="img">
              <defs>
                <linearGradient id="dpGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                  <stop offset="0%" stop-color="var(--accent-blue)" />
                  <stop offset="100%" stop-color="var(--accent-green)" />
                </linearGradient>
              </defs>
              <path fill="url(#dpGrad)" d="M32 6c6 10 16 18 16 30 0 9.94-8.06 18-18 18s-18-8.06-18-18C12 24 26 16 32 6z"/>
            </svg>
          </div>
          <div class="brand-copy">
            <h1 class="brand-title"><span class="thin">Daily</span> Dew&nbsp;Point</h1>
            <p class="brand-sub">Automatically logs every NWS forecast update for Central Park and compares to the official daily high</p>
          </div>
        </div>
      <div class="brand-right">
          <div class="pill-group">
            <span class="pill live"><span class="dot"></span> Live</span>
            <span class="pill">NYC</span>
            <span class="pill">KNYC</span>
          </div>
             <label class="theme-switch">
            <input type="checkbox" id="themeToggle">
            <span class="slider"></span>
            <span class="theme-label">Auto</span>
          </label>
          <button id="btn-billing" class="pill">Manage billing</button>
          <button id="btn-logout" class="pill logout-btn">Log out</button>
        </div>
      </div>
    </header>

    <div class="container">
      <div class="last-update">
        <div class="lu-top">
          <span id="todayDate" class="lu-date"></span>
          <span class="lu-badge">All times and day boundary are Eastern Time (aligned with NWS)</span>
        </div>
        <div class="last-update-label">Latest Forecast Update</div>
        <div id="recentForecast" class="last-update-content">Loading latest forecast data...</div>
      </div>

      <!-- Metrics -->
      <div class="metrics-grid">
        <div class="metric-card today-forecast">
          <div class="metric-label">Today's Latest Forecast</div>
          <div id="box-today-forecast" class="metric-value">‚Äì</div>
          <div class="metric-subtitle">Today's Forecasts</div>
          <div id="mini-today-forecasts" class="mini-forecasts"></div>
        </div>

        <div class="metric-card today-actual">
          <div class="metric-label">Today's High (DSM)</div>
          <div id="box-dsm-max" class="metric-value">‚Äì</div>
          <div id="box-dsm-note" class="metric-subtitle"></div>
          <div style="margin-top:16px; padding-top:14px; border-top:1px solid var(--border-subtle);">
            <div class="metric-label" style="margin-bottom:6px;">Today's Actual High (CLI)</div>
            <div id="box-today-actual" class="metric-value">‚Äì</div>
            <div id="box-today-actual-note" class="metric-subtitle">NWS daily climatological report</div>
          </div>
        </div>

        <div class="metric-card today-obs">
          <div class="metric-label">6 Hr Max</div>
          <div id="box-6hr-max" class="metric-value">‚Äì</div>
          <div id="box-6hr-max-note" class="metric-subtitle"></div>
          <div style="margin-top:16px; padding-top:14px; border-top:1px solid var(--border-subtle);">
            <div class="metric-label">Recent Observed Temperature</div>
            <div id="box-today-current" class="metric-value">‚Äì</div>
            <div id="box-today-current-note" class="metric-subtitle"></div>
          </div>
        </div>

        <div class="metric-card tomorrow-forecast">
          <div class="metric-label">Tomorrow's Latest Forecast</div>
          <div id="box-tomorrow-forecast" class="metric-value">‚Äì</div>
          <div class="metric-subtitle">Tomorrow's Forecasts</div>
          <div id="mini-tomorrow-forecasts" class="mini-forecasts"></div>
        </div>
      </div>

      <!-- Bias-corrected -->
      <div class="prediction-grid" style="display:grid; grid-template-columns:repeat(2,1fr); gap:18px; margin-bottom:22px;">
        <div class="prediction-card">
        <div class="prediction-title">
          Today's Bias-Corrected Prediction
          <span class="tip" tabindex="0" data-tip="Starts with yesterday's forecast for today, updates if additional forecasts come in, and locks once the actual high is reported">i</span>
        </div>
          <div id="correctionBoxToday" class="prediction-content">Loading...</div>
        </div>
        <div class="prediction-card">
          <div class="prediction-title">
            Tomorrow's Bias-Corrected Prediction
            <span class="tip" tabindex="0" data-tip="Uses today‚Äôs forecasts for tomorrow. Once tomorrow begins, updates with that day‚Äôs forecasts if any are issued">i</span>
          </div>
          <div id="correctionBoxTomorrow" class="prediction-content">Loading...</div>
        </div>
        <div class="prediction-disclaimer" style="grid-column:1 / span 2; font-size:12px; color:var(--text-light); margin-top:-4px;">
        Based on historical forecast accuracy patterns; updates as new forecasts arrive. Bias correction reduces average error over many days, but NWS can still miss on individual days.
      </div>
      </div>

      <!-- Track Record -->
      <div class="track-record" id="trackRecord">
        <span class="track-label">Our Bucket Accuracy</span>
        <span class="track-value highlight" id="ourAccuracy">‚Äî%</span>
        <span class="track-sep">|</span>
        <span class="track-label">NWS Alone</span>
        <span class="track-value" id="nwsAccuracy">‚Äî%</span>
        <span class="track-sep">|</span>
        <span class="track-label">Days Verified</span>
        <span class="track-value" id="daysVerified">‚Äî</span>
      </div>

      <!-- Kalshi -->
      <div class="kalshi-grid">
        <div class="kalshi-card">
          <div class="metric-label">Today's Kalshi Market</div>
          <div id="box-today-kalshi" class="metric-value" style="font-size:18px;">Pending settlement</div>
          <div id="box-today-kalshi-note" class="kalshi-note"></div>
        </div>
        <div class="kalshi-card">
          <div class="metric-label">Yesterday's Kalshi Result</div>
          <div id="box-yday-kalshi" class="metric-value" style="font-size:18px;">‚Äì</div>
          <div id="box-yday-kalshi-note" class="kalshi-note"></div>
        </div>
      </div>

      <!-- Controls -->
      <div class="controls-section">
        <div class="controls-title">Filter Data</div>
        <div class="controls">
          <div class="control-group">
            <label class="control-label" for="fromDate">From:</label>
            <input type="date" id="fromDate"/>
          </div>
          <div class="control-group">
            <label class="control-label" for="toDate">To:</label>
            <input type="date" id="toDate"/>
          </div>
          <button class="btn" onclick="applyDateFilter()">Apply Filter</button>
          <button class="btn secondary" onclick="resetFilter()">Show All</button>
          <button class="btn secondary" onclick="reloadCSV()">Refresh Data</button>
        </div>
      </div>

      <!-- Stats -->
      <div class="stats-grid" id="stats">
        <div class="stat-card">
          <div class="stat-label">Days Tracked</div>
          <div class="stat-value">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Days With Actual</div>
          <div class="stat-value">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Average Absolute Error</div>
          <div class="stat-value">--¬∞F</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Average Best Error</div>
          <div class="stat-value">--¬∞F</div>
        </div>
      </div>

      <!-- Chart -->
      <div class="chart-section">
        <div class="chart-title">Temperature Trends: Actual vs Forecasted</div>
        <div class="chart-container">
          <canvas id="dailyChart" width="1000" height="380"></canvas>
        </div>
      </div>

      <!-- Collapsible Table -->
      <div class="table-section">
        <details class="table-wrap">
          <summary>
            <span>Detailed Forecast Log</span>
            <span class="caret">‚ñ∏</span>
          </summary>
          <div class="table-container">
            <table id="dataTable">
              <thead>
                <tr>
                  <th>Date Pulled</th>
                  <th>Forecast Time</th>
                  <th>For Date</th>
                  <th>Forecasted High</th>
                  <th>Actual High</th>
                  <th>High Time</th>
                  <th>Error (¬∞F)</th>
                  <th>Best?</th>
                  <th>Kalshi Range</th>
                  <th>Night Before Prediction</th>
                  <th>Morning Of Prediction</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </details>
      </div>
    </div>

    <footer class="footer">
      ¬© 2025 Daily Dew Point ¬∑
      <a href="/terms.html">Terms</a> ¬∑
      <a href="/privacy.html">Privacy</a> ¬∑
      <span>Informational only, not financial advice. Do your own due diligence before placing any bets or making financial decisions.</span>
    </footer>
  </div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- App scripts -->
  <script>
    /* ========= SIMPLE GATE ========= */
    const $gate = () => document.getElementById('gate');
    const $app  = () => document.getElementById('app');

    function showApp(){ const g=$gate(), a=$app(); if(g) g.style.display='none'; if(a) a.style.display=''; }
    function showGate(msg){ const g=$gate(); if(!g) return; g.style.display=''; const sub=g.querySelector('.gate-sub'); if(sub&&msg) sub.textContent=msg; }
    window.showApp = showApp;
    window.showGate = showGate;

/* ========= DATA + UI ========= */
let allRows = [], filteredRows = [], chartInstance = null, accuRows = [];
// Track last logged values to prevent duplicate API calls (date-specific)
let lastLoggedPredictions = { 
  today: localStorage.getItem(`lastPred_today_${nycISODate(0)}`) ? parseFloat(localStorage.getItem(`lastPred_today_${nycISODate(0)}`)) : null,
  tomorrow: localStorage.getItem(`lastPred_tomorrow_${nycISODate(1)}`) ? parseFloat(localStorage.getItem(`lastPred_tomorrow_${nycISODate(1)}`)) : null
};
// Flag to prevent logging before system is ready
let systemFullyLoaded = false;

// Initialize global if it doesn't exist
if (!window.predictionHistory) {
  window.predictionHistory = {
    today: [],
    tomorrow: [],
    
    add(which, value, timestamp = new Date().toISOString()) {
      if (!['today', 'tomorrow'].includes(which)) return;
      
      const rounded = Math.round(value * 10) / 10;
      
      const last = this[which][this[which].length - 1];
      if (last) {
        if (last.value === rounded) {
          const timeDiff = new Date(timestamp) - new Date(last.timestamp);
          if (timeDiff < 60000) return;
        }
      }
      
      const entry = {
        timestamp,
        value: rounded,
        hour: new Date(timestamp).getHours()
      };
      
      this[which].push(entry);
    },
    
    getRange(which) {
      if (!this[which].length) return null;
      const values = this[which].map(e => Math.round(e.value * 10) / 10);
      const uniqueValues = Array.from(new Set(values));
      return {
        min: Math.min(...uniqueValues),
        max: Math.max(...uniqueValues),
        current: values[values.length - 1],
        changes: uniqueValues.length
      };
    },
    
    crossedBoundary(which, boundary) {
      const values = this[which].map(e => e.value);
      if (values.length < 2) return false;
      
      for (let i = 1; i < values.length; i++) {
        const prev = values[i-1];
        const curr = values[i];
        if ((prev < boundary && curr >= boundary) || 
            (prev >= boundary && curr < boundary)) {
          return true;
        }
      }
      return false;
    }
  };
}

// Use the global object directly
const predictionHistory = window.predictionHistory;

// === Bucket confidence calculator (ML-integrated, replaces separate boundary detector) ===
// 5-component scoring: ML confidence + boundary distance + source agreement + stability + count
// Normal CDF approximation (Abramowitz & Stegun)
function normalCDF(x) {
  if (x < -8) return 0;
  if (x > 8) return 1;
  const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
  const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
  const sign = x < 0 ? -1 : 1;
  const t = 1 / (1 + p * Math.abs(x));
  const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t * Math.exp(-x*x/2);
  return 0.5 * (1 + sign * y);
}

function computeBucketConfidence(prediction, kalshiRange, candidates, kalshiData, mlPrediction, hedgeRMSE) {
  if (!kalshiRange || !Number.isFinite(prediction)) return { pct: 0, signal: "SKIP", reason: "No data", boundary_warning: false };

  const lo = kalshiRange.min ?? (prediction - 5);
  const hi = (kalshiRange.max ?? (prediction + 5)) + 1; // Kalshi "81-82" includes up to 82.99
  const distFromLo = prediction - lo;
  const distFromHi = hi - prediction;
  const minDist = Math.min(distFromLo, distFromHi);

  // --- Probabilistic confidence via normal distribution ---
  // Hedge probability: P(actual falls in this bucket)
  // hedgeRMSE is the bias-corrected RMSE from the Hedge learner
  // Default 1.2 if no learned value yet (conservative but not absurdly wide)
  const std = Math.max(0.8, hedgeRMSE || 1.2);
  const hedgeProb = normalCDF((hi - prediction) / std) - normalCDF((lo - prediction) / std);

  // ML probability (if available)
  const hasML = mlPrediction && mlPrediction.confidence > 0 && !mlPrediction._stale;
  const hasStaleML = mlPrediction && mlPrediction.confidence > 0 && mlPrediction._stale;
  let mlProb = null;
  let mlNote = "";

  if (hasML && kalshiRange.label && mlPrediction.bucket === kalshiRange.label) {
    // ML agrees on bucket ‚Äî use its probability directly
    mlProb = mlPrediction.confidence;
    mlNote = `ML ${Math.round(mlProb * 100)}%`;
  } else if (hasML && mlPrediction.confidence > 0) {
    // ML picks a different bucket ‚Äî its confidence for THIS bucket is lower
    // Use complement: if ML says 70% for its bucket, this bucket gets ~(1-0.70)/N
    mlProb = Math.max(0.05, (1 - mlPrediction.confidence) * 0.3);
    mlNote = `ML favors ${mlPrediction.bucket}`;
  } else if (hasStaleML && kalshiRange.label && mlPrediction.bucket === kalshiRange.label) {
    mlProb = mlPrediction.confidence;
    mlNote = `ML ${Math.round(mlProb * 100)}% (stale)`;
  }

  // Blend: 60% ML + 40% Hedge (fresh), 30% ML + 70% Hedge (stale), 100% Hedge (no ML)
  let blended;
  if (mlProb !== null && hasML) {
    blended = 0.6 * mlProb + 0.4 * hedgeProb;
  } else if (mlProb !== null && hasStaleML) {
    blended = 0.3 * mlProb + 0.7 * hedgeProb;
  } else {
    blended = hedgeProb;
  }

  const pct = Math.min(95, Math.max(5, Math.round(blended * 100)));
  const boundary_warning = minDist < 0.3;

  // Signal thresholds
  let signal, reason;
  if (pct >= 60) {
    signal = "BET";
    const parts = [];
    if (mlNote) parts.push(mlNote);
    if (hedgeProb > 0.5) parts.push("centered in bucket");
    else parts.push("Hedge agrees");
    reason = parts.join(" + ");
  } else if (pct >= 35) {
    signal = "LEAN";
    const parts = [];
    if (mlNote) parts.push(mlNote);
    if (minDist < 0.5) parts.push(`${minDist.toFixed(1)}¬∞ from edge`);
    else parts.push(`std ¬±${std.toFixed(1)}¬∞`);
    reason = parts.join(", ");
  } else {
    signal = "SKIP";
    if (minDist < 0.3) reason = "Too close to boundary";
    else if (std > 2.0) reason = "High uncertainty";
    else reason = "Low probability for this bucket";
  }

  return { pct, signal, reason, minDist: minDist.toFixed(1), boundary_warning, hedgeProb: Math.round(hedgeProb * 100), mlProb: mlProb !== null ? Math.round(mlProb * 100) : null };
}
// Log predictions to Supabase - matches what's on the UI
async function logUIprediction(which, prediction, candidates, conf, bias, rmse, mlData) {
  if (!PREDICTION_LOGGING_ENABLED) return;

  const rounded = Math.round(prediction * 10) / 10;
  const targetDate = which === 'today' ? nycISODate(0) : nycISODate(1);

  const uniqueKey = `${targetDate}|${rounded}`;
  const lastLoggedKey = localStorage.getItem(`lastLoggedKey_${which}`);

  if (lastLoggedKey === uniqueKey) {
    console.log(`Skipping: ${which} already logged ${rounded}¬∞F for ${targetDate}`);
    return;
  }

  const now = new Date();
  const minuteTimestamp = new Date(
    now.getFullYear(), now.getMonth(), now.getDate(),
    now.getHours(), now.getMinutes(), 0, 0
  );

  const payload = {
    target_date: targetDate,
    lead_used: which === 'today' ? 'D0' : 'D1',
    rep_forecast: candidates?.series_rep || prediction,
    delta_last3: 0,
    issuance_iso: minuteTimestamp.toISOString(),
    issuance_hour_local: now.getHours(),
    season: getSeason(targetDate),
    bias_applied: bias || 0,
    prediction_value: rounded,
    uncertainty_rmse: rmse || 2.0,
    model_name: 'hedge_v5',
    version: '5.0',
    forecast_signature: '',
    representative_kind: 'blend',
    timestamp_et: now.toISOString(),
    nws_d0: Number.isFinite(candidates?.D0_latest) ? candidates.D0_latest : null,
    nws_d1: Number.isFinite(candidates?.D1_latest) ? candidates.D1_latest : null,
    accuweather: Number.isFinite(candidates?.AccuWeather) ? candidates.AccuWeather : null,
    // Derive warning fields from confidence score
    has_boundary_warning: conf?.boundary_warning || false,
    warning_level: conf?.pct < 30 ? "critical" : conf?.pct < 45 ? "warning" : null,
    warning_message: conf?.reason || null,
    recommendation: conf?.signal || null,
    };

  try {
    const r = await fetch(`${API_BASE}/log-prediction`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!r.ok && r.status !== 409) {
      console.error(`API error (${r.status}):`, await r.text());
    } else if (r.ok) {
      console.log(`Successfully logged ${which}: ${rounded}¬∞F for ${targetDate}`);
      localStorage.setItem(`lastLoggedKey_${which}`, uniqueKey);
      lastLoggedPredictions[which] = rounded;
    }
  } catch (e) {
    console.error("Network error:", e);
  }
}
    
// Gate inputs (populated by updateObservations / updateSixHourMax)
window._recentObservedF = window._recentObservedF ?? null;
window._sixHourMaxF    = window._sixHourMaxF ?? null;

// --- Detect if overnight high exceeded forecast (full hourly scan) ---
async function checkEarlyMorningExceedance() {
  const todayISO = nycISODate(0);
  const OVERNIGHT_CUTOFF_HOUR = 10; // treat 0‚Äì9 ET as ‚Äúovernight‚Äù

  // Prefer D0; fallback to D1 if D0 isn't issued/ingested yet
  let latestForecast = latestPreHighValue(getForecastRowsFor(todayISO, "D0"), "");
  if (!Number.isFinite(latestForecast)) {
    latestForecast = latestPreHighValue(getForecastRowsFor(todayISO, "D1"), "");
  }
  if (!Number.isFinite(latestForecast) || latestForecast <= 0) return null;

  let overnightHigh = Number(window._overnightHighSoFar);
  let overnightTime = window._overnightHighTime || null;

  const etHourNow = Number(new Intl.DateTimeFormat("en-US", {
    timeZone: "America/New_York",
    hour: "numeric",
    hour12: false
  }).format(new Date()));

  // Use 6-hr max only in the morning window
  if (!Number.isFinite(overnightHigh) &&
      Number.isFinite(Number(window._sixHourMaxF)) &&
      etHourNow < OVERNIGHT_CUTOFF_HOUR) {
    overnightHigh = Number(window._sixHourMaxF);
    overnightTime = null;
  }

  // Fallback: ask server for today's high-so-far
  if (!Number.isFinite(overnightHigh)) {
    try {
      const r = await fetch(`${API_BASE}/nws-high-so-far?station=KNYC`, { cache: "no-store" });
      if (r.ok) {
        const j = await r.json();
        const f = Number(j?.highF);
        const iso = j?.atISO || null;
        if (Number.isFinite(f)) {
          overnightHigh = f;
          overnightTime = iso;
          window._overnightHighSoFar = f;
          window._overnightHighTime  = iso;
        }
      }
    } catch {}
  }

  if (!Number.isFinite(overnightHigh)) return null;

  // If we know the time of the high, require that it actually happened before 10 ET
  if (overnightTime) {
    const etDate = new Date(
      new Date(overnightTime).toLocaleString("en-US", { timeZone: "America/New_York" })
    );
    const hour = etDate.getHours();
    if (hour >= OVERNIGHT_CUTOFF_HOUR) {
      // daytime spike ‚Äì do not label as ‚Äúovernight exceeded‚Äù
      return null;
    }
  }

  if (overnightHigh > latestForecast + 0.3) {
    return {
      currentHigh: overnightHigh,
      overnightHigh,
      forecast: latestForecast,
      time: overnightTime,
      exceedance: +(overnightHigh - latestForecast).toFixed(1),
      occurredOvernight: true
    };
  }
  return null;
}


// Show overnight exceedance note in Today's Bias-Corrected Prediction card
async function handleOvernightExceedanceNote() {
  const box = document.getElementById('correctionBoxToday');
  if (!box) return;

  // Remove any existing note first
  const existing = box.querySelector('.overnight-note');
  if (existing) existing.remove();

  // Do not show once the official CLI ‚ÄúActual‚Äù has published
  if (hasActualFor(nycISODate(0))) return;

// If we previously recorded any post-midnight exceedance, show it immediately
try {
  const todayKey = nycISODate(0);
  const saved = JSON.parse(localStorage.getItem(`overnightExceeded_${todayKey}`) || 'null');
// If there is no entry for *today*, clear any stale in-memory flag from yesterday
if (!saved) window._overnightExceeded = null;
  if (saved && Number.isFinite(Number(saved.value))) {
    // Recompute the latest forecast now
    let latestForecast = latestPreHighValue(getForecastRowsFor(todayKey, "D0"), "");
    if (!Number.isFinite(latestForecast)) {
      latestForecast = latestPreHighValue(getForecastRowsFor(todayKey, "D1"), "");
    }
    const timeLabel = saved.time
      ? new Date(saved.time).toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit" })
      : "overnight";

    const div = document.createElement("div");
    div.className = "overnight-note";
    div.style.cssText = "margin-top:6px;font-size:12px;color:#b91c1c;font-weight:600;";

    // Try to map overnight high to Kalshi bucket + check settlement
    let bucketNote = "";
    let settled = false;
    try {
      const [todayMkt, settledResult] = await Promise.all([
        fetchKalshiLiveLeader(todayKey).catch(() => null),
        getKalshiLabel(todayKey).catch(() => null)
      ]);
      if (todayMkt) {
        const oRange = mapToKalshiRange(Number(saved.value), todayMkt);
        if (oRange?.label) bucketNote = ` ‚Üí ${oRange.label}¬∞F bucket`;
      }
      if (settledResult?.winning_label) {
        settled = true;
        div.style.color = "#059669";
        div.textContent = `Kalshi settled: ${settledResult.winning_label}¬∞F ‚Äî actual high ${Number(saved.value).toFixed(1)}¬∞F (${timeLabel}).`;
        box.appendChild(div);
        return;
      }
    } catch {}

    if (Number.isFinite(latestForecast) && Number(saved.value) > Number(latestForecast)) {
      div.textContent = `High so far: ${Number(saved.value).toFixed(1)}¬∞F${bucketNote} (${timeLabel}) ‚Äî exceeded forecast (${Number(latestForecast).toFixed(1)}¬∞F).`;
    } else {
      div.textContent = `High so far: ${Number(saved.value).toFixed(1)}¬∞F${bucketNote} (${timeLabel}).`;
    }
    box.appendChild(div);
    return;
  }
} catch {}

  // 1) Existing exceedance path
  const res = await checkEarlyMorningExceedance();
  if (res) {
    const timeLabel = res.time
      ? new Date(res.time).toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit" })
      : "overnight";

    const div = document.createElement("div");
    div.className = "overnight-note";
    div.style.cssText = "margin-top:6px;font-size:12px;color:#b91c1c;font-weight:600;";
    div.textContent = `Overnight high of ${res.currentHigh.toFixed(1)}¬∞F (${timeLabel}) already exceeded today's forecast (${res.forecast.toFixed(1)}¬∞F).`;
    box.appendChild(div);
    hidePredictionAndBoundary(box);
    return;
  }

// 2) Neutral path disabled to avoid false positives on normal mornings

}
function hidePredictionAndBoundary(box) {
  const pv = box.querySelector('.prediction-value');
  if (pv) pv.style.display = 'none';
  const sub = box.querySelector('.prediction-subtitle');
  if (sub) sub.style.display = 'none';
}

// --- Helpers: separate NWS vs AccuWeather rows ---
function getNwsForecastRowsFor(targetISO, kind) {
  const dayPrev = prevISO(targetISO);
  const isToday = (targetISO === nycISODate(0));
  const gate    = gateForToday();

  return allRows.filter(r => {
    if ((r.forecast_or_actual || "") !== "forecast") return false;
    if ((r.target_date || "") !== targetISO) return false;

    const issueISO = etDateISOFromTS(r.timestamp || r.forecast_time || "");
    if (!issueISO) return false;

    if (kind === "D0") {
      if (issueISO !== targetISO) return false;
      // Gate only today's intraday captures: drop if forecast high <= max(recent obs, 6-hr max)
    if (isToday && gate != null) {
      const issueDate = new Date(r.timestamp || r.forecast_time);
      const issueHour = issueDate.getHours();
    
      const v = Math.round(Number(r.predicted_high));
      if (Number.isFinite(v) && v <= gate) {
        if (issueHour === 1) {
          console.log(`‚è≠Ô∏è Gate triggered at 1 AM cycle (forecast ${v}¬∞F ‚â§ gate ${gate}¬∞F) ‚Äî keeping row`);
        } else {
          console.log(`‚è≠Ô∏è Gate triggered (forecast ${v}¬∞F ‚â§ gate ${gate}¬∞F) ‚Äî keeping row`);
        }
        // don‚Äôt skip, just continue (row will still be returned)
      }
    }
      return true;
    }

    if (kind === "D1") return issueISO === dayPrev;

    // No kind specified: still gate today's D0 rows
    if (!kind) {
      if (isToday && gate != null && issueISO === targetISO) {
        const v = Math.round(Number(r.predicted_high));
        if (Number.isFinite(v) && v <= gate) return false;
      }
      return true;
    }

    return false;
  });
}


    // === Online ensemble (Hedge) + Bias EWMA (self-learning) =====================
const ENS_KEY = "hedge_v5";               // v5: 4-season, live learning, BCP candidate
const CLIENT_LEARNING = true;             // live-update weights when actuals arrive
const ETA = 0.25;                         // learning rate per ¬∞F (Hedge)
const MIX_GAMMA = 0.02;                   // uniform mix-in to avoid collapse
const DECAY_PER_DAY = 0.997;              // gently decay old info
const BIAS_HALFLIFE_DAYS = 14;            // bias recency (~2 weeks, responsive to season transitions)
const RMSE_HALFLIFE_DAYS = 14;            // uncertainty recency for clamp

async function loadState(key){
  try {
    const { data } = await supabase
      .from('model_states')
      .select('state')
      .eq('key', `${ENS_KEY}:${key}`)
      .single();
    
    if (data?.state) {
      localStorage.setItem(`${ENS_KEY}:${key}`, JSON.stringify(data.state));
      return data.state;
    }
  } catch (e) {
    console.log("Falling back to localStorage");
  }
  
  const raw = localStorage.getItem(`${ENS_KEY}:${key}`);
  return raw ? JSON.parse(raw) : null;
}

function saveState(key, obj){
  localStorage.setItem(`${ENS_KEY}:${key}`, JSON.stringify(obj));
  
  // Fire and forget async save to server
  (async () => {
    try {
      await supabase
        .from('model_states')
        .upsert({ 
          key: `${ENS_KEY}:${key}`,
          state: obj,
          updated_at: new Date().toISOString()
        });
    } catch (e) {
      console.log("Failed to save to server:", e);
    }
  })();
}
function decayWeights(ws){ for (const k in ws) ws[k] *= DECAY_PER_DAY; }
function contextKey(lead, season, hour = null){ 
  // For backward compatibility with stored states during transition
  return `${lead}:${season}`; 
}

function softmaxNormalize(obj){
  let sum = 0; for (const k in obj) sum += obj[k];
  if (sum <= 0) { const ks = Object.keys(obj); const n = ks.length || 1; ks.forEach(k => obj[k]=1/n); return; }
  for (const k in obj) obj[k] /= sum;
}
function mixWithUniform(weights, gamma= MIX_GAMMA){
  const ks = Object.keys(weights); if (!ks.length) return;
  const n = ks.length;
  ks.forEach(k => { weights[k] = (1 - gamma) * weights[k] + gamma * (1 / n); });
}
function ewmaUpdate(old, value, halfLifeDays){
  if (value == null) return old ?? null;
  const alpha = (halfLifeDays && halfLifeDays > 0)
    ? 1 - Math.exp(-Math.log(2) / halfLifeDays)
    : 1;
  return (old == null) ? value : (1 - alpha) * old + alpha * value;
}

// Build candidates + envelope for a target date.
// Uses your existing d0CandidatesFor, d1CandidatesFor, combineSeries, repFromSeries.
function buildCandidatesForDay(targetISO, highTime){
  const c0 = d0CandidatesFor(targetISO, highTime);   // today-for-today (pre-high)
  const c1 = d1CandidatesFor(targetISO);             // yesterday-for-today, or today-for-tomorrow
  const seriesAll = combineSeries(c1.series, c0.series);
  const seriesRep = repFromSeries(seriesAll); // (keep your current rep; easy to swap to time-aware later)
  
  const candidates = {};
  if (c1.latest  != null) candidates.D1_latest  = Number(c1.latest);
  if (c1.trimmed != null) candidates.D1_trimmed = Number(c1.trimmed);
  if (c0.latest  != null) candidates.D0_latest  = Number(c0.latest);
  if (c0.trimmed != null) candidates.D0_trimmed = Number(c0.trimmed);
  if (seriesRep  != null) candidates.series_rep = Number(seriesRep);
  
// Use live AccuWeather API data if available, fall back to CSV
  const todayISO = nycISODate(0);
  const tomorrowISO = nycISODate(1);
  
// Check if accuWeatherData exists and has values
  // Use the actual today/tomorrow dates
  const actualTodayISO = nycISODate(0);
  const actualTomorrowISO = nycISODate(1);
  
if (window.accuWeatherData && targetISO === todayISO && window.accuWeatherData.today != null) {
    candidates.AccuWeather = Number(window.accuWeatherData.today);
    console.log("SET from API for today:", candidates.AccuWeather);
  } else if (window.accuWeatherData && targetISO === tomorrowISO && window.accuWeatherData.tomorrow != null) {
    candidates.AccuWeather = Number(window.accuWeatherData.tomorrow);
    console.log("SET from API for tomorrow:", candidates.AccuWeather);
  } else {
    console.log("FALLING BACK to CSV");
    // Fallback to CSV data - use accuRows which is the global array
const parseTs = (t) => {
      const cleaned = (t || "").replace(" EDT", "").replace(" EST", "").trim();
      return new Date(cleaned);
    };
    
    const accRowsFiltered = accuRows
      .filter(r => r.target_date === targetISO)
      .sort((a, b) => {
        const dateA = parseTs(a.timestamp || a.forecast_time);
        const dateB = parseTs(b.timestamp || b.forecast_time);
        return dateA - dateB;
      });
    
    const accLatest = accRowsFiltered.length ? accRowsFiltered[accRowsFiltered.length - 1] : null;
    candidates.AccuWeather = accLatest ? Number(accLatest.predicted_high) : null;
    console.log("SET from CSV:", candidates.AccuWeather);
  }
  
  console.log("FINAL AccuWeather value after if/else:", candidates.AccuWeather);

  // Inject server-side BCP (seasonal bias-corrected prediction) as a candidate
  const serverBCP = window._bcpFromServer?.[targetISO];
  if (serverBCP) {
    // Prefer same-day BCP; fall back to prev-day (night-before)
    const bcpVal = serverBCP.same_day ?? serverBCP.prev_day;
    if (bcpVal != null) {
      candidates.ServerBCP = Number(bcpVal);
      console.log("Added ServerBCP candidate:", candidates.ServerBCP);
    }
  }

  // envelope + latest issuance (unchanged)
  const vals = [];
  (c1.series||[]).forEach(r=>{ const v=Number(r.predicted_high); if(Number.isFinite(v)) vals.push(v); });
  (c0.series||[]).forEach(r=>{ const v=Number(r.predicted_high); if(Number.isFinite(v)) vals.push(v); });
  const envelope = vals.length ? { lo: Math.min(...vals), hi: Math.max(...vals) } : { lo:null, hi:null };
  const latestIssuanceRow = (seriesAll && seriesAll.length) ? seriesAll[seriesAll.length-1] : null;

  return { candidates, envelope, latestIssuanceRow, c0, c1, seriesAll };
}

// Make a prediction with Hedge (+ stored bias)
async function predictWithHedge(lead, season, candidates, rmseContext){
  const key = contextKey(lead, season);
  console.log("predictWithHedge loading key:", key);
  let st = await loadState(key) || { w:{}, bias:null, rmse:null, lastDay:null };
  
  // Fallback: if this season lacks data, borrow from nearest season with learned bias
    const MIN_SEASONAL_OBS = 10;
    const totalObs = st.learnCounts ? Object.values(st.learnCounts).reduce((sum, count) => sum + count, 0) : 0;

    if (!st.bias || st.bias === 0 || !st.lastDay || totalObs < MIN_SEASONAL_OBS) {
      // Ordered by climatic similarity for each season
      const fallbackOrder = {
        winter: ["fall", "spring", "summer"],
        spring: ["fall", "summer", "winter"],
        summer: ["spring", "fall", "winter"],
        fall:   ["spring", "summer", "winter"],
      };
      const candidates = fallbackOrder[season] || ["summer", "fall", "spring", "winter"];
      for (const alt of candidates) {
        const altKey = contextKey(lead, alt);
        const altSt = await loadState(altKey);
        if (altSt && altSt.bias != null && altSt.bias !== 0) {
          const reason = !st.lastDay ? "no data yet" : `only ${totalObs} days (need ${MIN_SEASONAL_OBS})`;
          console.log(`${season} bias not ready (${reason}), borrowing from ${alt}: ${altSt.bias}`);
          st.bias = altSt.bias;
          st.rmse = altSt.rmse;
          break;
        }
      }
    }
  
  console.log("predictWithHedge loaded state:", st);

  const names = Reflect.ownKeys(candidates).filter(k => typeof k === 'string' && candidates[k] != null);
  if (!names.length) return { y:null, y0:null, bias:0, pad:2, weights:{}, key };

  // init on first use
  if (!Object.keys(st.w).length) {
    const init = 1 / names.length;
    names.forEach(n => st.w[n] = init);
} else {
    // Check for new candidates
    const existingNames = Object.keys(st.w);
    const newNames = names.filter(n => !(n in st.w));
    
if (newNames.length > 0) {
      // Add all new sources with minimal weight
      newNames.forEach(n => st.w[n] = 1e-6);
    }
  }

  // small uniform mix to prevent collapse
  mixWithUniform(st.w, MIX_GAMMA);

  const denom = names.reduce((s,n)=>s + (st.w[n]||0), 0) || 1;
  const y0 = names.reduce((s,n)=>s + (st.w[n]||0) * (candidates[n] || 0), 0) / denom;
  if (!Number.isFinite(y0) || y0 === 0) return { y:null, y0:null, bias:0, pad:2, weights:{...st.w}, key };

  const bias = st.bias ?? 0;
  const y = (y0 == null) ? null : (y0 + bias);

  // clamp pad from stored RMSE or provided context
  // Floor at 0.8 (not 2.0) ‚Äî bias correction makes our effective uncertainty much lower than raw NWS RMSE
  const pad = Math.max(0.8, Number(st.rmse ?? rmseContext ?? 0) || 1.2);

  return { y, y0, bias, pad, weights:{...st.w}, key };
}

// Update Hedge weights + Bias/RMSE when an actual arrives
async function updateHedgeOnActual(kind, season, candidates, actual, targetISO, force = false) {
  if (!CLIENT_LEARNING && !force) return;  // allow forced pretraining
  const key = contextKey(kind, season);
  let st = await loadState(key) || { w:{}, bias:null, rmse:null, lastDay:null, learnCounts:{} };

  // Track how many times each candidate has been trained
  if (!st.learnCounts) st.learnCounts = {};

  const names = Object.keys(candidates);
  if (!names.length || actual == null) return;

 if (st.lastDay && st.lastDay !== targetISO) decayWeights(st.w);
  st.lastDay = targetISO;

  // compute pre-bias ensemble pred for residual
  mixWithUniform(st.w, MIX_GAMMA);
  const denom = names.reduce((s,n)=>s + (st.w[n]||0), 0) || 1;
  const y0 = names.reduce((s,n)=>s + (st.w[n]||0) * candidates[n], 0) / denom;
  const yhat = (st.bias ?? 0) + (y0 ?? 0);

  const err = Number(actual) - Number(yhat);
  const absErr = Math.abs(err);

  // Hedge update with boost for new sources
  for (const n of names){
    const li = Math.abs(Number(candidates[n]) - Number(actual));
    
    // Boost learning rate for sources with < 10 observations
    const count = st.learnCounts[n] || 0;
    const etaBoost = count < 10 ? 2.0 : 1.0; // 2x learning rate for new sources
    
    st.w[n] = (st.w[n] || 0) * Math.exp(-ETA * etaBoost * li);
    st.learnCounts[n] = count + 1;
  }
  softmaxNormalize(st.w);
  mixWithUniform(st.w, MIX_GAMMA);

  // Bias EWMA (clip to ¬±6¬∞F to damp outliers)
  const clipped = Math.max(-6, Math.min(6, err));
  st.bias = ewmaUpdate(st.bias, clipped, BIAS_HALFLIFE_DAYS);

  // RMSE EWMA (for clamp pad)
  const sq = Math.min(36, err*err);
  const oldVar = st.rmse == null ? null : (st.rmse*st.rmse);
  const varNew = ewmaUpdate(oldVar, sq, RMSE_HALFLIFE_DAYS);
  st.rmse = varNew == null ? st.rmse : Math.sqrt(Math.max(0, varNew));

  saveState(key, st);
}
  async function pretrainFromHistory() {
    console.log("=== PRETRAIN DEBUG START ===");
    console.log("Total rows in allRows:", allRows.length);
  // Collect which days have an actual
  const byDay = new Map();
  for (const r of allRows) {
    const day = (r.forecast_or_actual === "actual" ? r.cli_date : r.target_date);
    if (!/^\d{4}-\d{2}-\d{2}$/.test(day || "")) continue;
    if (!byDay.has(day)) byDay.set(day, { actual: null });
    if (r.forecast_or_actual === "actual" && r.actual_high) byDay.get(day).actual = r;
  }

  const todayISO = nycISODate(0);
  
  console.log("Days with actuals:", Array.from(byDay.entries()).filter(([_, v]) => v.actual).length);
  console.log("First 3 days:", Array.from(byDay.entries()).slice(0, 3));

  for (const [iso, { actual }] of byDay.entries()) {
  if (!actual || actual.actual_high == null) continue;

  // Don‚Äôt use today‚Äôs actual unless it‚Äôs truly published
  if (iso === todayISO && !hasActualFor(todayISO)) continue;


    const season  = getSeason(iso);
    const hiTime  = actual.high_time || "";
    const actualF = Number(actual.actual_high);
    console.log("Training row:", iso, "‚Üí", actualF, "season:", season);

    // Train the "today" policy using everything you'd have for that day
    const builtToday = buildCandidatesForDay(iso, hiTime);
    await updateHedgeOnActual("today", season, builtToday.candidates, actualF, iso, true);

    // Train the "tomorrow" policy using only D1 info (what you knew the day before)
    const d1 = d1CandidatesFor(iso);
    const candTomorrow = {};
    if (d1.latest  != null) candTomorrow.D1_latest  = Number(d1.latest);
    if (d1.trimmed != null) candTomorrow.D1_trimmed = Number(d1.trimmed);
    const rep1 = repFromSeries(d1.series);
    if (rep1 != null) candTomorrow.series_rep = Number(rep1);
    // --- AccuWeather (D1 for this iso) ---
    const accD1 = latestPreHighValue(getAccuRowsFor(iso, "D1"), "");
    if (Number.isFinite(accD1)) {
      candTomorrow.AccuWeather = Number(accD1);
    }
await updateHedgeOnActual("tomorrow", season, candTomorrow, actualF, iso, true);
  }
  
  // Check what was learned per season
  for (const s of ["winter","spring","summer","fall"]) {
    const st = await loadState(`today:${s}`);
    if (st?.bias != null) console.log(`After pretrain - today:${s} bias: ${st.bias?.toFixed(3)}, rmse: ${st.rmse?.toFixed(3)}`);
  }
  console.log("=== PRETRAIN DEBUG END ===");
}
window.pretrainFromHistory = pretrainFromHistory;
function resetHedgeState(){
  const keys = [];
  for (let i=0; i<localStorage.length; i++){
    const k = localStorage.key(i);
    if (k && k.startsWith(`${ENS_KEY}:`)) keys.push(k);
  }
  keys.forEach(k => localStorage.removeItem(k));
}

function historySignature(){
  const last = allRows[allRows.length-1] || {};
  return `${allRows.length}|${last.timestamp||last.date_pulled||''}|${last.cli_date||last.target_date||''}`;
}

async function warmOnceForCurrentCSV() {
  // Don't reset - preserve learned biases across reloads
  // resetHedgeState();

// === SEEDS (production deterministic defaults, 4 seasons) ===
// AccuWeather dominant (MAE 1.38 vs NWS 1.71), NWS as sanity check
const SEASONS = ["winter", "spring", "summer", "fall"];

// Bias seeds per season (from historical analysis: winter +1.4, summer +0.26, fall ~+0.7)
const SEASON_SEED_BIAS = { winter: 1.2, spring: 0.5, summer: 0.2, fall: 0.6 };
const SEASON_SEED_RMSE_D0 = { winter: 2.2, spring: 2.0, summer: 1.8, fall: 1.9 };
const SEASON_SEED_RMSE_D1 = { winter: 2.6, spring: 2.4, summer: 2.2, fall: 2.3 };

const seeds = [];
for (const s of SEASONS) {
  seeds.push([`${ENS_KEY}:today:${s}`, {
    w: { D0_latest: 0.03, D0_trimmed: 0.02, series_rep: 0.02, AccuWeather: 0.93 },
    bias: SEASON_SEED_BIAS[s], rmse: SEASON_SEED_RMSE_D0[s], lastDay: null, learnCounts: {}
  }]);
  seeds.push([`${ENS_KEY}:tomorrow:${s}`, {
    w: { D1_latest: 0.03, D1_trimmed: 0.02, series_rep: 0.02, AccuWeather: 0.93 },
    bias: SEASON_SEED_BIAS[s], rmse: SEASON_SEED_RMSE_D1[s], lastDay: null, learnCounts: {}
  }]);
}

for (const [k, v] of seeds) {
  const existing = localStorage.getItem(k);
  if (!existing) {
    localStorage.setItem(k, JSON.stringify(v));
    console.log(`Seeded ${k} with initial values`);
  } else {
    console.log(`Preserving learned state for ${k}`);
  }
 }
}

// optional: expose for debugging
window.resetHedgeState = resetHedgeState;
window.warmOnceForCurrentCSV = warmOnceForCurrentCSV;

    // === Header date (ET) ===
      function showTodayDate() {
        const el = document.getElementById('todayDate');
        if (!el) return;
        const label = new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/New_York',
          weekday: 'short',
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        }).format(new Date());
        el.textContent = label;
      }
      
      function scheduleMidnightUpdate() {
        showTodayDate();                   // set immediately
        setInterval(showTodayDate, 60 * 1000); // refresh once a minute
      }
      
      // expose to the UMD boot block
      window.showTodayDate = showTodayDate;
      window.scheduleMidnightUpdate = scheduleMidnightUpdate;


    function nycISODate(offsetDays = 0) {
      const fmt = new Intl.DateTimeFormat('en-CA', {
        timeZone: 'America/New_York', year: 'numeric', month: '2-digit', day: '2-digit'
      });
      const parts = fmt.formatToParts(new Date(Date.now() + offsetDays * 86400000));
      const g = k => parts.find(p => p.type === k).value;
      return `${g('year')}-${g('month')}-${g('day')}`;
    }
  window.nycISODate = nycISODate;  // Make it globally accessible
  // Reset any stale overnight state when the date changes
(function resetOvernightForToday(){
  try {
    const today = nycISODate(0);
    if (window._overnightDate !== today) {
      window._overnightHighSoFar = undefined;
      window._overnightHighTime  = null;
      window._overnightExceeded  = null;
      window._overnightDate      = today;
    }
  } catch {}
})();
  
  // Restore overnight high saved during 12‚Äì7 ET so UI can show the note after 7 ET
  (function restoreOvernightFromStorage(){
    try {
      const key = `overnight_${nycISODate(0)}`;
      const saved = JSON.parse(localStorage.getItem(key) || 'null');
      if (saved && Number.isFinite(Number(saved.high))) {
        window._overnightHighSoFar = Number(saved.high);
        window._overnightHighTime  = saved.time || null;
        console.log(`[Overnight tracker] ‚ôªÔ∏è restored ${window._overnightHighSoFar}¬∞F`);
      }
    } catch {}
  })();


    
    function kalshiAnchorForISO(dateISO) {
      const [y,m,d] = dateISO.split('-').map(Number);
      const dt = new Date(Date.UTC(y, m-1, d));
      const mon = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'][dt.getUTCMonth()];
      const dd = String(dt.getUTCDate()).padStart(2,'0');
      const yy = String(dt.getUTCFullYear()).slice(-2);
      return `/kxhighny-${yy}${mon}${dd}`;
    }

    function showSkeleton(rows = 6) {
      const tb = document.querySelector("#dataTable tbody");
      if (!tb) return;
      tb.innerHTML = "";
      for (let i = 0; i < rows; i++) {
        const tr = document.createElement("tr");
        tr.className = "skel";
        tr.innerHTML = "<td></td>".repeat(9);
        tb.appendChild(tr);
      }
    }

   // Global holder for AccuWeather rows
accuRows = [];

// Global holder for server-side BCP values from forecast_day_summary
// Keyed by ISO date ‚Üí { prev_day: number, same_day: number }
window._bcpFromServer = {};

// Global holder for ML predictions from ml_predictions.json
window._mlPredictions = null;

async function loadMLPredictions() {
  try {
    const r = await fetch('/ml_predictions.json', { cache: 'no-store' });
    if (!r.ok) return;
    const data = await r.json();
    // Staleness check: if > 6 hours old, mark as stale (reduced weight in confidence)
    const genAt = new Date(data.generated_at);
    const ageMs = Date.now() - genAt.getTime();
    if (ageMs > 6 * 3600 * 1000) {
      console.warn('ML predictions stale, age:', Math.round(ageMs / 3600000), 'hours');
      data._stale = true;
    }
    window._mlPredictions = data;
    console.log('Loaded ML predictions:', Object.keys(data.predictions || {}).length, 'days');
  } catch (e) {
    console.debug('loadMLPredictions failed:', e);
  }
}

async function loadServerBCP() {
  try {
    const { data, error } = await supabase
      .from("forecast_day_summary")
      .select("target_date, prev_day_latest_value, same_day_earliest_value");
    if (error || !Array.isArray(data)) return;
    const m = {};
    for (const row of data) {
      const td = String(row.target_date || "").match(/\d{4}-\d{2}-\d{2}/)?.[0];
      if (!td) continue;
      const pd = Number(row.prev_day_latest_value);
      const sd = Number(row.same_day_earliest_value);
      m[td] = {
        prev_day: Number.isFinite(pd) ? pd : null,
        same_day: Number.isFinite(sd) ? sd : null,
      };
    }
    window._bcpFromServer = m;
    console.log(`Loaded server BCP for ${Object.keys(m).length} days`);
  } catch (e) {
    console.debug("loadServerBCP failed:", e);
  }
}

function reloadCSV(opts = {}) {
  const skipUI = !!opts.skipUI;
  showSkeleton();

  // Fetch NWS + AccuWeather concurrently
  return Promise.all([
    fetch(CSV_URL, { cache: "no-store" }).then(r => r.text()),
  fetch(ACCU_URL, { cache: "no-store" }).then(r => r.text()).catch(() => "")
  ])
  .then(async ([nwsText, accuText]) => {
    // Parse NWS (UI + ensemble base)
    parseCSV(nwsText);

    // Parse AccuWeather separately
    accuRows = [];
    if (accuText && accuText.trim()) {
      const rows = csvToRows(accuText);
      const header = rows[0].map(h => h.trim());
      for (let i = 1; i < rows.length; i++) {
        const vals = rows[i];
        const rec = {};
        for (let j = 0; j < header.length; j++) {
          let v = (vals[j] ?? "").trim();
          if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1).replace(/""/g, '"');
          rec[header[j]] = v;
        }
        accuRows.push(rec);
      }
    }

    // Load server-side BCP values so they can be used as Hedge candidates
    if (typeof loadServerBCP === "function") {
      try { await loadServerBCP(); } catch (e) { console.warn("loadServerBCP failed:", e); }
    }
    // Load ML predictions (static JSON from GitHub Actions)
    if (typeof loadMLPredictions === "function") {
      try { await loadMLPredictions(); } catch (e) { console.warn("loadMLPredictions failed:", e); }
    }

    // Reset + pretrain the learner from the CSVs we just loaded (NWS history + AccuWeather)
    if (typeof warmOnceForCurrentCSV === "function") {
      try { warmOnceForCurrentCSV(); } catch (e) { console.warn("warmOnceForCurrentCSV failed:", e); }
    }
    if (typeof pretrainFromHistory === "function") {
      try { await pretrainFromHistory(); } catch (e) { console.warn("pretrainFromHistory failed:", e); }
    }

    // Continue normal boot
    seedForecastSignatures();
    lastActualSig = actualSignatureFor(allRows);
    forecastChanged.today = false;
    forecastChanged.tomorrow = false;

    if (!skipUI) {
      resetFilter();
      showMostRecent();
      updateSummaryBoxes();
      updateCorrectionBoxes();   // now uses CSV-trained weights/bias
      updateObservations();
    }

  })
  .catch(err => {
    alert("Could not load CSVs. " + err);
    throw err;
  });
}

    function csvToRows(text) {
      const rows = [];
      let row = [], field = '', q = false;
      for (let i = 0; i < text.length; i++) {
        const c = text[i], n = text[i + 1];
        if (c === '"') {
          if (q && n === '"') { field += '"'; i++; } else q = !q;
        } else if (c === ',' && !q) {
          row.push(field); field = '';
        } else if ((c === '\n' || c === '\r') && !q) {
          if (c === '\r' && n === '\n') i++;
          row.push(field); field = '';
          if (row.length && row.some(x => x !== '')) rows.push(row);
          row = [];
        } else field += c;
      }
      if (field !== '' || row.length) {
        row.push(field);
        if (row.length && row.some(x => x !== '')) rows.push(row);
      }
      return rows;
    }

    function parseCSV(text) {
      const rows = csvToRows(text);
      if (!rows.length) return;
      const header = rows[0].map(h => h.trim());
      allRows = [];
      for (let i = 1; i < rows.length; i++) {
        const vals = rows[i];
        const rec = {};
        for (let j = 0; j < header.length; j++) {
          let v = (vals[j] ?? '').trim();
          if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1).replace(/""/g, '"');
          rec[header[j]] = v;
        }
        allRows.push(rec);
      }
    }

    function rNum(x){ const n=Number(x); return Number.isFinite(n)? n : null; }

    function toDateObj(t) {
      if (!t) return null;
      const clean = String(t).trim().replace(/:(\d{2})(?=\s*[AP]M)/i, '');
      if (/[AP]M/i.test(clean)) {
        const m = clean.match(/(\d{1,2}):(\d{2})\s*([AP]M)/i);
        if (!m) return null;
        const [, h, mn, amp] = m;
        const hour = (Number(h) % 12) + (amp.toUpperCase() === "PM" ? 12 : 0);
        return new Date(2020, 1, 1, hour, Number(mn));
      }
      if (/^\d{2}:\d{2}$/.test(clean)) {
        const [h, mn] = clean.split(":");
        return new Date(2020, 1, 1, Number(h), Number(mn));
      }
      return null;
    }
    function compareTimes(t1, t2) { const d1=toDateObj(t1), d2=toDateObj(t2); return (d1&&d2)? d1-d2 : 0; }

    // ===== ET date helpers =====
    function etDateISOFromTS(ts) {
      const s = (ts || "").replace(" ", "T"); const d = new Date(s);
      if (!Number.isFinite(d.getTime())) return "";
      return new Intl.DateTimeFormat("en-CA", { timeZone: "America/New_York", year:"numeric", month:"2-digit", day:"2-digit" }).format(d);
    }
    function prevISO(iso) {
      if (!iso || typeof iso !== "string" || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) {
        console.warn("prevISO: bad input", iso);
        return null;
      }
      const d = new Date(iso + "T00:00:00");
      if (isNaN(d)) return null;
      d.setHours(12,0,0,0);      // normalize to noon to avoid DST shifts
      d.setDate(d.getDate() - 1);
      return d.toISOString().slice(0,10);
    }

    function monthNum(iso){ return Number((iso||"").split("-")[1]||"0"); }
    function isWarmSeason(iso){ const m=monthNum(iso); return m>=5 && m<=9; }
    function getSeason(iso){
      const m = monthNum(iso);
      if (m >= 6 && m <= 8) return "summer";
      if (m >= 9 && m <= 11) return "fall";
      if (m >= 3 && m <= 5) return "spring";
      return "winter"; // Dec, Jan, Feb
    }

    // ===== Lead kind =====
    function leadKind(row){
      if (!row || !row.target_date) return "other";
      const issueISO = etDateISOFromTS(row.timestamp || row.forecast_time || "");
      if (!issueISO) return "other";
      if (issueISO === row.target_date) return "D0";
      if (issueISO === prevISO(row.target_date)) return "D1";
      return "other";
    }

  // ===== Row selectors =====
  function getForecastRowsFor(targetISO, kind, source){
    const rows = (String(source||"") === "AccuWeather") ? accuRows : allRows;
    const dayPrev = prevISO(targetISO);
    return rows.filter(r => {
      if ((r.forecast_or_actual||"") !== "forecast") return false;
      if ((r.target_date||"") !== targetISO) return false;
  
      // optional strict source filter (for NWS vs Accu explicit calls)
      if (source && String(r.source||"").trim() !== String(source).trim()) return false;
  
      const issueISO = etDateISOFromTS(r.timestamp || r.forecast_time || "");
      if (kind === "D0") return issueISO === targetISO;
      if (kind === "D1") return issueISO === dayPrev;
      return false;
    });
  }

  // Accu-only (hidden from UI)
  function getAccuRowsFor(targetISO, kind){
    const dayPrev = prevISO(targetISO);
    return accuRows.filter(r=>{
      if ((r.forecast_or_actual||"") !== "forecast") return false;
      if ((r.target_date||"") !== targetISO) return false;
      const issueISO = etDateISOFromTS(r.timestamp || r.forecast_time || "");
      if (kind === "D0") return issueISO === targetISO;
      if (kind === "D1") return issueISO === dayPrev;
      return false;
    });
  }

    // Keep trend; collapse only consecutive duplicates by value
   function collapseConsecutiveDuplicates(sortedRows){
        const out = [];
        let lastBin = null;
        for (const r of sortedRows){
          const v = Number(r.predicted_high);
          if (!Number.isFinite(v)) continue;
          const bin = quantize05(v);  // bucket by 0.5¬∞F
          if (lastBin === null || bin !== lastBin){
            out.push(r);
            lastBin = bin;
          }
        }
        return out;
      }


    // Representative issuance rows/values
    function latestPreHighRow(rows, highTime/* "" allowed */){
      const pre = rows
        .filter(r => r.predicted_high != null && r.predicted_high !== "")
        .filter(r => {
          if (!highTime) return true;
          const fcHH = (r.forecast_time || "").substr(11,5);
          return !(fcHH && compareTimes(fcHH, highTime) > 0);
        })
        .sort((a,b)=>((a.timestamp||a.forecast_time||"")).localeCompare(b.timestamp||b.forecast_time||""));
      if (!pre.length) return null;
      const dedup = collapseConsecutiveDuplicates(pre);
      return dedup[dedup.length-1] || null;
    }
    function latestPreHighValue(rows, highTime){ const row=latestPreHighRow(rows, highTime); const v=Number(row?.predicted_high); return Number.isFinite(v)?v:null; }

    // Robust stats
    function winsorize(arr,p=0.10){ if(!arr.length) return arr.slice(); const s=arr.slice().sort((a,b)=>a-b);
      const loIdx = Math.floor(p*(s.length-1)), hiIdx = Math.ceil((1-p)*(s.length-1));
      const lo=s[loIdx], hi=s[hiIdx]; return s.map(x=>Math.max(lo, Math.min(hi,x)));
    }
    function median(a){ if(!a.length) return null; const s=a.slice().sort((x,y)=>x-y); const m=Math.floor(s.length/2); return s.length%2? s[m] : (s[m-1]+s[m])/2; }
    function mean(a){ return a.length? a.reduce((x,y)=>x+y,0)/a.length : null; }
    function robustMean(arr){ if(arr.length>=15) return mean(winsorize(arr,0.10)); if(arr.length>=7){ const m=median(arr); return m==null? mean(arr):m; } return mean(arr); }

    // ===== Candidate builders =====
  function d0CandidatesFor(dayISO, highTime) {
    const d0 = getForecastRowsFor(dayISO, "D0").filter(r => r.predicted_high != null && r.predicted_high !== "");
    const sorted = d0
      .filter(r => {
        if (!highTime) return true;
        const fcHH = (r.forecast_time || "").substr(11,5);
        return !(fcHH && compareTimes(fcHH, highTime) > 0);
      })
      .sort((a,b)=>((a.timestamp||a.forecast_time||"")).localeCompare(b.timestamp||b.forecast_time||""));
  
    // chronological series with 0.5¬∞F step de-noise
    const series = collapseConsecutiveDuplicates(sorted);
  
    const first   = series.length ? Number(series[0].predicted_high) : null;
    const latest  = series.length ? Number(series[series.length-1].predicted_high) : null;
    const trimmed = (() => {
      const vals = series.map(r=>Number(r.predicted_high)).filter(Number.isFinite).sort((a,b)=>a-b);
      if (!vals.length) return null;
      const k = Math.max(1, Math.floor(vals.length*0.1));
      const core = vals.slice(k, vals.length-k);
      const arr = core.length ? core : vals;
      return mean(arr);
    })();
 
    // carry-over D1 (yesterday's issuance for this target) ‚Äî NWS only
   const d1Carry = latestPreHighValue(getForecastRowsFor(dayISO, "D1"), ""); 
    return { first, latest, trimmed, carry: d1Carry, series, _hasD0: series.length>0 };
  }

   function d1CandidatesFor(tomorrowISO) {
     const d1 = getForecastRowsFor(tomorrowISO, "D1").filter(r => r.predicted_high != null && r.predicted_high !== "");
      const series = collapseConsecutiveDuplicates(
        d1.sort((a,b)=>((a.timestamp||a.forecast_time||"")).localeCompare(b.timestamp||b.forecast_time||""))
      );
    
      const first   = series.length ? Number(series[0].predicted_high) : null;
      const latest  = series.length ? Number(series[series.length-1].predicted_high) : null;
      const trimmed = (() => {
        const vals = series.map(r=>Number(r.predicted_high)).filter(Number.isFinite).sort((a,b)=>a-b);
        if (!vals.length) return null;
        const k = Math.max(1, Math.floor(vals.length*0.1));
        const core = vals.slice(k, vals.length-k);
        const arr = core.length ? core : vals;
        return mean(arr);
      })();
    
      return { first, latest, trimmed, series };
    }

    // ===== Learn per-bucket blend + bias =====
function buildBiasAndBlend() {
  // ---- Gather per-day data ----
  const dayMap = new Map();
  for (const r of allRows) {
    const d = (r.forecast_or_actual === "actual" ? r.cli_date : r.target_date);
    if (!d) continue;
    if (!dayMap.has(d)) dayMap.set(d, { D0:[], D1:[], actual:null });
    const bucket = dayMap.get(d);
    if (r.forecast_or_actual === "forecast") {
      const k = leadKind(r);
      if (k === "D0") bucket.D0.push(r);
      else if (k === "D1") bucket.D1.push(r);
    } else if (r.actual_high) {
      bucket.actual = r;
    }
  }

  const todayISO = nycISODate(0);

  // ---- Build examples (candidates + series) ----
  const examples = [];
  for (const [iso, {D0, D1, actual}] of dayMap.entries()) {
    if (!actual || !actual.actual_high) continue;
    const act = Number(actual.actual_high);
    const highTime = actual.high_time || "";
    const season = isWarmSeason(iso) ? "warm" : "cool";

    // D0 entry (same-day issuances)
    const c0 = d0CandidatesFor(iso, highTime);
    if (c0._hasD0) {
      examples.push({
        iso, season, lead: "D0", actual: act,
        cand: { first:c0.first, latest:c0.latest, trimmed:c0.trimmed, carry:c0.carry },
        series: c0.series
      });
    }

    // D1 entry (yesterday's issuances for this target)
    const c1 = d1CandidatesFor(iso);
    if (c1.first!=null || c1.latest!=null || c1.trimmed!=null) {
      examples.push({
        iso, season, lead: "D1", actual: act,
        cand: { first:c1.first, latest:c1.latest, trimmed:c1.trimmed },
        series: c1.series
      });
    }
  }

  // ---- Learn blend weights (per lead+season) ----
  function learnWeights(rows, allowCarry) {
    if (!rows.length) return { w:{first:0, latest:1, trimmed:0, carry:0}, mae:Infinity };
    let best = { w:null, mae:Infinity };
    const step = 0.1;
    for (let f=0; f<=1; f+=step) {
      for (let l=0; l<=1-f; l+=step) {
        for (let t=0; t<=1-f-l; t+=step) {
          const c = allowCarry ? (1 - f - l - t) : 0;
          if (!allowCarry && Math.abs(1 - f - l - t) > 1e-9) continue;
          const w = { first:f, latest:l, trimmed:t, carry:c };

          // MAE vs actual using this blend
          let absSum=0, n=0;
          for (const r of rows) {
            const parts=[];
            if (r.cand.first   != null) parts.push({v:r.cand.first,   w:w.first});
            if (r.cand.latest  != null) parts.push({v:r.cand.latest,  w:w.latest});
            if (r.cand.trimmed != null) parts.push({v:r.cand.trimmed, w:w.trimmed});
            if (allowCarry && r.cand.carry != null) parts.push({v:r.cand.carry, w:w.carry});
            if (!parts.length) continue;
            const sumW = parts.reduce((a,b)=>a+b.w,0) || 1;
            const rep  = parts.reduce((a,b)=>a + b.v * (b.w/sumW), 0);
            absSum += Math.abs(r.actual - rep);
            n++;
          }
          if (!n) continue;
          const mae = absSum / n;
          if (mae < best.mae) best = { w, mae };
        }
      }
    }
    if (!best.w) best = { w:{first:0,latest:1,trimmed:0,carry:0}, mae:Infinity };
    return best;
  }

  const D0_warm = learnWeights(examples.filter(e=>e.lead==="D0" && e.season==="warm"), true);
  const D0_cool = learnWeights(examples.filter(e=>e.lead==="D0" && e.season==="cool"), true);
  const D1_warm = learnWeights(examples.filter(e=>e.lead==="D1" && e.season==="warm"), false);
  const D1_cool = learnWeights(examples.filter(e=>e.lead==="D1" && e.season==="cool"), false);

  const weights = {
    D0_warm: D0_warm.w, D0_cool: D0_cool.w,
    D1_warm: D1_warm.w, D1_cool: D1_cool.w
  };

  // ---- Compute residuals for series & blend (rolling window, recency-weighted) ----
  const res = {
    series: { D0:{warm:[], cool:[]}, D1:{warm:[], cool:[]} },
    blend:  { D0:{warm:[], cool:[]}, D1:{warm:[], cool:[]} }
  };

  for (const e of examples) {
    const age = Math.max(0, daysBetween(e.iso, todayISO));
    if (age > BIAS_WINDOW_DAYS) continue; // rolling window
    const decay = Math.pow(2, -age/DECAY_HALF_LIFE);

    // series representative (EMA of deduped series)
    const repSeries = repFromSeries(e.series);
    if (repSeries != null) {
      const r = clamp(e.actual - repSeries, -RESIDUAL_CLAMP, RESIDUAL_CLAMP);
      res.series[e.lead][e.season].push({ r, w:decay });
    }

    // blend representative (using learned weights)
    const key = `${e.lead}_${e.season}`;
    const w   = weights[key] || { first:0, latest:1, trimmed:0, carry:0 };
    const parts=[];
    if (e.cand.first   != null) parts.push({v:e.cand.first,   w:w.first});
    if (e.cand.latest  != null) parts.push({v:e.cand.latest,  w:w.latest});
    if (e.cand.trimmed != null) parts.push({v:e.cand.trimmed, w:w.trimmed});
    if (e.lead==="D0" && e.cand.carry != null) parts.push({v:e.cand.carry, w:w.carry});
    if (parts.length){
      const sumW = parts.reduce((a,b)=>a+b.w,0) || 1;
      const rep  = parts.reduce((a,b)=>a + b.v * (b.w/sumW), 0);
      const r    = clamp(e.actual - rep, -RESIDUAL_CLAMP, RESIDUAL_CLAMP);
      res.blend[e.lead][e.season].push({ r, w:decay });
    }
  }

  function weightedMeanResidual(arr){
    if (!arr.length) return null;
    return wmean(arr.map(x=>x.r), arr.map(x=>x.w));
  }
  function weightedRMSE(arr){
    if (!arr.length) return null;
    const xs = arr.map(x=>x.r*x.r), ws = arr.map(x=>x.w);
    const m = wmean(xs, ws);
    return m==null ? null : Math.sqrt(m);
  }

  const bias = {
    D0: {
      warm: { series: weightedMeanResidual(res.series.D0.warm), blend: weightedMeanResidual(res.blend.D0.warm) },
      cool: { series: weightedMeanResidual(res.series.D0.cool), blend: weightedMeanResidual(res.blend.D0.cool) }
    },
    D1: {
      warm: { series: weightedMeanResidual(res.series.D1.warm), blend: weightedMeanResidual(res.blend.D1.warm) },
      cool: { series: weightedMeanResidual(res.series.D1.cool), blend: weightedMeanResidual(res.blend.D1.cool) }
    },
    global: {
      warm: {
        series: weightedMeanResidual([...res.series.D0.warm, ...res.series.D1.warm]),
        blend:  weightedMeanResidual([...res.blend.D0.warm,  ...res.blend.D1.warm])
      },
      cool: {
        series: weightedMeanResidual([...res.series.D0.cool, ...res.series.D1.cool]),
        blend:  weightedMeanResidual([...res.blend.D0.cool,  ...res.blend.D1.cool])
      },
      all: weightedMeanResidual([
        ...res.series.D0.warm, ...res.series.D1.warm,
        ...res.series.D0.cool, ...res.series.D1.cool
      ]) ?? 0
    }
  };

  const rmse = {
    D0: {
      warm: { series: weightedRMSE(res.series.D0.warm), blend: weightedRMSE(res.blend.D0.warm) },
      cool: { series: weightedRMSE(res.series.D0.cool), blend: weightedRMSE(res.blend.D0.cool) }
    },
    D1: {
      warm: { series: weightedRMSE(res.series.D1.warm), blend: weightedRMSE(res.blend.D1.warm) },
      cool: { series: weightedRMSE(res.series.D1.cool), blend: weightedRMSE(res.blend.D1.cool) }
    }
  };

  return { weights, bias, rmse };
}

    // Pick bias (lead-level with safe fallback)
  function pickBiasFrom(tables, lead, season, usedSeries){
  const method = usedSeries ? "series" : "blend";
  const s = (season === "warm" || season === "cool") ? season : "warm";
  const byLead = tables?.bias?.[lead]?.[s]?.[method];
  if (Number.isFinite(byLead)) return byLead;
  const bySeason = tables?.bias?.global?.[s]?.[method];
  if (Number.isFinite(bySeason)) return bySeason;
  return tables?.bias?.global?.all ?? 0;
}

    // Blend helper
    function blendedRep(cands, weights, allowCarry) {
      const parts = [];
      if (cands.first   != null) parts.push({v:cands.first,   w:weights.first ?? 0});
      if (cands.latest  != null) parts.push({v:cands.latest,  w:weights.latest ?? 0});
      if (cands.trimmed != null) parts.push({v:cands.trimmed, w:weights.trimmed ?? 0});
      if (allowCarry && cands.carry != null) parts.push({v:cands.carry, w:weights.carry ?? 0});
      if (!parts.length) return null;
      const sumW = parts.reduce((a,b)=>a+b.w,0);
      if (sumW <= 1e-9) return cands.latest ?? cands.first ?? cands.trimmed ?? cands.carry ?? null;
      return parts.reduce((a,b)=>a + b.v * (b.w/sumW), 0);
    }

          // === Exact formula explainer (normalized to the parts that exist) ===
      function blendExplainer(cands, weights, allowCarry) {
        const present = [];
        if (cands.first   != null)  present.push({label:"first",   v:Number(cands.first),   w:weights.first ?? 0});
        if (cands.latest  != null)  present.push({label:"latest",  v:Number(cands.latest),  w:weights.latest ?? 0});
        if (cands.trimmed != null)  present.push({label:"trimmed", v:Number(cands.trimmed), w:weights.trimmed ?? 0});
        if (allowCarry && cands.carry != null) present.push({label:"carry", v:Number(cands.carry), w:weights.carry ?? 0});
      
        const sumW = present.reduce((a,p)=>a+p.w,0);
        const used = sumW > 1e-9
          ? present.map(p => ({...p, wn: p.w/sumW}))
          : present.map(p => ({...p, wn: (p.label==="latest") ? 1 : 0})); // mirrors blendedRep fallback
      
        const partsTxt = used
          .filter(p => p.wn > 0)
          .map(p => `${p.wn.toFixed(2)}√ó${p.label} ${p.v.toFixed(1)}¬∞F`)
          .join(" + ");
      
        return { partsTxt };
      }
// === Subtitle explainer: prefer series rep if used, else show normalized blend ===
function explainPred({ usedSeries, series, bias, partsTxt, nudge = null }) {
  const b = (bias == null) ? "0.0" : Number(bias).toFixed(1);

  if (usedSeries) {
    const n = Array.isArray(series) ? series.length : 0;
    const core = `pred = series_rep (n=${n}, newest-weighted) + ${b}`;
    if (nudge != null && Number.isFinite(nudge) && Math.abs(nudge) > 0) {
      return `${core} + nudge ${Number(nudge).toFixed(1)}`;
    }
    return core;
  }

  // fallback: normalized blend parts (only if any non-zero weight components exist)
  return partsTxt ? `pred = (${partsTxt}) + ${b}` : `pred = ‚Äî + ${b}`;
}

    // === Series helpers (0.5¬∞F de-noise + recency rep) =========================
function quantize05(x){
  const n = Number(x);
  if (!Number.isFinite(n)) return null;
  return Math.round(n * 2) / 2; // nearest 0.5¬∞F
}

// rowsChrono: chronological rows (oldest ‚Üí newest), each has predicted_high
// alpha=0.85 weights newest more (w, w*alpha, w*alpha^2, ... from newest back)
function repFromSeries(rowsChrono, alpha = 0.85){
  if (!rowsChrono || !rowsChrono.length) return null;
  let vsum = 0, wsum = 0, w = 1;               // start from newest
  for (let i = rowsChrono.length - 1; i >= 0; i--) {
    const v = Number(rowsChrono[i].predicted_high);
    if (!Number.isFinite(v)) continue;
    vsum += w * v;
    wsum += w;
    w *= alpha;
  }
  return wsum > 0 ? (vsum / wsum) : null;
}
function combineSeries(seriesD1, seriesD0){
  const A = Array.isArray(seriesD1) ? seriesD1 : [];
  const B = Array.isArray(seriesD0) ? seriesD0 : [];
  const merged = [...A, ...B].sort((x,y)=>
    ((x.timestamp||x.forecast_time||"").localeCompare(y.timestamp||y.forecast_time||""))
  );
  return collapseConsecutiveDuplicates(merged);
}

// === Calibration config (rolling/recency-weighted biases) ===
const BIAS_WINDOW_DAYS   = 75;   // only last ~2.5 months
const DECAY_HALF_LIFE    = 30;   // days; recency weighting for biases
const RESIDUAL_CLAMP     = 6;    // ¬∞F; soft outlier guard

function daysBetween(iso1, iso2){
  if(!iso1 || !iso2) return 0;
  const d1=new Date(iso1+"T00:00:00"), d2=new Date(iso2+"T00:00:00");
  return Math.round((d2-d1)/86400000);
}
function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }
function wmean(xs, ws){
  let num=0, den=0;
  for (let i=0;i<xs.length;i++){
    const x=xs[i], w=ws[i] ?? 1;
    if (!Number.isFinite(x) || w<=0) continue;
    num += x*w; den += w;
  }
  return den>0 ? num/den : null;
}

    // ===== Feature helpers for logging =====
    function issuanceISOUTC(row){
      const src = (row?.timestamp || row?.forecast_time || "").replace(" ", "T");
      const d = new Date(src);
      if (!Number.isFinite(d.getTime())) return null;
      return d.toISOString().slice(0,19) + "Z"; // canonical UTC
    }
    function issuanceHourET(row){
      const s = (row?.timestamp || row?.forecast_time || "").replace(" ", "T"); const d=new Date(s);
      if (!Number.isFinite(d.getTime())) return null;
      const hh = new Intl.DateTimeFormat("en-CA",{timeZone:"America/New_York",hour:"2-digit",hour12:false}).format(d);
      return Number(hh);
    }
    function rowSig(r){ return `${r.timestamp || r.forecast_time || ""}|${r.predicted_high}`; }

    function deltaLast3(rows, repRow, highTime){
      const sorted = rows
        .filter(r => r.predicted_high != null && r.predicted_high !== "")
        .filter(r => {
          if (!highTime) return true;
          const fcHH = (r.forecast_time || r.timestamp || "").substr(11,5);
          return !(fcHH && compareTimes(fcHH, highTime) > 0);
        })
        .sort((a,b)=>((a.timestamp||a.forecast_time||"")).localeCompare(b.timestamp||b.forecast_time||""));

      const dedup = collapseConsecutiveDuplicates(sorted);
      if (!repRow || !dedup.length) return 0;

      const repS = rowSig(repRow);
      let idx = dedup.findIndex(x => rowSig(x) === repS);
      if (idx < 0) idx = dedup.length - 1;

      const prevs = dedup.slice(Math.max(0, idx - 2), idx)
        .map(r => Number(r.predicted_high))
        .filter(Number.isFinite);

      if (!prevs.length) return 0;
      const medPrev = median(prevs);
      const rep = Number(repRow.predicted_high);
      return (Number.isFinite(rep) && medPrev != null) ? (rep - medPrev) : 0;
    }

    // === Client idempotency helpers (avoid logging the same prediction repeatedly) ===
    function stableRound(x, d=1){
      const n = Number(x);
      if (!Number.isFinite(n)) return null;
      const p = Math.pow(10, d);
      return Math.round(n * p) / p;
    }
    function round1(x){ const n = Number(x); return Number.isFinite(n) ? Math.round(n*10)/10 : null; }

    function buildPredSignature({
      target_date, lead_used, issuance_iso,
      rep_forecast, bias_applied, prediction_value,
      model_name, version
    }) {
      const rep = stableRound(rep_forecast, 1);
      const bias = stableRound(bias_applied, 2);
      const pred = stableRound(prediction_value, 1);
      return [
        target_date || '',
        lead_used || '',
        issuance_iso || '',
        rep ?? '',
        bias ?? '',
        pred ?? '',
        model_name || '',
        version || ''
      ].join('|');
    }

    // remembers the last forecast_signature we actually logged
    const loggedSig = {
      today:    localStorage.getItem("loggedSig_today")    || null,
      tomorrow: localStorage.getItem("loggedSig_tomorrow") || null,
    };
    function setLoggedSig(which, sig) {
      loggedSig[which] = sig;
      try { localStorage.setItem(`loggedSig_${which}`, sig); } catch {}
    }
    
    // ===== Prediction logging toggle + helpers =====
    // Fail-open: if the probe endpoint flakes, still attempt POST logging.
    // Only disable if the endpoint is truly missing (404).
    let PREDICTION_LOGGING_ENABLED = true;
    
    async function probeLoggingEndpoint() {
      try {
        const r = await fetch(`${API_BASE}/log-prediction`, { method: "OPTIONS" });
        PREDICTION_LOGGING_ENABLED = (r.status === 404) ? false : true;
      } catch {
        PREDICTION_LOGGING_ENABLED = true;
      }
    }
     async function logPrediction(payload){
      if (!PREDICTION_LOGGING_ENABLED) return;
      try{
        const r = await fetch(`${API_BASE}/log-prediction`, {
          method:"POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify(payload)
        });
        if (!r.ok) {
          let j = null; try { j = await r.json(); } catch {}
          const dup = r.status === 409 || (j && (j.code === '23505' || /duplicate key/i.test(j.message||"")));
          if (dup) return;                   // silently ignore duplicates
          if (r.status === 404) PREDICTION_LOGGING_ENABLED = false; // endpoint missing: stop trying
          console.debug("/api/log-prediction error", r.status, j?.message || r.statusText);
        }
      } catch(_) { /* quiet */ }
    }

    // ---- Friendly ET date display helpers ----
    function safeParseTimestamp(ts) {
      const s = (ts || "").trim();
      if (!s) return null;
      const isoish = s.includes("T") ? s : s.replace(" ", "T");
      const d = new Date(isoish);
      return Number.isFinite(d.getTime()) ? d : null;
    }
    function fmtMonthDayET(d) {
      return new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        month: "short",
        day: "numeric"
      }).format(d);
    }
    function fmtTimeET(d) {
      return new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        hour: "numeric",
        minute: "2-digit"
      }).format(d);
    }
    function monthDayFromISO(iso) {
      if (!/^\d{4}-\d{2}-\d{2}$/.test(iso || "")) return "";
      return fmtMonthDayET(new Date(iso + "T00:00:00"));
    }
    function hhmmFromTS(s) {
      const m = String(s || "").match(/\b(\d{1,2}:\d{2})\b/);
      return m ? m[1] : "";
    }
    function showMostRecent() {
      const el = document.getElementById("recentForecast");
      if (!el) return;
      if (!allRows.length) { el.textContent = ""; return; }

      for (let i = allRows.length - 1; i >= 0; i--) {
        const r = allRows[i];
        if (r && r.forecast_or_actual === "forecast" && r.predicted_high && r.target_date) {
          const d =
            safeParseTimestamp(r.timestamp) ||
            safeParseTimestamp(r.forecast_time);

          const dateLabel = d
            ? fmtMonthDayET(d)
            : monthDayFromISO((r.timestamp || r.forecast_time || "").slice(0, 10)) ||
              monthDayFromISO(nycISODate(0));

          const timeLabel = d
            ? fmtTimeET(d)
            : hhmmFromTS(r.timestamp || r.forecast_time) || "";

          const whenLabel = timeLabel ? `${dateLabel} at ${timeLabel} ET` : `${dateLabel}`;

          el.innerHTML =
            `<strong>${whenLabel}</strong> ‚Äî ` +
            `<strong>${r.predicted_high}¬∞F</strong> for <strong>${r.target_date}</strong>`;
          return;
        }
      }
      el.textContent = "";
    }

    function getForecastsForDate(dateISO) {
      const rows = allRows
        .filter(r => r.forecast_or_actual === "forecast" && r.target_date === dateISO && r.predicted_high)
        .map(r => ({
          tstamp: r.timestamp || r.forecast_time || "",
          timeHHMM: (r.forecast_time || "").substr(11, 5),
          val: Number(r.predicted_high)
        }))
        .filter(x => Number.isFinite(x.val));
      rows.sort((a, b) => (a.tstamp || "").localeCompare(b.tstamp || ""));
      return rows;
    }

    function renderMiniForecastChips(rows, elId) {
      const host = document.getElementById(elId);
      if (!host) return;
      host.innerHTML = "";
      const compact = [];
      rows.forEach((r, i) => {
        if (i === 0 || r.val !== rows[i - 1].val) compact.push(r);
      });
      if (!compact.length) {
        host.innerHTML = `<span class="mini-chip">No forecasts yet</span>`;
        return;
      }
      compact.forEach(r => {
        const label = `${r.timeHHMM || "‚Äî"}, ${r.val.toFixed(0)}¬∞`;
        const chip = document.createElement("span");
        chip.className = "mini-chip";
        chip.textContent = label;
        host.appendChild(chip);
      });
    }

    // ---- Forecast change watcher (GLOBAL scope) ----
    let lastSig = { today: null, tomorrow: null };
    let forecastChanged = { today: false, tomorrow: false };

    let lastActualSig = null;
function actualSignatureFor(rows) {
  const todayISO = nycISODate(0);
  const a = rows.find(r =>
    r.forecast_or_actual === "actual" &&
    r.cli_date === todayISO &&
    r.actual_high
  );
  if (!a) return "";
  return [
    a.cli_date,
    a.actual_high,
    a.high_time || "",
    a.timestamp || a.date_pulled || ""
  ].join("|");
}

    function forecastSignatureFor(dateISO, rows = allRows) {
      return rows
        .filter(r => r.forecast_or_actual === "forecast" && r.target_date === dateISO && r.predicted_high)
        .map(r => `${r.timestamp || r.forecast_time || ""}|${r.predicted_high}`)
        .sort()
        .join("~");
    }
    function seedForecastSignatures() {
      lastSig.today = forecastSignatureFor(nycISODate(0));
      lastSig.tomorrow = forecastSignatureFor(nycISODate(1));
    }

    async function pollCsvAndUpdate() {
      try {
        const txt = await fetch(CSV_URL + "?" + Date.now(), { cache: "no-cache", mode: "cors" }).then(r => r.text());

        // reuse parser
        const raw = csvToRows(txt);
        if (!raw.length) return;
        const header = raw[0].map(h => h.trim());
        const rows = [];
        for (let i = 1; i < raw.length; i++) {
          const rec = {};
          for (let j = 0; j < header.length; j++) {
            let v = (raw[i][j] ?? '').trim();
            if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1).replace(/""/g, '"');
            rec[header[j]] = v;
          }
          rows.push(rec);
        }

        const todayISO = nycISODate(0);
        const tomorrowISO = nycISODate(1);
        const sigTodayNew = forecastSignatureFor(todayISO, rows);
        const sigTmrwNew  = forecastSignatureFor(tomorrowISO, rows);
        const actSigNew = actualSignatureFor(rows);
      const actualChanged = actSigNew !== lastActualSig;
if (actualChanged) lastActualSig = actSigNew;

const changedToday    = sigTodayNew !== lastSig.today;
const changedTomorrow = sigTmrwNew  !== lastSig.tomorrow;

// If nothing changed at all, bail
if (!changedToday && !changedTomorrow && !actualChanged) return;

// Forecasts or actual changed ‚Üí reset + pretrain so normal/incognito match
  if (typeof warmOnceForCurrentCSV === "function") {
    try { warmOnceForCurrentCSV(); } catch (e) { console.warn("warmOnceForCurrentCSV failed:", e); }
  }
  if (typeof pretrainFromHistory === "function") {
    try { pretrainFromHistory(); } catch (e) { console.warn("pretrainFromHistory failed:", e); }
  }

// (optional) refresh the bias-corrected cards immediately
try { updateCorrectionBoxes(); } catch {}

// Adopt new signatures (we still only *log* on forecast changes)
lastSig.today    = sigTodayNew;
lastSig.tomorrow = sigTmrwNew;
forecastChanged.today    = changedToday;
forecastChanged.tomorrow = changedTomorrow;

// Swap data
allRows = rows;
filteredRows = allRows.slice();

// === NEW: if an actual just appeared/changed, train Hedge immediately ===
if (actualChanged) {
  try {
    const todayISO = nycISODate(0);
    const a = allRows.find(r => r.forecast_or_actual === "actual" && r.cli_date === todayISO && r.actual_high);
    if (a && a.actual_high != null) {
      const season = getSeason(todayISO);
      const built  = buildCandidatesForDay(todayISO, a.high_time || "");
      await updateHedgeOnActual("today", season, built.candidates, Number(a.actual_high), todayISO);
        // also teach the "tomorrow" model using D1-only candidates for the resolved day
      const c1today = d1CandidatesFor(todayISO);
      const tmCands = {};
      if (c1today.latest  != null) tmCands.D1_latest  = Number(c1today.latest);
      if (c1today.trimmed != null) tmCands.D1_trimmed = Number(c1today.trimmed);
      const rep1 = repFromSeries(c1today.series);
      if (rep1 != null) tmCands.series_rep = Number(rep1);
      await updateHedgeOnActual("tomorrow", season, tmCands, Number(a.actual_high), todayISO);
    }
  } catch(_) {}
}

// Refresh UI
showMostRecent();
updateSummaryBoxes();
updateCorrectionBoxes();  // now uses the freshly-trained state

      } catch (e) {
        console.debug("pollCsvAndUpdate error:", e);
      }
    }

    /* ========= NETWORK: SAME-ORIGIN ‚Üí PROXY ‚Üí UPSTREAM ========= */
    const CSV_URL = "https://raw.githubusercontent.com/hwaheed13/nws-forecast-logger/main/nws_forecast_log.csv";
    const ACCU_URL = "https://raw.githubusercontent.com/hwaheed13/nws-forecast-logger/main/accuweather_log.csv";
    const KALSHI_BASE_URL = "https://kalshi.com/markets/kxhighny/highest-temperature-in-nyc";
    const API_BASE = "/api"; // relative works from / or /dashboard/

    const KALSHI_BY_DATE_URLS = [ `${API_BASE}/kalshi` ];
    const KALSHI_LIVE_URLS    = [ `${API_BASE}/kalshi-live` ];
    const NWS_HIGH_SO_FAR_URLS= [ `${API_BASE}/nws-high-so-far` ];
    const NWS_CURRENT_TEMP_URLS=[ `${API_BASE}/nws-current-temp` ];
    const NWS_DSM_URLS        = [
      `${API_BASE}/nws-dsm?issuedby=NYC`,
      "https://forecast.weather.gov/product.php?site=NWS&issuedby=NYC&product=DSM&format=CI&version=1&glossary=1",
    ];
    const NWS_6HR_JSON_URLS = [
      `${API_BASE}/nws-6hr-json`,
      "https://www.weather.gov/source/wrh/timeseries/obs.js",
    ];

    async function fetchJSON(urls, qs) {
      for (const base of urls) {
        try {
          const u = new URL(base, location.origin);
          if (qs) for (const [k, v] of Object.entries(qs)) u.searchParams.set(k, v);
          const r = await fetch(u.toString(), { cache: "no-cache", mode: "cors", headers: { Accept: "application/json" } });
          if (r.ok) return await r.json();
        } catch (_) {}
      }
      return null;
    }
    async function fetchTEXT(urls, qs) {
      for (const base of urls) {
        try {
          const u = new URL(base, location.origin);
          if (qs) for (const [k, v] of Object.entries(qs)) u.searchParams.set(k, v);
          const r = await fetch(u.toString(), { cache: "no-cache", mode: "cors" });
          if (r.ok) return await r.text();
        } catch (_) {}
      }
      return null;
    }

    async function fetchKalshiWinningRange(dateISO) { return fetchJSON(KALSHI_BY_DATE_URLS, { date: dateISO }); }
    async function fetchKalshiLiveLeader(dateISO)   { return fetchJSON(KALSHI_LIVE_URLS, { date: dateISO, cb: Date.now() }); }
    async function fetchNwsHighSoFar(station = "KNYC") { return fetchJSON(NWS_HIGH_SO_FAR_URLS, { station }); }
    async function fetchNwsCurrentTemp(station = "KNYC") { return fetchJSON(NWS_CURRENT_TEMP_URLS, { station, cb: Date.now() }); }

// Helper function to check if DSM exists for today
function hasDSMForToday() {
  const dsmEl = document.getElementById("box-dsm-max");
  return dsmEl && dsmEl.textContent && dsmEl.textContent !== "‚Äî";
} 
async function fetchAccuWeatherForecasts() {
  try {
    const response = await fetch('/api/accuweather-forecast');
    if (!response.ok) return null;
    
    const data = await response.json();
    
    // Initialize if it doesn't exist
    if (!window.accuWeatherData) {
      window.accuWeatherData = { today: null, tomorrow: null };
    }
    
    const oldToday = window.accuWeatherData.today;
    const oldTomorrow = window.accuWeatherData.tomorrow;
    
    // Only update today's AccuWeather if DSM hasn't been published
    if (!hasDSMForToday()) {
      window.accuWeatherData.today = Math.round(data.DailyForecasts[0].Temperature.Maximum.Value);
    }
    window.accuWeatherData.tomorrow = Math.round(data.DailyForecasts[1].Temperature.Maximum.Value);
    
    console.log(`AccuWeather: Today ${window.accuWeatherData.today}¬∞F, Tomorrow ${window.accuWeatherData.tomorrow}¬∞F`);
    
    // If values changed, update the prediction boxes
    if (oldToday !== window.accuWeatherData.today || oldTomorrow !== window.accuWeatherData.tomorrow) {
      if (typeof updateCorrectionBoxes === 'function') {
        updateCorrectionBoxes();
      }
    }
    
    return window.accuWeatherData;
  } catch (error) {
    console.error('AccuWeather error:', error);
    return null;
  }
}
window.fetchAccuWeatherForecasts = fetchAccuWeatherForecasts;



    // Kalshi cache
    const kalshiCache = new Map();
    async function getKalshiLabel(dateISO) {
      const today = nycISODate(0);
      const yesterday = nycISODate(-1);

      // Never cache "today"
      if (dateISO === today) return await fetchKalshiWinningRange(dateISO);

      const now = Date.now();
      const cached = kalshiCache.get(dateISO);
      if (cached && (dateISO !== yesterday || (now - cached._ts) < 120000)) return cached.data;

      const fresh = await fetchKalshiWinningRange(dateISO);
      kalshiCache.set(dateISO, { _ts: now, data: fresh });
      return fresh;
    }

    // DSM parsing
    function parseDSM(text) {
      if (!text) return null;
      const t = text.replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim();
      const dateMatch = t.match(/\b(\d{1,2})\/(\d{2})\b/);
      if (!dateMatch) return null;
      const after = t.slice(t.indexOf(dateMatch[0]) + dateMatch[0].length);
      const hiBlock = after.match(/\b(\d{6})\b/);
      if (!hiBlock) return null;
      const block = hiBlock[1];
      const tempF = Number(block.slice(0, 2));
      const hh = block.slice(2, 4);
      const mm = block.slice(4, 6);
      if (!Number.isFinite(tempF)) return null;
      const now = new Date();
      const year = now.getFullYear();
      const dd = String(dateMatch[1]).padStart(2, "0");
      const mmMon = String(dateMatch[2]).padStart(2, "0");
      const isoLocal = `${year}-${mmMon}-${dd}T${hh}:${mm}:00`;
      const dayISO = `${year}-${mmMon}-${dd}`;
      const when = new Date(isoLocal);
      const fmtET = new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        hour: "numeric",
        minute: "2-digit"
      }).format(when);
      return { tempF, timeET: fmtET, iso: isoLocal, dayISO, raw: block };
    }

    // Month helpers (for table)
    function monthKeyFromISO(iso) { const [y,m] = iso.split('-'); return `${y}-${m}`; }
    function monthLabelFromKey(key) {
      const [y, m] = key.split('-').map(Number);
      const d = new Date(y, m - 1, 1);
      return new Intl.DateTimeFormat('en-US', { month: 'long', year: 'numeric' }).format(d);
    }

    // DSM (single, non-duplicated)
    let lastDSMDay = nycISODate(0);
    function clearDSMOnly() {
      const max = document.getElementById("box-dsm-max");
      const note = document.getElementById("box-dsm-note");
      if (max) max.textContent = "‚Äì";
      if (note) note.textContent = "";
    }
    async function updateDSM() {
      const el = document.getElementById("box-dsm-max");
      const note = document.getElementById("box-dsm-note");
      if (!el || !note) return;
      const today = nycISODate(0);
      if (today !== lastDSMDay) { clearDSMOnly(); lastDSMDay = today; }
      el.textContent = "‚Äì";
      note.textContent = "";
      const txt = await fetchTEXT(NWS_DSM_URLS);
      const parsed = parseDSM(txt);
      if (parsed && parsed.dayISO === today) {
        el.textContent = `${parsed.tempF.toFixed(0)}¬∞F`;
        note.textContent = `${parsed.timeET} ET ‚Ä¢ daily summary message`;
      } else {
        clearDSMOnly();
      }
    }

    // 6-hr max
    async function updateSixHourMax() {
      const el = document.getElementById("box-6hr-max");
      const note = document.getElementById("box-6hr-max-note");
      if (!el || !note) return;
      el.textContent = "‚Äì";
      note.textContent = "";
      try {
        const parsed = await fetchJSON(NWS_6HR_JSON_URLS, { station: "KNYC" });
        if (parsed && parsed.value != null) {
         el.textContent = `${parsed.value}¬∞F`;
        window._sixHourMaxF = Number(parsed.value);
          note.textContent = parsed.time ? `as of ${parsed.time} ‚Ä¢ 6-hr max` : "Latest 6-hr max";
        } else {
          note.textContent = "6-Hr Max not available";
            }
    } catch (err) {
      console.error("6HR fetch error:", err);
      note.textContent = "6-Hr Max unavailable";
    }
    
    // Re-evaluate the overnight note after 6-hr max updates
    try { await handleOvernightExceedanceNote(); } catch {}
    
    }

    // Observations: current temp only
    function updateObservations() {
      fetchNwsCurrentTemp("KNYC").then(cur => {
        const el = document.getElementById("box-today-current");
        const note = document.getElementById("box-today-current-note");
        if (!el || !note) return;
        if (cur && cur.currentF != null) {
         el.textContent = `${Number(cur.currentF).toFixed(1)}¬∞F`;
        window._recentObservedF = Number(cur.currentF);
        window._recentObservedAtISO = (typeof cur?.atISO === "string") ? cur.atISO : null;


  // Track overnight high between midnight and 7 AM ET, persist until CLI publishes
  {
    const etNow  = new Date().toLocaleString("en-US", { timeZone: "America/New_York" });
    const etDate = new Date(etNow);
    const etHour = etDate.getHours();
    const todayKey = nycISODate(0);
  
    // 0‚Äì7 ET: live track and persist
    if (etHour >= 0 && etHour < 7) {
      const current = window._recentObservedF;
      if (Number.isFinite(current) && current > (window._overnightHighSoFar ?? -Infinity)) {
        window._overnightHighSoFar = current;
        window._overnightHighTime  = (typeof cur?.atISO === "string") ? cur.atISO : null;
        try {
          localStorage.setItem(`overnight_${todayKey}`, JSON.stringify({ high: current, time: window._overnightHighTime }));
        } catch {}
        console.log(`[Overnight tracker] ‚úÖ New overnight high: ${current}¬∞F`);
      }
    } else if (etHour === 7) {
      // Keep value around for display after the window closes
      if (window._overnightHighSoFar != null) {
        console.log(`[Overnight tracker] üïñ 7 AM - holding overnight high: ${window._overnightHighSoFar}¬∞F`);
      }
    } else if (etHour > 7) {
      // After 7 ET: keep the value until the official CLI "actual" publishes, then clear
      const published = hasActualFor(todayKey);
      if (published) {
        try { localStorage.removeItem(`overnight_${todayKey}`); } catch {}
        window._overnightHighSoFar = null;
        window._overnightHighTime  = null;
      }
    }
  }
  
  // If any post-midnight obs beats today's forecast, set a sticky exceedance flag (kept until CLI posts)
  try {
    const etNow  = new Date().toLocaleString("en-US", { timeZone: "America/New_York" });
    const etDate = new Date(etNow);
    const etHour = etDate.getHours();
    const todayKey = nycISODate(0);
  
    if (!hasActualFor(todayKey) && etHour < 10) {
      // Use same forecast getter as the exceedance checker
      let latestForecast = latestPreHighValue(getForecastRowsFor(todayKey, "D0"), "");
      if (!Number.isFinite(latestForecast)) {
        latestForecast = latestPreHighValue(getForecastRowsFor(todayKey, "D1"), "");
      }
      const current = window._recentObservedF;
      if (Number.isFinite(current) && Number.isFinite(latestForecast) && current > latestForecast) {
        const payload = {
          value: current,
          forecast: latestForecast,
          time: (typeof window._recentObservedAtISO === "string") ? window._recentObservedAtISO : null
        };
        window._overnightExceeded = payload;
        try { localStorage.setItem(`overnightExceeded_${todayKey}`, JSON.stringify(payload)); } catch {}
        console.log(`[Overnight exceed] ‚úÖ ${current}¬∞F > fcst ${latestForecast}¬∞F`);
      }
    }
  } catch (e) { console.debug("overnight exceed check failed", e); }
  
  // Re-evaluate the note after each observation tick
  try { handleOvernightExceedanceNote(); } catch {}

  
          const ts = cur.atISO ? new Date(cur.atISO) : null;
          const tNY = ts ? new Intl.DateTimeFormat("en-US", {
            timeZone: "America/New_York",
            hour: "numeric",
            minute: "2-digit"
          }).format(ts) : "";
          note.textContent = tNY ? `as of ${tNY} ET ‚Ä¢ station ${cur.station}` : `station ${cur.station}`;
        } else {
          el.textContent = "‚Äì";
          note.textContent = "";
        }
      });
    }

    async function updateSummaryBoxes() {
      const today = nycISODate(0);
      const tomorrow = nycISODate(1);
      const yesterday = nycISODate(-1);

      const latestForDate = (date) => {
        const rows = allRows
          .filter(r => r.forecast_or_actual === "forecast" && r.target_date === date && r.predicted_high);
        if (!rows.length) return null;
        rows.sort((a, b) => {
          const A = a.timestamp || a.forecast_time || "";
          const B = b.timestamp || b.forecast_time || "";
          return B.localeCompare(A);
        });
        return Number(rows[0].predicted_high);
      };

      // Update the four metric boxes + mini chips
      const tLatest  = latestForDate(today);
      const tActRow  = allRows.find(r => r.forecast_or_actual === "actual" && r.cli_date === today && r.actual_high);
      const tActual  = tActRow ? Number(tActRow.actual_high) : null;
      const tmLatest = latestForDate(tomorrow);

      const e = (id) => document.getElementById(id);
      if (e("box-today-forecast"))    e("box-today-forecast").textContent    = (tLatest  == null) ? "‚Äì" : `${tLatest.toFixed(0)}¬∞F`;
      if (e("box-today-actual"))      e("box-today-actual").textContent      = (tActual  == null) ? "‚Äì" : `${tActual.toFixed(0)}¬∞F`;
      if (e("box-tomorrow-forecast")) e("box-tomorrow-forecast").textContent = (tmLatest == null) ? "‚Äì" : `${tmLatest.toFixed(0)}¬∞F`;

      const todayRows    = getForecastsForDate(today);
      const tomorrowRows = getForecastsForDate(tomorrow);
      renderMiniForecastChips(todayRows, "mini-today-forecasts");
      renderMiniForecastChips(tomorrowRows, "mini-tomorrow-forecasts");

      // ===== Kalshi badges =====
      const tBox  = e('box-today-kalshi');
      const tNote = e('box-today-kalshi-note');
      const yBox  = e('box-yday-kalshi');
      const yNote = e('box-yday-kalshi-note');

      try {
        const [ktoday, kyday, live] = await Promise.all([
          getKalshiLabel(today),
          getKalshiLabel(yesterday),
          fetchKalshiLiveLeader(today)
        ]);

        // --- TODAY ---
        if (live && live.leadingLabel) {
          const pct = (live.leadingProb != null) ? ` (${Math.round(live.leadingProb * 100)}%)` : "";
          if (tBox)  tBox.innerHTML  = `<a class="kalshi-badge" href="${KALSHI_BASE_URL}" target="_blank" rel="noopener noreferrer">${live.leadingLabel}${pct}</a>`;
          if (tNote) tNote.textContent = "Live leader (can flip before settlement).";
        } else if (ktoday && ktoday.settled === true && ktoday.label) {
          if (tBox)  tBox.innerHTML  = `<a class="kalshi-badge" href="${KALSHI_BASE_URL}" target="_blank" rel="noopener noreferrer">${ktoday.label}</a>`;
          if (tNote) tNote.textContent = (ktoday.exactTemp != null) ? `Settled at ${ktoday.exactTemp.toFixed(1)}¬∞F.` : "";
        } else {
          if (tBox)  tBox.innerHTML  = `<span class="kalshi-pending">Pending settlement</span>`;
          if (tNote) tNote.textContent = "Closes 11:59 PM ET; settles after NWS daily report.";
        }

        // --- YESTERDAY ---
        const anchor = kalshiAnchorForISO(yesterday);
        const yHref = `${KALSHI_BASE_URL}${anchor}`;
        if (kyday && kyday.label) {
          const exact = (kyday.exactTemp != null) ? ` (settled ${kyday.exactTemp.toFixed(1)}¬∞F)` : "";
          if (yBox)  yBox.innerHTML  = `<a class="kalshi-badge" href="${yHref}" target="_blank" rel="noopener noreferrer">${kyday.label}${exact}</a>`;
          if (yNote) yNote.textContent = "Links directly to yesterday's contract.";
        } else {
          if (yBox)  yBox.innerHTML  = `<a class="kalshi-badge" href="${yHref}" target="_blank" rel="noopener noreferrer">Open yesterday's market</a>`;
          if (yNote) yNote.textContent = "No proxy data; linking via anchor.";
        }
      } catch {
        if (tBox)  tBox.innerHTML  = `<a class="kalshi-badge" href="${KALSHI_BASE_URL}" target="_blank" rel="noopener noreferrer">Open market</a>`;
        if (tNote) tNote.textContent = "Could not load proxy data.";
        const yHref = `${KALSHI_BASE_URL}${kalshiAnchorForISO(yesterday)}`;
        if (yBox)  yBox.innerHTML  = `<a class="kalshi-badge" href="${yHref}" target="_blank" rel="noopener noreferrer">Open yesterday's market</a>`;
        if (yNote) yNote.textContent = "Proxy error; using anchor link.";
      }
    }

function hasActualFor(dateISO) {
  return allRows.some(r =>
    r.forecast_or_actual === "actual" &&
    r.cli_date === dateISO &&
    r.actual_high && String(r.actual_high).trim() !== ""
  );
}

async function updateCorrectionBoxes() {
  try {
    const todayISO = nycISODate(0);
    const tomorrowISO = nycISODate(1);

    // ----- Today -----
    const seasonToday = getSeason(todayISO);
    const builtToday = buildCandidatesForDay(todayISO, "");
    const predToday = await predictWithHedge("today", seasonToday, builtToday.candidates);
    // expose for debugging
window._predToday = predToday;

    console.log("TODAY ‚Üí",
      "candidates:", builtToday.candidates,
      "prediction:", predToday?.y,
      "bias:", predToday?.bias
    );

    // ----- Tomorrow -----
    const seasonTomorrow = getSeason(tomorrowISO);
    const builtTomorrow = buildCandidatesForDay(tomorrowISO, "");
    const predTomorrow = await predictWithHedge("tomorrow", seasonTomorrow, builtTomorrow.candidates);
    
    // expose for debugging
window._predTomorrow = predTomorrow;

  // === Feed today's realization into D1 (momentum/realized-heat) ===
  // Self-contained: don't rely on getActualFor / hasActualFor
  let d1AdjF = 0;               // local used by renderer
  window._d1AdjF = 0;           // debug
  window._d1Adj_debug = null;   // debug
  
  try {
  // Find today's actual directly from allRows (case-insensitive + cli_date OR target_date + multiple field names)
  const rowsSrc = Array.isArray(allRows) ? allRows : [];
  const actualRow = rowsSrc.find(r =>
    r &&
    String(r.forecast_or_actual || "").toLowerCase() === "actual" &&
    (r.cli_date === todayISO || r.target_date === todayISO) &&
    (r.actual_high != null || r.actual != null || r.high != null)
  );
  const actual = actualRow
    ? (Number.isFinite(Number(actualRow.actual_high)) ? Number(actualRow.actual_high)
       : Number.isFinite(Number(actualRow.actual))     ? Number(actualRow.actual)
       : Number(actualRow.high))
    : NaN;
  
    // Build a baseline from today's intraday forecasts: prefer D0_*; if none, use D1_*; always include AccuWeather if present
    const cT = builtToday?.candidates || {};
    const pool = [];
    if (Number.isFinite(cT.D0_latest))   pool.push(cT.D0_latest);
    if (Number.isFinite(cT.D0_trimmed))  pool.push(cT.D0_trimmed);
    if (!pool.length) {
      if (Number.isFinite(cT.D1_latest))   pool.push(cT.D1_latest);
      if (Number.isFinite(cT.D1_trimmed))  pool.push(cT.D1_trimmed);
    }
    if (Number.isFinite(cT.AccuWeather)) pool.push(cT.AccuWeather);
  
    if (Number.isFinite(actual) && pool.length && Number.isFinite(predTomorrow?.y)) {
      const base = pool.reduce((a,b)=>a+b,0) / pool.length;
      const overshoot = actual - base;          // ¬±
      const BETA = 0.30;                        // tune 0.2‚Äì0.4
      const CAP  = 2.0;                         // max |bump|
      const bump = Math.max(-CAP, Math.min(CAP, BETA * overshoot));
      d1AdjF = bump;
      window._d1AdjF = d1AdjF;                  // debug
      window._d1Adj_debug = { actual, base, overshoot, bump: d1AdjF, pool: [...pool] }; // debug
      console.log("D1 momentum bump applied:", d1AdjF, window._d1Adj_debug);
    }
  } catch (e) {
    console.debug("D1 momentum adj skipped:", e);
  }

  

     console.log("TOMORROW ‚Üí",
    "candidates:", builtTomorrow.candidates,
    "raw:", predTomorrow?.y,
    "bump:", (typeof d1AdjF === "number" ? d1AdjF : 0),
    "final:", (Number(predTomorrow?.y) + (Number.isFinite(d1AdjF) ? d1AdjF : 0)),
    "bias:", predTomorrow?.bias
  );

  // Fetch Kalshi data to map predictions to ranges
    let todayKalshiRange = null;
    let tomorrowKalshiRange = null;
    let todayMarket = null;
    let tomorrowMarket = null;
    
    try {
      [todayMarket, tomorrowMarket] = await Promise.all([
        fetchKalshiLiveLeader(todayISO).catch(() => null),
        fetchKalshiLiveLeader(tomorrowISO).catch(() => null)
      ]);
      
      if (todayMarket && predToday?.y) {
        todayKalshiRange = mapToKalshiRange(predToday.y, todayMarket);
      }
      
      if (tomorrowMarket && predTomorrow?.y) {
        const finalTemp = predTomorrow.y + (Number.isFinite(d1AdjF) ? d1AdjF : 0);
        tomorrowKalshiRange = mapToKalshiRange(finalTemp, tomorrowMarket);
      }
    } catch (e) {
      console.debug("Kalshi range mapping failed:", e);
    }

    // Format predictions with proper display
  // Track predictions - only add if different from last value
  if (predToday?.y) {
    const rounded = Math.round(predToday.y * 10) / 10;
    const last = predictionHistory.today[predictionHistory.today.length - 1];
    if (!last || last.value !== rounded) {
      predictionHistory.add('today', predToday.y);
    }
  }
  if (predTomorrow?.y) {
    const finalTomorrow = predTomorrow.y + (Number.isFinite(d1AdjF) ? d1AdjF : 0);
    const rounded = Math.round(finalTomorrow * 10) / 10;
    const last = predictionHistory.tomorrow[predictionHistory.tomorrow.length - 1];
    if (!last || last.value !== rounded) {
      predictionHistory.add('tomorrow', finalTomorrow);
    }
  }

 // Check for early morning exceedance
    const exceedance = await checkEarlyMorningExceedance();   
// Get ML predictions for today/tomorrow (from static JSON)
    const mlToday = window._mlPredictions?.predictions?.[todayISO] || null;
    const mlTomorrow = window._mlPredictions?.predictions?.[tomorrowISO] || null;
    // Mark stale if parent is stale
    if (mlToday && window._mlPredictions?._stale) mlToday._stale = true;
    if (mlTomorrow && window._mlPredictions?._stale) mlTomorrow._stale = true;

// Only log valid predictions after system is fully loaded
    if (systemFullyLoaded && predToday?.y && predToday.y > 20 && !hasActualFor(todayISO)) {
      const roundedToday = Math.round(predToday.y * 10) / 10;
      if (lastLoggedPredictions.today !== roundedToday) {
        const todayConfForLog = todayKalshiRange
          ? computeBucketConfidence(predToday.y, todayKalshiRange, builtToday.candidates, todayMarket, mlToday, predToday.pad)
          : null;
        logUIprediction('today', predToday.y, builtToday.candidates, todayConfForLog, predToday.bias, predToday.pad, mlToday);
        lastLoggedPredictions.today = roundedToday;
      }
    }

    if (systemFullyLoaded && predTomorrow?.y && predTomorrow.y > 20) {
      const finalValue = predTomorrow.y + (Number.isFinite(d1AdjF) ? d1AdjF : 0);
      const roundedTomorrow = Math.round(finalValue * 10) / 10;
      if (lastLoggedPredictions.tomorrow !== roundedTomorrow) {
        const tmConfForLog = tomorrowKalshiRange
          ? computeBucketConfidence(finalValue, tomorrowKalshiRange, builtTomorrow.candidates, tomorrowMarket, mlTomorrow, predTomorrow.pad)
          : null;
        logUIprediction('tomorrow', finalValue, builtTomorrow.candidates, tmConfForLog, predTomorrow.bias, predTomorrow.pad, mlTomorrow);
        lastLoggedPredictions.tomorrow = roundedTomorrow;
      }
    }
    
    const el0 = document.getElementById('correctionBoxToday');
    const el1 = document.getElementById('correctionBoxTomorrow');
    
    if (el0) {
      if (hasActualFor(todayISO)) {
        el0.innerHTML = `
          <div class="prediction-value">‚Äî</div>
          <div class="prediction-subtitle">Actual high published for ${todayISO}</div>
        `;
      } else if (Number.isFinite(predToday?.y) && predToday?.y > 0) {
        const val = predToday.y.toFixed(1);
        const bias = Number.isFinite(predToday.bias)
          ? predToday.bias.toFixed(2)
          : "0.00";
        const sign = Number(bias) >= 0 ? "+" : "";

        const kalshiNote = todayKalshiRange?.label 
          ? ` ‚Ä¢ Kalshi: ${todayKalshiRange.label}` 
          : "";
        
const exceedanceNote = (
  exceedance &&
  Number.isFinite(Number(exceedance.currentTemp)) &&
  Number.isFinite(Number(exceedance.forecast)) &&
  Number.isFinite(Number(exceedance.hour))
) ? `<div class="info-note">
      Currently ${Number(exceedance.currentTemp).toFixed(1)}¬∞F at ${Number(exceedance.hour)}:00 AM ET ‚Äî already at/above forecast (${Number(exceedance.forecast).toFixed(1)}¬∞F).
      High may occur overnight. Forecast reflects expected daytime high.
    </div>`
  : '';


// Compute bucket confidence (with ML data if available)
const todayConf = todayKalshiRange
  ? computeBucketConfidence(predToday.y, todayKalshiRange, builtToday.candidates, todayMarket, mlToday, predToday.pad)
  : { pct: 0, signal: "SKIP", reason: "No Kalshi data" };
const sigClass0 = todayConf.signal.toLowerCase();

const bucketLabel0 = todayKalshiRange?.label || `${Math.floor(predToday.y)}-${Math.floor(predToday.y)+1}`;

// Build source detail line
const srcParts0 = [];
if (mlToday) srcParts0.push(`ML: ${mlToday.temperature.toFixed(1)}¬∞F ‚Üí ${mlToday.bucket} (${Math.round(mlToday.confidence*100)}%)`);
srcParts0.push(`Hedge: ${val}¬∞F`);
if (Number.isFinite(builtToday.candidates?.D0_latest)) srcParts0.push(`NWS: ${builtToday.candidates.D0_latest}¬∞`);
if (Number.isFinite(builtToday.candidates?.AccuWeather)) srcParts0.push(`Accu: ${builtToday.candidates.AccuWeather}¬∞`);

el0.innerHTML = `
  <div class="bucket-display">
    <span class="bucket-range">${bucketLabel0}¬∞F</span>
    <span class="bucket-signal ${sigClass0}">${todayConf.signal}</span>
    <span class="probability-value ${sigClass0}">${todayConf.pct}%</span>
  </div>
  <div class="confidence-reason">${todayConf.reason}</div>
  <details class="source-details">
    <summary>Source details</summary>
    <div class="detail-content">${srcParts0.join(' | ')}</div>
  </details>
  ${exceedanceNote}
`;
      } else {
        el0.innerHTML = `<div class="prediction-value">‚Äî</div><div class="prediction-subtitle">Awaiting forecast data</div>`;
      }
    }
    
    
if (el1) {
  if (Number.isFinite(predTomorrow?.y)) {
    const raw = Number(predTomorrow.y);
    const bump = (typeof d1AdjF === "number" && Number.isFinite(d1AdjF)) ? d1AdjF : 0;
    const final = Math.round((raw + bump) * 10) / 10;
    const val = final.toFixed(1);
    

        const bias = predTomorrow?.bias != null ? Number(predTomorrow.bias).toFixed(2) : "0.00";
        const sign = Number(bias) >= 0 ? "+" : "";
        const showBump = Math.abs(bump) >= 0.05;
        const bumpTxt = showBump ? ` ‚Ä¢ momentum ${bump >= 0 ? "+" : ""}${bump.toFixed(1)}¬∞` : "";

        const kalshiNote = tomorrowKalshiRange?.label 
            ? ` ‚Ä¢ Kalshi: ${tomorrowKalshiRange.label}` 
            : "";
        
  // Compute bucket confidence for tomorrow (with ML data if available)
  const tmConf = tomorrowKalshiRange
    ? computeBucketConfidence(final, tomorrowKalshiRange, builtTomorrow.candidates, tomorrowMarket, mlTomorrow, predTomorrow.pad)
    : { pct: 0, signal: "SKIP", reason: "No Kalshi data" };
  const sigClass1 = tmConf.signal.toLowerCase();

  const bucketLabel1 = tomorrowKalshiRange?.label || `${Math.floor(final)}-${Math.floor(final)+1}`;

  // Build source detail line for tomorrow
  const srcParts1 = [];
  if (mlTomorrow) srcParts1.push(`ML: ${mlTomorrow.temperature.toFixed(1)}¬∞F ‚Üí ${mlTomorrow.bucket} (${Math.round(mlTomorrow.confidence*100)}%)`);
  srcParts1.push(`Hedge: ${val}¬∞F`);
  if (Number.isFinite(builtTomorrow.candidates?.D1_latest)) srcParts1.push(`NWS: ${builtTomorrow.candidates.D1_latest}¬∞`);
  if (Number.isFinite(builtTomorrow.candidates?.AccuWeather)) srcParts1.push(`Accu: ${builtTomorrow.candidates.AccuWeather}¬∞`);

  el1.innerHTML = `
      <div class="bucket-display">
        <span class="bucket-range">${bucketLabel1}¬∞F</span>
        <span class="bucket-signal ${sigClass1}">${tmConf.signal}</span>
        <span class="probability-value ${sigClass1}">${tmConf.pct}%</span>
      </div>
      <div class="confidence-reason">${tmConf.reason}</div>
      <details class="source-details">
        <summary>Source details</summary>
        <div class="detail-content">${srcParts1.join(' | ')}</div>
      </details>
    `;
      } else {
        el1.innerHTML = `<div class="prediction-value">‚Äî</div><div class="prediction-subtitle">Awaiting forecast data</div>`;
      }
    }

  // Re-apply any overnight exceedance note after the card re-render
  try { await handleOvernightExceedanceNote(); } catch {}

  } catch (e) {
    console.warn("updateCorrectionBoxes() failed", e);
    const el0 = document.getElementById('correctionBoxToday');
    const el1 = document.getElementById('correctionBoxTomorrow');
    if (el0) el0.innerHTML = `<div class="prediction-value">‚Äî</div><div class="prediction-subtitle">Error loading data</div>`;
    if (el1) el1.innerHTML = `<div class="prediction-value">‚Äî</div><div class="prediction-subtitle">Error loading data</div>`;
  }
}
window.updateCorrectionBoxes = updateCorrectionBoxes;
// Helper function to map temperature to Kalshi range
function mapToKalshiRange(temp, kalshiData) {
  if (!kalshiData?.ranges || !Array.isArray(kalshiData.ranges)) return null;

  for (const range of kalshiData.ranges) {
    // "X¬∞ or less" - anything up to and including X.99
    if (range.min === null && temp < range.max + 1) return range;
    // "X¬∞ or more" - anything X.0 and above
    if (range.max === null && temp >= range.min) return range;
    // "X¬∞ to Y¬∞" ranges - Kalshi treats these as X.0 to Y.99
    // So "81¬∞ to 82¬∞" includes all temps from 81.0 to 82.99
    if (range.min !== null && range.max !== null) {
      if (temp >= range.min && temp < range.max + 1) {
        return range;
      }
    }
  }
  
  return null;
}

  function showChart() {
    // Group rows by target/cli date (the "day" label)
    const byDate = {};
    filteredRows.forEach(r => {
      const d = (r.forecast_or_actual === "actual" ? r.cli_date : r.target_date);
      if (!/^\d{4}-\d{2}-\d{2}$/.test(d || "")) return;
      (byDate[d] ??= []).push(r);
    });
  
    const haveDays = Object.keys(byDate).sort();
    const ctx = document.getElementById('dailyChart').getContext('2d');
  
    if (!haveDays.length) {
      if (chartInstance) chartInstance.destroy();
      chartInstance = new Chart(ctx, { type:'line', data:{labels:[], datasets:[]}, options:{} });
      return;
    }
  
    // Build continuous day labels from first Monday-ish to last day (same as before)
    const isoToDate = iso => { const [Y,M,D] = iso.split('-').map(Number); return new Date(Y, M-1, D); };
    const dateToISO = d => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    const addDays  = (d,n)=>{ const x=new Date(d); x.setDate(x.getDate()+n); return x; };
  
    const first = isoToDate(haveDays[0]);
    const dow = first.getDay();             // 0=Sun ‚Ä¶ 6=Sat
    const back = (dow + 6) % 7;             // start week on Mon
    const start = addDays(first, -back);
    const end   = isoToDate(haveDays[haveDays.length - 1]);
  
    const labels = [];
    for (let d=new Date(start); d<=end; d=addDays(d,1)) labels.push(dateToISO(d));

    // Helper function to map temperature to Kalshi range
function mapToKalshiRange(temp, kalshiData) {
  if (!kalshiData?.ranges || !Array.isArray(kalshiData.ranges)) return null;
  
  const t = Math.floor(temp);
  
  for (const range of kalshiData.ranges) {
    // Handle "X¬∞ or less" ranges
    if (range.min === null && t <= range.max) return range;
    // Handle "X¬∞ or more" ranges  
    if (range.max === null && t >= range.min) return range;
    // Handle "X¬∞ to Y¬∞" ranges
    if (range.min !== null && range.max !== null && t >= range.min && t <= range.max) return range;
  }
  return null;
}
  
    // Helpers to compute daily stats from detailed log
    const actualMap   = new Map();  // day ‚Üí actual
    const lastMap     = new Map();  // day ‚Üí last pre-high forecast (chronological latest before high_time)
    const bestMap     = new Map();  // day ‚Üí best pre-high forecast (closest to actual)
    const minMap      = new Map();  // day ‚Üí min pre-high forecast
    const maxMap      = new Map();  // day ‚Üí max pre-high forecast
  
    labels.forEach(dayISO => {
      const rows = byDate[dayISO] || [];
      const actualRow = rows.find(r => r.forecast_or_actual === "actual" && r.actual_high);
      if (!actualRow) return; // only compute when we have an actual
  
      const actualHigh = Number(actualRow.actual_high);
      const highTime   = actualRow.high_time || ""; // HH:MM AM/PM (ET) when available
      actualMap.set(dayISO, Number.isFinite(actualHigh) ? actualHigh : null);
  
      // Collect pre-high forecasts
      const pre = rows
        .filter(r => r.forecast_or_actual === "forecast" && r.predicted_high)
        .filter(r => {
          if (!highTime) return true; // if no high time, treat all same-day forecasts as eligible
          const fcHH = (r.forecast_time || "").substr(11, 5);
          return !(fcHH && compareTimes(fcHH, highTime) > 0); // drop after-high issuances
        })
        .map(r => ({
          t: (r.timestamp || r.forecast_time || ""),
          v: Number(r.predicted_high)
        }))
        .filter(x => Number.isFinite(x.v))
        .sort((a,b) => (a.t || "").localeCompare(b.t || "")); // chronological
  
      if (!pre.length) return;
  
      // Last pre-high (chronologically latest before high)
      const last = pre[pre.length - 1].v;
      lastMap.set(dayISO, last);
  
      // Best pre-high (closest to actual)
      if (Number.isFinite(actualHigh)) {
        let best = pre[0].v, bestErr = Math.abs(pre[0].v - actualHigh);
        for (let i=1;i<pre.length;i++){
          const e = Math.abs(pre[i].v - actualHigh);
          if (e < bestErr) { best = pre[i].v; bestErr = e; }
        }
        bestMap.set(dayISO, best);
      }
  
      // Range band
      const vs = pre.map(p => p.v);
      minMap.set(dayISO, Math.min(...vs));
      maxMap.set(dayISO, Math.max(...vs));
    });
  
    const actual = labels.map(d => actualMap.has(d) ? actualMap.get(d) : null);
    const lastPH = labels.map(d => lastMap.has(d)     ? lastMap.get(d)     : null);
    const bandMin= labels.map(d => minMap.has(d)      ? minMap.get(d)      : null);
    const bandMax= labels.map(d => maxMap.has(d)      ? maxMap.get(d)      : null);
    const bestPH = labels.map(d => bestMap.has(d)     ? bestMap.get(d)     : null); // used in tooltip only
  
    // Build chart
    if (chartInstance) chartInstance.destroy();
    chartInstance = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          // 1) Band (min then max). Max fills down to previous (min) to create the shaded envelope.
          {
            label: 'Pre-high range (min)',
            data: bandMin,
            borderWidth: 0,
            pointRadius: 0,
            spanGaps: true
          },
          {
            label: 'Pre-high range (max)',
            data: bandMax,
            borderWidth: 0,
            pointRadius: 0,
            spanGaps: true,
            fill: { target: '-1' },                  // fill to previous dataset (min)
            backgroundColor: 'rgba(37,99,235,0.10)'  // subtle blue-ish shade
          },
  
          // 2) Actual
          {
            label: 'Actual high',
            data: actual,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 0,
            pointHitRadius: 10,
            spanGaps: true,
            borderColor: '#2563eb'
          },
  
          // 3) Last pre-high (what you realistically knew)
          {
            label: 'Last pre-high forecast',
            data: lastPH,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 0,
            pointHitRadius: 10,
            spanGaps: true,
            borderColor: '#059669'
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        spanGaps: true,
        animation: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { display: true },
          tooltip: {
            mode: 'index',
            intersect: false,
            callbacks: {
              title: (items) => {
                const iso = labels[items[0].dataIndex];
                const [Y,M,D] = iso.split('-').map(Number);
                const jsDate = new Date(Y, M-1, D);
                return new Intl.DateTimeFormat('en-US', { weekday:'short', month:'short', day:'numeric' }).format(jsDate);
              },
              label: (ctx) => {
                const y = ctx.parsed.y;
                const name = ctx.dataset.label;
                if (y == null) return `${name}: ‚Äî`;
                return `${name}: ${Number(y).toFixed(1)}¬∞F`;
              },
              afterBody: (items) => {
                // Append Best pre-high + simple errors in the tooltip (no extra line on chart)
                const idx = items?.[0]?.dataIndex;
                if (idx == null) return '';
                const a = actual[idx], lp = lastPH[idx], bp = bestPH[idx];
                const parts = [];
  
                if (bp != null) {
                  parts.push(`Best pre-high: ${bp.toFixed(1)}¬∞F`);
                }
                if (a != null && lp != null) {
                  const errLast = (lp - a).toFixed(1);
                  parts.push(`Last error: ${errLast}¬∞F`);
                }
                if (a != null && bp != null) {
                  const errBest = (bp - a).toFixed(1);
                  parts.push(`Best error: ${errBest}¬∞F`);
                }
                return parts.length ? parts.join('\n') : '';
              }
            }
          }
        },
        scales: {
          x: {
            title: { display: true, text: 'Day' },
            grid: { color: 'rgba(0,0,0,0.05)' },
            offset: true,
            ticks: {
              autoSkip: true, autoSkipPadding: 8, maxRotation: 0, minRotation: 0,
              callback: (val, idx) => {
                const iso = labels[idx];
                if (!iso) return '';
                const [Y,M,D] = iso.split('-').map(Number);
                const jsDate = new Date(Y, M-1, D);
                return new Intl.DateTimeFormat('en-US', { month:'short', day:'numeric' }).format(jsDate);
              }
            }
          },
          y: {}
        }
      }
    });
  }

async function displayTable() {
      const tb = document.querySelector("#dataTable tbody");
      if (!tb) return;
      tb.innerHTML = "";
    
    // Load prediction snapshots from Supabase
      const predSnapshots = {};
      const toISODate = (v) => {
        if (v == null) return "";
        const s = String(v);
        const m = s.match(/\d{4}-\d{2}-\d{2}/); // works for 'YYYY-MM-DD' and ISO timestamps
        return m ? m[0] : "";
      };
      try {
        const { data, error } = await supabase
          .from("forecast_day_summary")
          .select("target_date, prev_day_latest_value, same_day_earliest_value");
        
        console.log("üìä Fetched snapshots:", { count: data?.length, sample: data?.[0], error });
        
        if (error) throw error;

        if (Array.isArray(data) && data.length) {
          data.forEach((row) => {
            const td = toISODate(row.target_date);
            if (!td) return;

            const nb = row.prev_day_latest_value;
            if (nb !== null && nb !== undefined && nb !== "") {
              predSnapshots[`${td}_night_before`] = Number(nb).toFixed(1);
            }

            const mo = row.same_day_earliest_value;
            if (mo !== null && mo !== undefined && mo !== "") {
              predSnapshots[`${td}_morning_of`] = Number(mo).toFixed(1);
            }
          });
        }
      } catch (e) {
        console.log("Could not load prediction snapshots from Supabase:", e);
      }

      const dayMap = {};
      filteredRows.forEach(r => {
        const date = (r.forecast_or_actual === "actual" ? r.cli_date : r.target_date);
        if (!/^\d{4}-\d{2}-\d{2}$/.test(date || "")) return;
        (dayMap[date] ??= []).push(r);
      });

      const dates = Object.keys(dayMap).sort();
      const months = {};
      dates.forEach(d => {
        const mk = monthKeyFromISO(d);
        (months[mk] ??= []).push(d);
      });

      const kalshiByDate = {};
      await Promise.all(dates.map(async d => {
        try { kalshiByDate[d] = await getKalshiLabel(d); }
        catch { kalshiByDate[d] = null; }
      }));

      const todayISO = nycISODate(0);
      const yISO = nycISODate(-1);

      Object.keys(months).sort().forEach(mk => {
        const label = monthLabelFromKey(mk);
        const hdr = document.createElement("tr");
        hdr.className = "month-row collapsed";
        hdr.dataset.month = mk;
        hdr.innerHTML = `<td colspan="11"><span class="caret">‚ñ∏</span>${label}</td>`;
        tb.appendChild(hdr);

        months[mk].forEach(date => {
          const rows = dayMap[date];
          const forecasts = rows.filter(r => r.forecast_or_actual === "forecast");
          const actual = rows.find(r => r.forecast_or_actual === "actual") || null;

          forecasts.sort((a, b) => {
            const A = (a.timestamp || a.forecast_time || "");
            const B = (b.timestamp || b.forecast_time || "");
            return A.localeCompare(B);
          });

          let bestIdx = -1, bestErr = Infinity;
          const actualHigh = actual && actual.actual_high ? Number(actual.actual_high) : null;
          const highTime = actual && actual.high_time ? actual.high_time : "";

          forecasts.forEach((r, i) => {
            if (!r.predicted_high || actualHigh == null) return;
            if (highTime) {
              const fcHH = (r.forecast_time || "").substr(11, 5);
              if (fcHH && compareTimes(fcHH, highTime) > 0) return;
            }
            const err = Math.abs(Number(r.predicted_high) - actualHigh);
            if (err < bestErr) { bestErr = err; bestIdx = i; }
          });

          forecasts.forEach((r, i) => {
            const cls = "forecast-row" + (i === bestIdx ? " best" : "");
            const pulled = r.timestamp || r.date_pulled || "";
            const fcTime = (r.forecast_time || "").substr(11, 5);
            const pred = r.predicted_high ? `${r.predicted_high}¬∞F` : "";
            const actTxt = (actual && actual.actual_high) ? `${actual.actual_high}¬∞F` : "";
           const errTxt = (r.predicted_high && actualHigh != null)
          ? (Number(r.predicted_high) - actualHigh).toFixed(1)   // signed error: pred - actual
          : "";

            const tr = document.createElement("tr");
            tr.className = cls + " is-hidden";
            tr.dataset.month = mk;
          tr.innerHTML = `
            <td>${pulled}</td>
            <td>${fcTime}</td>
            <td>${date}</td>
            <td>${pred}</td>
            <td>${actTxt}</td>
            <td>${highTime || ""}</td>
            <td>${errTxt}</td>
            <td>${i === bestIdx ? "‚úÖ" : ""}</td>
            <td></td>
            <td></td>
            <td></td>
          `;
            tb.appendChild(tr);
          });

        if (actual) {
        const pulled = actual.timestamp || actual.date_pulled || "";
        const actTxt = actual.actual_high ? `${actual.actual_high}¬∞F` : "";
        const k = kalshiByDate[date];
        const label = k && k.label ? k.label : "";
        const exact = (k && k.exactTemp != null) ? ` (${k.exactTemp.toFixed(1)}¬∞F)` : "";
      
        let kalshiCell = "‚Äî";
        if (date === yISO) {
          kalshiCell = `<a class="kalshi-badge" href="${KALSHI_BASE_URL}${kalshiAnchorForISO(yISO)}" target="_blank" rel="noopener noreferrer">${label || "Open market"}${exact}</a>`;
        } else if (date === todayISO) {
          kalshiCell = `<a class="kalshi-badge" href="${KALSHI_BASE_URL}" target="_blank" rel="noopener noreferrer">${label || "Open market"}</a>`;
        } else if (label) {
          kalshiCell = `<span class="kalshi-badge">${label}${exact}</span>`;
        }
      
        // Get prediction snapshots
        const nightBefore = predSnapshots[`${date}_night_before`] || '‚Äî';
        const morningOf = predSnapshots[`${date}_morning_of`] || '‚Äî';
      
        const tr = document.createElement("tr");
        tr.className = "actual-row is-hidden";
        tr.dataset.month = mk;
        tr.innerHTML = `
          <td>${pulled}</td>
          <td></td>
          <td>${date}</td>
          <td></td>
          <td>${actTxt}</td>
          <td>${actual.high_time || ""}</td>
          <td></td>
          <td></td>
          <td>${kalshiCell}</td>
          <td>${nightBefore !== '‚Äî' ? nightBefore + '¬∞F' : '‚Äî'}</td>
          <td>${morningOf !== '‚Äî' ? morningOf + '¬∞F' : '‚Äî'}</td>
        `;
        tb.appendChild(tr);
      }
        });
      });

      tb.onclick = (e) => {
        const tr = e.target.closest("tr.month-row");
        if (!tr) return;
        const mk = tr.dataset.month;
        
        // First, collapse ALL other months
        tb.querySelectorAll("tr.month-row").forEach(row => {
          if (row !== tr) {
            row.classList.add("collapsed");
            const monthKey = row.dataset.month;
            tb.querySelectorAll(`tr[data-month="${monthKey}"]:not(.month-row)`).forEach(r =>
              r.classList.add("is-hidden")
            );
          }
        });
        
        // Then toggle the clicked month
        const collapsed = tr.classList.toggle("collapsed");
        tb.querySelectorAll(`tr[data-month="${mk}"]:not(.month-row)`).forEach(r =>
          r.classList.toggle("is-hidden", collapsed)
        );
      };
    }

    function resetFilter() {
      filteredRows = allRows.slice();
      const f = document.getElementById('fromDate'); if (f) f.value = "";
      const t = document.getElementById('toDate');   if (t) t.value = "";
      displayTable();
      showStats();
      showChart();
      showMostRecent();
      updateCorrectionBoxes();
      updateSummaryBoxes();
    }

    function applyDateFilter() {
      const from = document.getElementById('fromDate').value;
      const to   = document.getElementById('toDate').value;
      filteredRows = allRows.filter(row => {
        const date = row.forecast_or_actual === "actual" ? row.cli_date : row.target_date;
        if (!date) return false;
        if (from && date < from) return false;
        if (to && date > to) return false;
        return true;
      });
      displayTable();
      showStats();
      showChart();
      showMostRecent();
      updateCorrectionBoxes();
      updateSummaryBoxes();
    }

   function showStats() {
  const stats = document.getElementById('stats');
  if (!stats) return;

  const dayMap = {};
  filteredRows.forEach(r => {
    const date = (r.forecast_or_actual === "actual" ? r.cli_date : r.target_date);
    if (!date) return;
    (dayMap[date] ??= []).push(r);
  });

  const dates = Object.keys(dayMap).filter(d => /^\d{4}-\d{2}-\d{2}$/.test(d));
  const daysWithActual = dates.filter(d => {
    const rows = dayMap[d] || [];
    return rows.some(r => r.forecast_or_actual === "actual" && r.actual_high);
  });

  let totalAbsErr = 0, totalBestErr = 0, errCount = 0, bestCount = 0;
  let totalSignedErr = 0, totalBestSignedErr = 0;
  let totalBcpErr = 0, bcpErrCount = 0;

  // Bucket accuracy counters
  let nwsBucketHits = 0, bcpBucketHits = 0, bucketDays = 0;

  daysWithActual.forEach(d => {
    const rows = dayMap[d] || [];
    const actual = rows.find(r => r.forecast_or_actual === "actual" && r.actual_high);
    if (!actual) return;
    const actualHigh = Number(actual.actual_high);
    const highTime = actual.high_time || "";

    const forecasts = rows
      .filter(r => r.forecast_or_actual === "forecast" && r.predicted_high)
      .filter(r => {
        if (highTime) {
          const fcHH = (r.forecast_time || "").substr(11, 5);
          if (fcHH && compareTimes(fcHH, highTime) > 0) return false;
        }
        return true;
      })
      .map(r => Number(r.predicted_high))
      .filter(Number.isFinite);

    if (forecasts.length) {
      const signedErrors = forecasts.map(f => f - actualHigh);
      const allErrors = forecasts.map(f => Math.abs(f - actualHigh));

      const avgErr = allErrors.reduce((a, b) => a + b, 0) / allErrors.length;
      const avgSignedErr = signedErrors.reduce((a, b) => a + b, 0) / signedErrors.length;

      const bestIdx = allErrors.indexOf(Math.min(...allErrors));
      const bestErr = allErrors[bestIdx];
      const bestSignedErr = signedErrors[bestIdx];

      totalAbsErr += avgErr;
      totalSignedErr += avgSignedErr;
      totalBestErr += bestErr;
      totalBestSignedErr += bestSignedErr;
      errCount++;
      bestCount++;

      // Bucket accuracy: use last forecast for the day as "NWS"
      const nwsLast = forecasts[forecasts.length - 1];
      const actualBucket = Math.floor(actualHigh);
      const nwsBucket = Math.floor(nwsLast);
      if (nwsBucket === actualBucket) nwsBucketHits++;

      // Bias-corrected bucket: apply the running mean bias to NWS
      // Use cumulative bias up to this point (approximated by overall mean)
      const bcpVal = nwsLast + (totalSignedErr / errCount);  // running mean bias
      const bcpBucket = Math.floor(nwsLast - (totalSignedErr / errCount));  // subtract bias since bias = forecast - actual
      if (bcpBucket === actualBucket) bcpBucketHits++;
      bucketDays++;

      // BCP error for this day
      const bcpPred = nwsLast - (totalSignedErr / errCount);
      totalBcpErr += Math.abs(bcpPred - actualHigh);
      bcpErrCount++;
    }
  });

  const avgAbsErr = errCount > 0 ? (totalAbsErr / errCount).toFixed(1) : "--";
  const avgBestErr = bestCount > 0 ? (totalBestErr / bestCount).toFixed(1) : "--";
  const avgBcpErr = bcpErrCount > 0 ? (totalBcpErr / bcpErrCount).toFixed(1) : "--";
  const meanBias = errCount > 0 ? (totalSignedErr / errCount) : null;

  const meanBiasStr = meanBias != null
    ? (meanBias >= 0 ? "+" : "") + meanBias.toFixed(1) + "¬∞F"
    : "--";

  // Update track record banner
  const ourAccEl = document.getElementById('ourAccuracy');
  const nwsAccEl = document.getElementById('nwsAccuracy');
  const daysVerEl = document.getElementById('daysVerified');
  if (bucketDays > 0) {
    const ourPct = Math.round(100 * bcpBucketHits / bucketDays);
    const nwsPct = Math.round(100 * nwsBucketHits / bucketDays);
    if (ourAccEl) ourAccEl.textContent = `${ourPct}%`;
    if (nwsAccEl) nwsAccEl.textContent = `${nwsPct}%`;
    if (daysVerEl) daysVerEl.textContent = bucketDays;
  }

stats.innerHTML = `
  <div class="stat-card">
    <div class="stat-label">
      Days Tracked
      <span class="tip" tabindex="0" data-tip="Total days with any forecast data">i</span>
    </div>
    <div class="stat-value">${dates.length}</div>
  </div>
  <div class="stat-card">
    <div class="stat-label">
      Days Verified
      <span class="tip" tabindex="0" data-tip="Days where the actual high was recorded">i</span>
    </div>
    <div class="stat-value">${daysWithActual.length}</div>
  </div>
  <div class="stat-card">
    <div class="stat-label">
      NWS Avg Error
      <span class="tip" tabindex="0" data-tip="Average NWS forecast error magnitude">i</span>
    </div>
    <div class="stat-value">${avgAbsErr}¬∞F</div>
  </div>
  <div class="stat-card">
    <div class="stat-label">
      Our Avg Error
      <span class="tip" tabindex="0" data-tip="Average error of bias-corrected predictions">i</span>
    </div>
    <div class="stat-value" style="color: #059669">${avgBcpErr}¬∞F</div>
  </div>
  <div class="stat-card">
    <div class="stat-label">
      Forecast Bias
      <span class="tip" tabindex="0" data-tip="Average signed error: + means forecasts run high, - means low">i</span>
    </div>
    <div class="stat-value" style="color: ${meanBias > 0 ? '#d97706' : meanBias < 0 ? '#2563eb' : 'inherit'}">
      ${meanBiasStr}
    </div>
  </div>
  <div class="stat-card">
    <div class="stat-label">
      Best Day Error
      <span class="tip" tabindex="0" data-tip="Average error of each day's most accurate forecast">i</span>
    </div>
    <div class="stat-value">${avgBestErr}¬∞F</div>
  </div>
`;
}
    // Expose necessary functions globally for auth script
    window.probeLoggingEndpoint = probeLoggingEndpoint;
    window.reloadCSV = reloadCSV;
    window.updateDSM = updateDSM;
    window.updateSixHourMax = updateSixHourMax;
    window.updateObservations = updateObservations;
    window.updateSummaryBoxes = updateSummaryBoxes;
    window.updateCorrectionBoxes = updateCorrectionBoxes;
    window.pollCsvAndUpdate = pollCsvAndUpdate;
  </script>

  <!-- Auth + boot (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
<script>
// Create supabase client in global scope so all functions can access it
window.supabase = window.supabase.createClient(
    "https://ztjtuhkjkqchsiuuvmzs.supabase.co",
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inp0anR1aGtqa3FjaHNpdXV2bXpzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYzMTUwODIsImV4cCI6MjA3MTg5MTA4Mn0.g7Zq-YbHxBzw732PhVfTf7XGiR080gRndsrzc0YPHfw"
);

(() => {
// Rest of the auth code continues here, but WITHOUT re-declaring supabase

async function loadTodaysPredictionHistory() {
  const today = window.nycISODate(0);
  console.log("Loading predictions for:", today);
  
  const { data, error } = await supabase
    .from('prediction_logs')
    .select('prediction_value, timestamp')
    .eq('target_date', today)
    .eq('lead_used', 'D0')
    .order('timestamp', { ascending: true });
    
  if (error) {
    console.error("Error loading predictions:", error);
    return;
  }
  
  console.log("Raw data from database:", data);
  
  if (data && data.length > 0) {
    // Clear existing history before loading from database
    window.predictionHistory.today = [];
    
    // Process all values
    const processedValues = [];
    data.forEach(row => {
      const roundedValue = Math.round(row.prediction_value * 10) / 10;
      processedValues.push(roundedValue);
      
      const entry = {
        timestamp: row.timestamp,
        value: roundedValue,
        hour: new Date(row.timestamp).getHours()
      };
      
      // Only add if different from last value
      const last = window.predictionHistory.today[window.predictionHistory.today.length - 1];
      if (!last || last.value !== roundedValue) {
        window.predictionHistory.today.push(entry);
        console.log("Added entry:", entry);
      } else {
        console.log("Skipped duplicate:", roundedValue);
      }
    });
    
    console.log('Processing complete:', {
      rawCount: data.length,
      processedValues: processedValues,
      uniqueValues: [...new Set(processedValues)],
      finalHistory: window.predictionHistory.today,
      computedRange: window.predictionHistory.getRange('today')
    });
  }
}

  const gate = document.getElementById("gate");
  function gateMsg(msg){
    const sub = gate && gate.querySelector(".gate-sub");
    if (sub && msg) sub.textContent = msg;
  }

  // Buttons
  document.getElementById("btn-logout")?.addEventListener("click", async () => {
    try { await supabase.auth.signOut(); } catch(e) {}
    try { localStorage.removeItem("dashboard_heartbeat"); } catch(e) {}
    window.location.href = "login.html";
  });

  document.getElementById("btn-billing")?.addEventListener("click", async () => {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) { window.location.href = "login.html"; return; }
    try {
      const r = await fetch("/api/create-portal-session", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ supabaseAccessToken: session.access_token })
      });
      const j = await r.json();
      if (!r.ok || !j?.url) { alert(j?.error || "Could not open billing portal"); return; }
      window.location.href = j.url;
    } catch (e) { alert("Could not open billing portal"); }
  });

async function bootApp() {
    // Load today's prediction history first
    try { await loadTodaysPredictionHistory(); } catch {}
    
    // light, defensive calls
    try { window.showTodayDate && window.showTodayDate(); } catch {}
    try { window.scheduleMidnightUpdate && window.scheduleMidnightUpdate(); } catch {}
    try { window.probeLoggingEndpoint && await window.probeLoggingEndpoint(); } catch {}

    // Fetch AccuWeather API data early
    if (typeof fetchAccuWeatherForecasts === 'function') {
      try { await fetchAccuWeatherForecasts(); } catch {}
    }

    try { window.reloadCSV && await window.reloadCSV({ skipUI: true }); } catch {}
    // now paint the UI once, with warmed state
    try { window.resetFilter && window.resetFilter(); } catch {}
    try { window.showMostRecent && window.showMostRecent(); } catch {}
    try { window.updateSummaryBoxes && window.updateSummaryBoxes(); } catch {}
    try { window.updateCorrectionBoxes && window.updateCorrectionBoxes(); } catch {}
    try { window.updateObservations && window.updateObservations(); } catch {}
    try { window.updateDSM && window.updateDSM(); } catch {}
    try { window.updateSixHourMax && window.updateSixHourMax(); } catch {}
    try { window.updateObservations && window.updateObservations(); } catch {}
    try { window.updateSummaryBoxes && window.updateSummaryBoxes(); } catch {}
    try { window.updateCorrectionBoxes && window.updateCorrectionBoxes(); } catch {}


    try { window.pollCsvAndUpdate && window.pollCsvAndUpdate(); } catch {}
    try { await handleOvernightExceedanceNote(); } catch {}
    setInterval(() => { try { window.updateObservations && window.updateObservations(); } catch {} }, 5 * 60 * 1000);
    setInterval(() => { try { window.updateDSM && window.updateDSM(); } catch {} }, 10 * 60 * 1000);
    setInterval(() => { try { window.updateSixHourMax && window.updateSixHourMax(); } catch {} }, 10 * 60 * 1000);
    setInterval(() => { try { window.updateSummaryBoxes && window.updateSummaryBoxes(); } catch {} }, 60 * 1000);
    setInterval(() => { try { window.updateCorrectionBoxes && window.updateCorrectionBoxes(); } catch {} }, 60 * 1000);
    setInterval(() => { try { window.pollCsvAndUpdate && window.pollCsvAndUpdate(); } catch {} }, 60 * 1000);
    // Poll AccuWeather every 2 hours
    if (typeof fetchAccuWeatherForecasts === 'function') {
      fetchAccuWeatherForecasts();
      setInterval(fetchAccuWeatherForecasts, 2 * 60 * 60 * 1000);
    }

  try {
      localStorage.setItem("dashboard_heartbeat", String(Date.now()));
      setInterval(() => { try { localStorage.setItem("dashboard_heartbeat", String(Date.now())); } catch {} }, 60 * 1000);
    } catch {}
    
    // Mark system as fully loaded after initial data load
    setTimeout(() => { 
      systemFullyLoaded = true;
      console.log("System fully loaded, logging enabled");
    }, 2000);
  }

async function checkAccess() {
  const path = location.pathname || "";
  const onLogin = /\/login(\.html)?$/.test(path);
  const onSubscribe = /\/subscribe(\.html)?$/.test(path);

  gateMsg("Checking access‚Ä¶");

  // 1) Session
  const { data: sessData, error: sErr } = await supabase.auth.getSession();
  if (sErr) {
    console.warn("getSession error", sErr);
    // If we're on login already, just show the prompt; otherwise go to login
    if (!onLogin) location.href = "login.html";
    else gateMsg("Please sign in.");
    return;
  }
  const session = sessData?.session || null;

  if (!session) {
    if (!onLogin) {
      gateMsg("Not signed in ‚Üí redirecting to login‚Ä¶");
      location.href = "login.html";
    } else {
      gateMsg("Please sign in.");
    }
    return;
  }

  // 2) Entitlement (profiles)
  try {
    const { data: profile, error } = await supabase
      .from("profiles")
      .select("subscription_status, current_period_end, trial_used")
      .eq("id", session.user.id)
      .single();

    if (error) throw error;

    const status = String(profile?.subscription_status || "inactive").toLowerCase();
    const entitled = (status === "active" || status === "trialing");

    if (!entitled) {
      if (!onSubscribe) {
        const dest = profile?.trial_used ? "subscribe.html?reason=trial_expired" : "subscribe.html";
        gateMsg("Subscription required ‚Üí redirecting‚Ä¶");
        location.href = dest;
      } else {
        gateMsg("Subscription required.");
      }
      return;
    }

    // 3) Authorized ‚Üí show the app
    try { window.showApp && window.showApp(); } catch {}
    await bootApp().catch(console.error);

  } catch (e) {
    // On any entitlement error: don't loop from login; show message there
    console.warn("Entitlement check failed", e);
    if (!onLogin) {
      location.href = "login.html";
    } else {
      gateMsg("Please sign in.");
    }
  }
}

supabase.auth.onAuthStateChange((_event, session) => {
  const onLogin = /\/login(\.html)?$/.test(location.pathname || "");
  if (!session && !onLogin) {
    location.href = "login.html";
  }
  // If on /login, let the login UI handle it.
});

  checkAccess();
  })();
// ===== Theme: system by default, toggle cycles System ‚Üí Dark ‚Üí Light =====
(function () {
  const KEY = "theme-pref"; // "system" | "dark" | "light"
  const root = document.documentElement;
  const mql = window.matchMedia("(prefers-color-scheme: dark)");
   const togg = document.getElementById("themeToggle");
  const themeLabel = document.querySelector(".theme-label");
  const switchEl = document.querySelector(".theme-switch");

  function currentPref() {
    return localStorage.getItem(KEY) || "system";
  }

    function applyTheme(pref) {
      if (pref === "system") {
        // set attribute based on OS right now
        root.setAttribute("data-theme", mql.matches ? "dark" : "light");
      } else {
        root.setAttribute("data-theme", pref);
      }
      updateButton(pref);
    }

  function updateButton(pref) {
    if (!togg || !themeLabel) return;
    themeLabel.textContent =
      pref === "system" ? "Auto" :
      pref === "dark"   ? "Dark" :
                          "Light";
    // Visual: we show "on" when Dark; Light/Auto both look off/neutral
    togg.checked = (pref === "dark");
    if (switchEl) switchEl.classList.toggle("is-auto", pref === "system");
  }

  function cycle(pref) {
    return pref === "system" ? "dark" : pref === "dark" ? "light" : "system";
  }

  function init() {
    const pref = currentPref();
    applyTheme(pref);

    // If following system, react to OS changes
    mql.addEventListener("change", () => {
      if (currentPref() === "system") applyTheme("system");
    });

    if (togg) {
      togg.addEventListener("change", () => {
        const next = cycle(currentPref()); // cycle: system ‚Üí dark ‚Üí light ‚Üí system
        localStorage.setItem(KEY, next);
        applyTheme(next);
      });
    }

    // Ensure we persist an initial value
    if (!localStorage.getItem(KEY)) {
      localStorage.setItem(KEY, "system");
    }
  }

  init();
})();
</script>
</body>
</html>
