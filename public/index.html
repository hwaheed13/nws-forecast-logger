<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üå°Ô∏è NWS Forecast Logger Dashboard (Live)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    /* === Design Tokens (brand-lite, newsroom-clean) === */
    :root{
      --ink:#132a3b;            /* deep ink */
      --muted:#5c728a;          /* slate */
      --bg:#f6f8fb;             /* page */
      --card:#ffffff;           /* surfaces */
      --ring:#e8eef6;           /* borders */
      --brand:#175398;          /* primary */
      --brand-2:#1c6bd0;        /* accent */
      --ok:#1f9c69;             /* status ok */
      --warn:#f59e0b;           /* status warn */
      --shadow:0 10px 30px rgba(16, 35, 82, .08);
      --radius-xl:18px;
      --radius-lg:14px;
      --radius:10px;
      --sp-1:8px; --sp-2:12px; --sp-3:16px; --sp-4:20px; --sp-5:24px; --sp-6:32px; --sp-7:40px;
      --maxw:1200px;
    }

    /* === Base === */
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family:"Inter", system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      margin:0; color:var(--ink); background:linear-gradient(180deg,#f3f7fd 0%, #f6f8fb 60%, #f6f8fb 100%);
      font-feature-settings:"tnum" 1, "lnum" 1; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    a{color:var(--brand-2); text-decoration:none}
    a:hover{text-decoration:underline}

    /* === Hero === */
    .hero{
      max-width:var(--maxw); margin:0 auto; padding: clamp(24px, 6vw, 56px) clamp(16px, 5vw, 28px) 0;
    }
    .hero-wrap{
      background:
        radial-gradient(60% 120% at 10% -10%, #e9f1ff 0%, rgba(233,241,255,0) 60%),
        radial-gradient(70% 140% at 110% 10%, #e8f7ff 0%, rgba(232,247,255,0) 60%),
        #f7fbff;
      border:1px solid var(--ring);
      border-radius: clamp(14px, 1.6vw, 22px);
      box-shadow: var(--shadow);
      padding: clamp(18px, 3vw, 28px);
    }
    .hero h1{
      margin:0 0 6px 0;
      font-weight:800;
      letter-spacing:.2px;
      font-size: clamp(22px, 3.4vw, 34px);
      color:#0e2e4b;
    }
    .hero-sub{
      color:var(--muted);
      font-size: clamp(13px, 1.6vw, 15px);
      line-height:1.5;
      display:flex; align-items:center; gap:10px;
    }
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 10px; border-radius:999px; font-size:12px; font-weight:600;
      color:#0f3c6d; background:#eaf2ff; border:1px solid var(--ring);
    }
    .meta-line{
      margin-top:10px; color:#2a5592; font-weight:600; letter-spacing:.01em;
      font-size:14px;
    }

    /* === Main Container === */
    .container{
      max-width:var(--maxw);
      margin: clamp(16px, 3.5vw, 28px) auto 40px;
      padding: 0 clamp(16px, 5vw, 28px);
    }

    /* === Stat Grid === */
    .stats{ display:grid; gap:12px; grid-template-columns: repeat(12, 1fr); margin: 16px 0 8px; }
    .stat-box{
      grid-column: span 12;
      background:var(--card);
      border:1px solid var(--ring);
      border-radius:var(--radius-lg);
      padding:14px 16px;
      box-shadow: var(--shadow);
      transition: transform .08s ease, box-shadow .18s ease;
    }
    .stat-box:hover{ transform: translateY(-1px); box-shadow:0 16px 32px rgba(16,35,82,.10); }
    @media (min-width:720px){ .stat-box{ grid-column: span 6; } }
    @media (min-width:1040px){ .stat-box{ grid-column: span 3; } }

    .stat-val{ font-size: clamp(20px, 2.4vw, 26px); font-weight:800; color:#0f63c6; }

    /* subtle contextual backgrounds */
    #card-today-forecast{ background: linear-gradient(180deg,#fff8ee, #fffdf9); }
    #card-today-actual{   background: linear-gradient(180deg,#f1fff6, #fcfffd); }
    #card-tomorrow-forecast{ background: linear-gradient(180deg,#eef6ff, #fbfdff); }
    #card-today-kalshi, #card-yday-kalshi{ background: linear-gradient(180deg,#fffaf2, #fffefb); }

    .mini-forecasts{ display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
    .mini-chip{ font-size:12px; padding:4px 8px; border-radius:999px; background:#eef6ff; border:1px solid var(--ring); color:#1d5dbc; white-space:nowrap; }
    .sparkline-wrap{ margin-top:6px; }
    .sparkline{ width:180px; height:30px; display:block; }

    .kalshi-badge{display:inline-block;margin-top:6px;padding:4px 10px;border-radius:999px;border:1px solid var(--ring);font-size:12px;background:#fff7f0;color:#b14b00}
    .kalshi-link{color:inherit;text-decoration:none;border-bottom:1px dotted #b14b00}
    .kalshi-pending{display:inline-block;margin-top:6px;padding:4px 10px;border-radius:999px;border:1px dashed var(--ring);font-size:12px;background:#fffaf0;color:#a16207}
    .kalshi-small{font-size:12px;color:#6b7280;margin-top:4px}

    /* === ‚ÄúCorrected predictions‚Äù duo === */
    .duo{ display:grid; grid-template-columns:1fr; gap:12px; margin:14px 0 8px; }
    @media (min-width:900px){ .duo{ grid-template-columns:1fr 1fr; } }
    .correction-box{
      background: linear-gradient(180deg, #fffbe9, #fffef7);
      border:1px solid #ffecb3;
      border-left:6px solid #ffd95b;
      border-radius:var(--radius-lg);
      padding: clamp(16px, 3vw, 24px);
      box-shadow: var(--shadow);
      font-size:15px;
    }
    .correction-box b{ color:#6b4f00; }
    .correction-box .big{
      font-size: clamp(18px, 2.4vw, 22px);
      font-weight:800;
      letter-spacing:.01em;
    }

    /* === Controls === */
    .controls{
      display:flex; flex-wrap:wrap; gap:10px 12px; align-items:center;
      margin: 18px 0 20px; padding: 14px;
      background: var(--card);
      border:1px solid var(--ring);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
    }
    label{ font-size:13px; color:#3c5872; }
    input[type="date"]{
      font-size:14px; padding:8px 10px; border-radius:10px; border:1px solid #cfd9e6; background:#fff;
      outline:none;
    }
    .btn{
      background:linear-gradient(180deg, var(--brand-2), #185db7);
      color:#fff; border:none; border-radius:12px; padding:9px 14px; cursor:pointer;
      font-weight:700; letter-spacing:.01em;
      box-shadow:0 6px 18px rgba(25,118,210,.22);
      transition:transform .06s ease, box-shadow .18s ease, opacity .15s ease;
    }
    .btn:hover{ box-shadow:0 10px 26px rgba(25,118,210,.28); }
    .btn:active{ transform:translateY(1px); }
    .btn:disabled{ opacity:.55; cursor:not-allowed }

    /* === Stats row (inline re-rendered) === */
    #stats .stat-box{ display:flex; justify-content:space-between; align-items:baseline; }
    #stats .stat-box .stat-val{ color:#0a4aa0 }

    /* === Chart === */
    .chart{
      background:var(--card);
      border:1px solid var(--ring);
      border-radius:var(--radius-xl);
      box-shadow:var(--shadow);
      padding: clamp(12px, 2.6vw, 24px);
      margin-top: 8px;
      overflow:hidden;
    }

    /* === Table === */
    .table-wrap{
      overflow:auto;
      margin-top:16px;
      background:var(--card);
      border:1px solid var(--ring);
      border-radius:var(--radius-xl);
      box-shadow: var(--shadow);
    }
    #dataTable{
      width:100%; border-collapse:separate; border-spacing:0; font-size:14px; table-layout:fixed; background:#fff;
    }
    thead th{
      position: sticky; top: 0;
      background: linear-gradient(180deg, #0f63c6, #0d56ac);
      color:#fff; z-index:5;
      border-bottom:1px solid rgba(255,255,255,.15);
      padding: 12px 8px; text-align:center; letter-spacing:.02em; font-weight:700;
    }
    th:first-child{ border-top-left-radius: 14px; }
    th:last-child{ border-top-right-radius: 14px; }
    td{ border-top:1px solid #edf2f8; padding: 10px 6px; text-align:center; color:#2a3f54; }
    tr:nth-child(even) td{ background:#f9fbff; }
    tr:hover td{ background:#eef5ff; }
    .forecast-row{ background:#fffdf3 !important; }
    .actual-row{ background:#f2faf2 !important; }
    .best{ box-shadow: inset 0 0 0 2px #9be19b; }
    #dataTable th:nth-child(5), #dataTable td:nth-child(5){ width: 90px; }

    /* skeletons for CSV fetch */
    .skel td::before{
      content:""; display:block; height:10px; margin:6px auto; width:70%;
      background:linear-gradient(90deg,#eef3f9,#f8fbff,#eef3f9);
      background-size:200% 100%; animation:sh 1.2s infinite linear; border-radius:6px;
    }
    @keyframes sh { from{background-position:0 0;} to{background-position:200% 0;} }

    /* === Footer === */
    footer{
      margin:26px 0 40px; font-size:12px; color:#6b7280; text-align:center;
    }
    footer a{ color:#42658b; text-decoration:underline; text-underline-offset:2px }

    /* === Small helpers === */
    .sr{ position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }
  </style>
</head>
<body>

  <!-- HERO -->
  <section class="hero">
    <div class="hero-wrap">
      <h1>NWS Forecast Logger Dashboard ‚Äî Central Park, NY <span class="badge">Live</span></h1>
      <div class="hero-sub">
        <span>Auto-logs NWS forecasts and compares against the official daily high.</span>
      </div>
      <div id="recentForecast" class="meta-line">Last logged forecast: ‚Ä¶</div>
    </div>
  </section>

  <!-- MAIN -->
  <main class="container">

    <!-- Summary boxes -->
    <section class="stats" aria-label="Summary">
      <div class="stat-box" id="card-today-forecast">
        <div style="font-size:14px;">Today‚Äôs Latest Forecasted High</div>
        <div id="box-today-forecast" class="stat-val">‚Äì</div>
        <div id="mini-today-forecasts" class="mini-forecasts"></div>
        <div class="sparkline-wrap"><canvas id="spark-today-forecast" class="sparkline" width="180" height="30"></canvas></div>
      </div>
      <div class="stat-box" id="card-today-obs">
        <div style="font-size:14px;">Today‚Äôs High So Far (NWS obs)</div>
        <div id="box-today-obs" class="stat-val">‚Äì</div>
        <div id="box-today-obs-note" class="kalshi-small"></div>
      </div>
      <div class="stat-box" id="card-today-actual">
        <div style="font-size:14px;">Today‚Äôs Actual High</div>
        <div id="box-today-actual" class="stat-val">‚Äì</div>
      </div>
      <div class="stat-box" id="card-tomorrow-forecast">
        <div style="font-size:14px;">Tomorrow‚Äôs Forecasted High</div>
        <div id="box-tomorrow-forecast" class="stat-val">‚Äì</div>
      </div>
    </section>

    <!-- Kalshi cards -->
    <section class="stats" aria-label="Kalshi">
      <div class="stat-box" id="card-today-kalshi">
        <div style="font-size:14px;">Today‚Äôs Kalshi Winning Range</div>
        <div id="box-today-kalshi" class="stat-val" style="font-size:18px;">Pending settlement</div>
        <div id="box-today-kalshi-note" class="kalshi-small"></div>
      </div>
      <div class="stat-box" id="card-yday-kalshi">
        <div style="font-size:14px;">Yesterday‚Äôs Kalshi Winning Range</div>
        <div id="box-yday-kalshi" class="stat-val" style="font-size:18px;">‚Äì</div>
        <div id="box-yday-kalshi-note" class="kalshi-small"></div>
      </div>
    </section>

    <!-- Corrected predictions (duo) -->
    <section class="duo" aria-label="Corrected predictions">
      <div id="correctionBoxToday" class="correction-box">
        <div class="big">Loading‚Ä¶</div>
      </div>
      <div id="correctionBoxTomorrow" class="correction-box">
        <div class="big">Loading‚Ä¶</div>
      </div>
    </section>

    <!-- Controls -->
    <section class="controls" aria-label="Filters">
      <label for="fromDate">From:</label><input type="date" id="fromDate" />
      <label for="toDate">To:</label><input type="date" id="toDate" />
      <button class="btn" onclick="applyDateFilter()">Filter</button>
      <button class="btn" onclick="resetFilter()">Show All</button>
      <button class="btn" onclick="reloadCSV()">Reload</button>
    </section>

    <!-- Stats row -->
    <section class="stats" id="stats" aria-label="Metrics">
      <div class="stat-box">Total Days: <span class="stat-val">0</span></div>
      <div class="stat-box">Avg Absolute Error (all forecasts): <span class="stat-val">--¬∞F</span></div>
      <div class="stat-box">Avg Best Error (closest forecast per day): <span class="stat-val">--¬∞F</span></div>
    </section>

    <!-- Chart -->
    <section class="chart" aria-label="Chart">
      <canvas id="dailyChart" width="1000" height="420" role="img" aria-label="Daily actual vs best forecast"></canvas>
    </section>

    <!-- Table -->
    <section class="table-wrap" aria-label="Forecast table">
      <table id="dataTable">
        <thead>
          <tr>
            <th>Date Pulled</th>
            <th>Forecast Time</th>
            <th>For Date</th>
            <th>Forecasted High</th>
            <th>Actual High</th>
            <th>High Time</th>
            <th>Error (¬∞F)</th>
            <th>Best?</th>
            <th>Kalshi Range</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </main>

  <!-- JS (unchanged logic) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    let allRows = [];
    let filteredRows = [];

    function nycISODate(offsetDays=0){
      const fmt = new Intl.DateTimeFormat('en-CA', {
        timeZone:'America/New_York', year:'numeric', month:'2-digit', day:'2-digit'
      });
      const parts = fmt.formatToParts(new Date(Date.now()+offsetDays*86400000));
      const g = k => parts.find(p => p.type === k).value;
      return `${g('year')}-${g('month')}-${g('day')}`;
    }

    function showSkeleton(rows=6){
      const tb=document.querySelector("#dataTable tbody");
      tb.innerHTML="";
      for(let i=0;i<rows;i++){
        const tr=document.createElement("tr");
        tr.className="skel";
        tr.innerHTML="<td></td>".repeat(9);
        tb.appendChild(tr);
      }
    }

    function reloadCSV() {
      showSkeleton();
      fetch("https://raw.githubusercontent.com/hwaheed13/nws-forecast-logger/main/nws_forecast_log.csv?"+Date.now())
        .then(resp => resp.text())
        .then(parseCSV)
        .then(() => {
          resetFilter();
          showMostRecent();
          updateSummaryBoxes();
          updateCorrectionBoxes();
        })
        .catch(err => { alert("Could not load CSV. " + err); });
    }

    function csvToRows(text) {
      const rows = [];
      let row = [], field = '', inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const c = text[i], n = text[i+1];
        if (c === '"') {
          if (inQuotes && n === '"') { field += '"'; i++; }
          else { inQuotes = !inQuotes; }
        } else if (c === ',' && !inQuotes) {
          row.push(field); field = '';
        } else if ((c === '\n' || c === '\r') && !inQuotes) {
          if (c === '\r' && n === '\n') i++;
          row.push(field); field = '';
          if (row.length && row.some(x => x !== '')) rows.push(row);
          row = [];
        } else { field += c; }
      }
      if (field !== '' || row.length) {
        row.push(field);
        if (row.length && row.some(x => x !== '')) rows.push(row);
      }
      return rows;
    }

    function parseCSV(text) {
      const rows = csvToRows(text);
      if (!rows.length) return;
      const header = rows[0].map(h => h.trim());
      allRows = [];
      for (let i = 1; i < rows.length; i++) {
        const vals = rows[i];
        const rec = {};
        for (let j = 0; j < header.length; j++) {
          let v = (vals[j] ?? '').trim();
          if (v.startsWith('"') && v.endsWith('"'))
            v = v.slice(1, -1).replace(/""/g, '"');
          rec[header[j]] = v;
        }
        allRows.push(rec);
      }
    }

    function resetFilter() {
      filteredRows = allRows.slice();
      document.getElementById('fromDate').value = "";
      document.getElementById('toDate').value = "";
      displayTable(); showStats(); showChart();
      showMostRecent(); updateCorrectionBoxes();
    }

    function applyDateFilter() {
      const from = document.getElementById('fromDate').value;
      const to = document.getElementById('toDate').value;
      filteredRows = allRows.filter(row => {
        const date = row.forecast_or_actual === "actual" ? row.cli_date : row.target_date;
        if (!date) return false;
        if (from && date < from) return false;
        if (to && date > to) return false;
        return true;
      });
      displayTable(); showStats(); showChart();
      showMostRecent(); updateCorrectionBoxes();
      updateSummaryBoxes();
    }

    function rNum(x){ const n=Number(x); return Number.isFinite(n)?n:null; }

    function compareTimes(t1,t2) {
      const d1 = toDateObj(t1), d2 = toDateObj(t2);
      return (d1&&d2) ? d1-d2 : 0;
    }

    function toDateObj(t) {
      if (!t) return null;
      if (/[AP]M/i.test(t)) {
        const m = t.match(/(\d{1,2}):(\d{2})\s*([AP]M)/i);
        if (!m) return null;
        const [,h,mn,amp] = m;
        const hour = Number(h)%12 + (amp.toUpperCase()==="PM"?12:0);
        return new Date(2020,1,1,hour,Number(mn));
      }
      if (/^\d{2}:\d{2}$/.test(t)) {
        const [h,mn]=t.split(":");
        return new Date(2020,1,1,Number(h),Number(mn));
      }
      return null;
    }

    function showMostRecent() {
      const el = document.getElementById("recentForecast");
      if (!allRows.length) { el.textContent = ""; return; }
      for (let i = allRows.length - 1; i >= 0; i--) {
        const r = allRows[i];
        if (r && r.forecast_or_actual === "forecast" && r.predicted_high && r.target_date) {
          const when = r.timestamp || r.forecast_time || "(time unknown)";
          el.innerHTML = `Last logged forecast: <b>${when}</b> ‚Äî <b>${r.predicted_high}¬∞F</b> (for <b>${r.target_date}</b>)`;
          return;
        }
      }
      el.textContent = "";
    }

    function getForecastsForDate(dateISO) {
      const rows = allRows
        .filter(r => r.forecast_or_actual === "forecast" && r.target_date === dateISO && r.predicted_high)
        .map(r => ({
          tstamp: r.timestamp || r.forecast_time || "",
          timeHHMM: (r.forecast_time || "").substr(11,5),
          val: Number(r.predicted_high)
        }))
        .filter(x => Number.isFinite(x.val));
      rows.sort((a,b) => (a.tstamp || "").localeCompare(b.tstamp || ""));
      return rows;
    }

    function renderMiniForecastChips(rows, elId) {
      const host = document.getElementById(elId);
      if (!host) return;
      host.innerHTML = "";
      const compact = [];
      rows.forEach((r, i) => { if (i === 0 || r.val !== rows[i-1].val) compact.push(r); });
      if (!compact.length) { host.innerHTML = `<span class="mini-chip">No forecasts yet</span>`; return; }
      compact.forEach(r => {
        const label = `${r.timeHHMM || "‚Äî"} ${r.val.toFixed(0)}¬∞`;
        const chip = document.createElement("span");
        chip.className = "mini-chip";
        chip.textContent = label;
        host.appendChild(chip);
      });
    }

    function drawSparkline(canvasId, rows) {
      const cv = document.getElementById(canvasId);
      if (!cv) return;
      const ctx = cv.getContext('2d');
      ctx.clearRect(0,0,cv.width,cv.height);
      if (!rows.length) return;
      const W = cv.width, H = cv.height, pad = 2;
      const vals = rows.map(r => r.val);
      const min = Math.min(...vals), max = Math.max(...vals);
      if (max === min) {
        const y = H/2;
        ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(W-pad, y);
        ctx.lineWidth = 2; ctx.strokeStyle = '#1976d2'; ctx.stroke();
        ctx.beginPath(); ctx.arc(W-pad, y, 2.5, 0, Math.PI*2);
        ctx.fillStyle = '#2ecc71'; ctx.fill();
        return;
      }
      const n = vals.length;
      const xStep = (W - pad*2) / Math.max(1, n-1);
      const toY = v => H - pad - ((v - min) / (max - min)) * (H - pad*2);
      ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = '#1976d2';
      vals.forEach((v, i) => {
        const x = pad + i * xStep, y = toY(v);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();
      const lastX = pad + (n-1)*xStep, lastY = toY(vals[n-1]);
      ctx.beginPath(); ctx.arc(lastX, lastY, 2.5, 0, Math.PI*2);
      ctx.fillStyle = '#2ecc71'; ctx.fill();
    }

    const KALSHI_PROXY_BASE = "https://kalshi-proxy-theta.vercel.app/api/kalshi";
    async function fetchKalshiWinningRange(dateISO){
      try {
        let r = await fetch(`${KALSHI_PROXY_BASE}?date=${encodeURIComponent(dateISO)}`, {
          mode: "cors", headers: { Accept: "application/json" }, cache: "no-cache"
        });
        if (r.status === 204) return null;
        if (r.status === 304) {
          r = await fetch(`${KALSHI_PROXY_BASE}?date=${encodeURIComponent(dateISO)}&cb=${Date.now()}`, {
            mode: "cors", headers: { Accept: "application/json" }
          });
        }
        if (!r.ok) return null;
        return await r.json();
      } catch { return null; }
    }

    const KALSHI_LIVE_BASE = "https://kalshi-proxy-theta.vercel.app/api/kalshi-live";
    async function fetchKalshiLiveLeader(dateISO){
      try {
        const r = await fetch(`${KALSHI_LIVE_BASE}?date=${encodeURIComponent(dateISO)}`, {
          mode: "cors", headers: { Accept: "application/json" }, cache: "no-cache"
        });
        if (!r.ok) return null;
        return await r.json();
      } catch { return null; }
    }

    const kalshiCache = new Map();
    async function getKalshiLabel(dateISO){
      if (!/^\d{4}-\d{2}-\d{2}$/.test(dateISO)) return null;
      if (kalshiCache.has(dateISO)) {
        const cached = kalshiCache.get(dateISO);
        if (cached === null) {
          const fresh = await fetchKalshiWinningRange(dateISO);
          kalshiCache.set(dateISO, fresh);
          return fresh;
        }
        return cached;
      }
      const data = await fetchKalshiWinningRange(dateISO);
      kalshiCache.set(dateISO, data);
      return data;
    }

    const NWS_OBS_BASE = "https://kalshi-proxy-theta.vercel.app/api/nws-high-so-far";
    async function fetchNwsHighSoFar(station = "KNYC") {
      try {
        const r = await fetch(`${NWS_OBS_BASE}?station=${encodeURIComponent(station)}`, {
          mode: "cors", headers: { Accept: "application/json" }, cache: "no-cache"
        });
        if (!r.ok) return null;
        return await r.json();   // { highF, atISO, station }
      } catch { return null; }
    }

    function updateSummaryBoxes() {
      const today = nycISODate(0);
      const tomorrow = nycISODate(1);
      const yesterday = nycISODate(-1);

      const latestForDate = (date) => {
        const rows = allRows.filter(r =>
          r.forecast_or_actual === "forecast" && r.target_date === date && r.predicted_high
        );
        if (!rows.length) return null;
        rows.sort((a,b) => {
          const A = a.timestamp || a.forecast_time || "";
          const B = b.timestamp || b.forecast_time || "";
          return B.localeCompare(A);
        });
        return Number(rows[0].predicted_high);
      };

      const avgForDate = (date) => {
        const vals = allRows
          .filter(r => r.forecast_or_actual==="forecast" && r.target_date===date && r.predicted_high)
          .map(r => Number(r.predicted_high));
        if (!vals.length) return null;
        return vals.reduce((a,b)=>a+b,0)/vals.length;
      };

      const todayLatestForecast = latestForDate(today);
      const todayActualRow = allRows.find(r => r.forecast_or_actual==="actual" && r.cli_date===today && r.actual_high);
      const todayActual = todayActualRow ? Number(todayActualRow.actual_high) : null;
      const tomorrowAvgForecast = avgForDate(tomorrow);

      document.getElementById("box-today-forecast").textContent =
        (todayLatestForecast==null) ? "‚Äì" : todayLatestForecast.toFixed(1) + "¬∞F";
      document.getElementById("box-today-actual").textContent =
        (todayActual==null) ? "‚Äì" : todayActual.toFixed(1) + "¬∞F";
      document.getElementById("box-tomorrow-forecast").textContent =
        (tomorrowAvgForecast==null) ? "‚Äì" : tomorrowAvgForecast.toFixed(1) + "¬∞F";

      const todayRows = getForecastsForDate(today);
      renderMiniForecastChips(todayRows, "mini-today-forecasts");
      drawSparkline("spark-today-forecast", todayRows);

      Promise.all([ getKalshiLabel(today), getKalshiLabel(yesterday) ])
        .then(async ([ktoday, kyday]) => {
          const tBox = document.getElementById('box-today-kalshi');
          const tNote = document.getElementById('box-today-kalshi-note');
          const yBox = document.getElementById('box-yday-kalshi');
          const yNote = document.getElementById('box-yday-kalshi-note');

          if (kyday && kyday.label) {
            yBox.innerHTML = `<span class="kalshi-badge"><a class="kalshi-link" href="${kyday.url}" target="_blank" rel="noopener">${kyday.label}</a></span>`;
            yNote.textContent = kyday.exactTemp != null ? `Settled at ${kyday.exactTemp.toFixed(1)}¬∞F.` : "";
          } else {
            yBox.innerHTML = `<span class="kalshi-pending">No data</span>`;
            yNote.textContent = "";
          }

          if (ktoday && ktoday.label) {
            tBox.innerHTML = `<span class="kalshi-badge"><a class="kalshi-link" href="${ktoday.url}" target="_blank" rel="noopener">${ktoday.label}</a></span>`;
            tNote.textContent = ktoday.exactTemp != null ? `Settled at ${ktoday.exactTemp.toFixed(1)}¬∞F.` : "";
          } else {
            const live = await fetchKalshiLiveLeader(today);
            if (live && live.leadingLabel) {
              const pct = (live.leadingProb != null) ? ` (${Math.round(live.leadingProb*100)}%)` : "";
              tBox.innerHTML = `<span class="kalshi-badge"><a class="kalshi-link" href="${live.url}" target="_blank" rel="noopener">${live.leadingLabel}${pct}</a></span>`;
              tNote.textContent = "Live leader (can flip before settlement).";
            } else {
              tBox.innerHTML = `<span class="kalshi-pending">Pending settlement</span>`;
              tNote.textContent = "Closes 11:59 PM ET; settles after NWS daily report.";
            }
          }
        })
        .catch(() => {
          const tBox = document.getElementById('box-today-kalshi');
          const tNote = document.getElementById('box-today-kalshi-note');
          if (tBox) tBox.innerHTML = `<span class="kalshi-pending">Pending settlement</span>`;
          if (tNote) tNote.textContent = "Closes 11:59 PM ET; settles after NWS daily report.";
        });
    }

    fetchNwsHighSoFar("KNYC").then(obs => {
      const el = document.getElementById("box-today-obs");
      const note = document.getElementById("box-today-obs-note");
      if (!el || !note) return;
      if (obs && obs.highF != null) {
        el.textContent = `${Number(obs.highF).toFixed(1)}¬∞F`;
        const ts = obs.atISO ? new Date(obs.atISO) : null;
        const tNY = ts
          ? new Intl.DateTimeFormat("en-US", { timeZone: "America/New_York", hour: "numeric", minute: "2-digit" }).format(ts)
          : "";
        note.textContent = tNY ? `as of ${tNY} ET ‚Ä¢ station ${obs.station}` : `station ${obs.station}`;
      } else {
        el.textContent = "‚Äì"; note.textContent = "";
      }
    });

    function calcBiases(){
      const biasList = [], dayMap = {};
      allRows.forEach(r => {
        const d = r.forecast_or_actual==="actual" ? r.cli_date : r.target_date;
        if(!d) return;
        if(!dayMap[d]) dayMap[d] = [];
        dayMap[d].push(r);
      });
      const dates = Object.keys(dayMap).sort();
      dates.forEach(d => {
        const rows = dayMap[d];
        const actual = rows.find(r => r.forecast_or_actual==="actual" && r.actual_high);
        if(!actual) return;
        const actualHigh = Number(actual.actual_high);
        const highTime = actual.high_time || "";
        const fcVals = [];
        rows.forEach(r => {
          if(r.forecast_or_actual!=="forecast" || !r.predicted_high) return;
          if (highTime) {
            const fcHHMM = (r.forecast_time||"").substr(11,5);
            if (fcHHMM && compareTimes(fcHHMM, highTime) > 0) return;
          }
          fcVals.push(Number(r.predicted_high));
        });
        if(fcVals.length){
          const meanFc = fcVals.reduce((a,b)=>a+b,0)/fcVals.length;
          biasList.push(actualHigh - meanFc);
        }
      });
      return biasList;
    }

    function updateCorrectionBoxes(){
      const biasList=calcBiases();
      const avgBias=biasList.length? (biasList.reduce((a,b)=>a+b,0)/biasList.length) : 0;
      const today = nycISODate(0);
      const tomorrow = nycISODate(1);

      const meanForecastForDate = (date) => {
        const actual = allRows.find(r=>r.forecast_or_actual==="actual" && r.cli_date===date && r.actual_high);
        const highTime = actual ? actual.high_time : "";
        const vals = allRows
          .filter(r=>r.forecast_or_actual==="forecast" && r.target_date===date && r.predicted_high)
          .filter(r=>{
            if(highTime){
              const fcHHMM=(r.forecast_time||"").substr(11,5);
              if(fcHHMM && compareTimes(fcHHMM, highTime) > 0) return false;
            }
            return true;
          })
          .map(r=>Number(r.predicted_high));
        if (!vals.length) return null;
        return vals.reduce((a,b)=>a+b,0)/vals.length;
      };

      const todayFcAvg = meanForecastForDate(today);
      const tomorrowFcAvg = meanForecastForDate(tomorrow);
      const todayPred = (todayFcAvg==null) ? null : todayFcAvg + avgBias;
      const tomorrowPred = (tomorrowFcAvg==null) ? null : tomorrowFcAvg + avgBias;
      const biasTxt = (avgBias>0?"+":"") + avgBias.toFixed(2);

      document.getElementById("correctionBoxToday").innerHTML =
        `<b>Today's Corrected Prediction:</b><br>
         <span class="big">${today}: <b>${todayPred==null?"‚Äì":todayPred.toFixed(1)+"¬∞F"}</b></span><br>
         <span style="color:#666;">Bias: <b>${biasTxt}¬∞F</b> (avg of ${biasList.length} days)</span>`;

      document.getElementById("correctionBoxTomorrow").innerHTML =
        `<b>Tomorrow's Corrected Prediction:</b><br>
         <span class="big">${tomorrow}: <b>${tomorrowPred==null?"‚Äì":tomorrowPred.toFixed(1)+"¬∞F"}</b></span><br>
         <span style="color:#666;">Bias: <b>${biasTxt}¬∞F</b> (avg of ${biasList.length} days)</span>`;
    }

    function showStats() {
      let count=0, absSum=0, bestSum=0, bestCount=0;
      const dayMap = {};
      filteredRows.forEach(row => {
        const date = row.forecast_or_actual === "actual" ? row.cli_date : row.target_date;
        if (!date) return;
        if (!dayMap[date]) dayMap[date] = [];
        dayMap[date].push(row);
      });
      Object.values(dayMap).forEach(dayRows => {
        const actual = dayRows.find(r => r.forecast_or_actual==="actual");
        const actualHigh = actual ? Number(actual.actual_high) : null;
        if (!Number.isFinite(actualHigh)) return;
        const highTime = actual ? actual.high_time : "";
        let bestErr=999;
        dayRows.forEach(r => {
          if (r.forecast_or_actual!=="forecast" || !r.predicted_high) return;
          if (highTime) {
            const fcHour = (r.forecast_time||"").substr(11,5);
            if (fcHour && compareTimes(fcHour, highTime)>0) return;
          }
          const err = Math.abs(Number(r.predicted_high)-actualHigh);
          absSum += err; count++;
          if (err<bestErr) bestErr=err;
        });
        if (bestErr<999) { bestSum += bestErr; bestCount++; }
      });
      const avgAbs = count ? (absSum/count).toFixed(2) : "--";
      const avgBest = bestCount ? (bestSum/bestCount).toFixed(2) : "--";
      document.getElementById("stats").innerHTML =
        `<div class="stat-box">Total Days: <span class="stat-val">${Object.keys(dayMap).length}</span></div>
         <div class="stat-box">Avg Absolute Error (all forecasts): <span class="stat-val">${avgAbs}¬∞F</span></div>
         <div class="stat-box">Avg Best Error (closest forecast per day): <span class="stat-val">${avgBest}¬∞F</span></div>`;
    }

    async function displayTable() {
      const tb = document.querySelector("#dataTable tbody");
      tb.innerHTML = "";
      const dayMap = {};
      filteredRows.forEach(r => {
        const date = r.forecast_or_actual === "actual" ? r.cli_date : r.target_date;
        if (!date) return;
        if (!dayMap[date]) dayMap[date] = [];
        dayMap[date].push(r);
      });

      const isISODate = d => /^\d{4}-\d{2}-\d{2}$/.test(d);
      const dates = Object.keys(dayMap).filter(isISODate).sort();

      const kalshiByDate = {};
      await Promise.all(dates.map(async d => {
        try { kalshiByDate[d] = await getKalshiLabel(d); }
        catch { kalshiByDate[d] = null; }
      }));

      dates.forEach(date => {
        const dayRows = dayMap[date];
        const actual = dayRows.find(r => r.forecast_or_actual==="actual");
        const actualHigh = actual ? rNum(actual.actual_high) : null;
        const actualHighTxt = actual && actual.actual_high ? actual.actual_high+"¬∞F" : "";
        const highTime = actual ? actual.high_time : "";
        let bestIdx=-1, bestErr=999;

        dayRows.forEach((r,i) => {
          if (r.forecast_or_actual !== "forecast" || !r.predicted_high || actualHigh===null) return;
          if (highTime) {
            const fcHour = (r.forecast_time||"").substr(11,5);
            if (fcHour && compareTimes(fcHour, highTime)>0) return;
          }
          const err = Math.abs(Number(r.predicted_high)-actualHigh);
          if (err<bestErr) { bestErr=err; bestIdx=i; }
        });

        const k = kalshiByDate[date];
        const label = k && k.label ? k.label : "";
        const exact = k && k.exactTemp != null ? ` (${k.exactTemp.toFixed(1)}¬∞F)` : "";
        const kalshiCell = label
          ? `<span class="kalshi-badge" title="Kalshi settled range">${label}${exact}</span>`
          : `<span class="kalshi-small">‚Äî</span>`;

        dayRows.forEach((r,i) => {
          if (r.forecast_or_actual!=="forecast" && r.forecast_or_actual!=="actual") return;
          let cls = r.forecast_or_actual==="actual" ? "actual-row" : "forecast-row";
          if (i===bestIdx && r.forecast_or_actual==="forecast") cls += " best";
          const pred = r.predicted_high ? r.predicted_high+"¬∞F" : "";
          const act = r.actual_high ? r.actual_high+"¬∞F" : actualHighTxt;
          const fTime = r.forecast_time ? r.forecast_time.substr(11,5) : "";
          const errTxt = (r.forecast_or_actual==="forecast" && r.predicted_high && actualHigh!==null)
            ? (Number(r.predicted_high)-actualHigh).toFixed(1) : "";
          tb.innerHTML += `
            <tr class="${cls}">
              <td>${r.timestamp ? r.timestamp.substr(0,10) : ""}</td>
              <td>${fTime}</td>
              <td>${date}</td>
              <td>${pred}</td>
              <td>${act}</td>
              <td>${highTime}</td>
              <td>${errTxt}</td>
              <td>${(i===bestIdx && r.forecast_or_actual==="forecast") ? "‚úîÔ∏è" : ""}</td>
              <td>${kalshiCell}</td>
            </tr>`;
        });
      });
    }

    reloadCSV();
    setInterval(() => { updateSummaryBoxes(); }, 10 * 60 * 1000);
  </script>

  <footer>
    ¬© 2025 Dewdrop Ventures, LLC ¬∑
    <a href="/terms.html">Terms</a> ¬∑
    <a href="/privacy.html">Privacy</a> ¬∑
    <span>Informational only ‚Äî not financial advice. Do your own due diligence before placing any bets or making financial decisions.</span>
  </footer>
</body>
</html>
